<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Porcelain Transcendence — Enhanced Engine</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html, body, #container {
            height: 100%;
            width: 100%;
        }
        body {
            background: #000;
            color: #fff;
            font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
            overflow: hidden;
        }
        #container {
            position: fixed;
            inset: 0;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        .ui {
            position: absolute;
            z-index: 60;
            inset: 0;
            pointer-events: none;
        }
        .panel {
            pointer-events: auto;
            position: absolute;
            background: rgba(0,0,0,0.45);
            backdrop-filter: blur(6px);
            border: 1px solid rgba(255,255,255,0.05);
            padding: 10px 12px;
            border-radius: 10px;
            font-size: 13px;
            line-height: 1.4;
        }
        .top-left {
            left: 16px;
            top: 16px;
        }
        .top-right {
            right: 16px;
            top: 16px;
            text-align: right;
        }
        .bottom-left {
            left: 16px;
            bottom: 16px;
        }
        .scene-indicator {
            font-weight: 600;
            opacity: 0.95;
        }
        .small {
            font-size: 12px;
            opacity: 0.8;
        }
        .loading {
            position: fixed;
            inset: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="container" role="application" aria-label="Porcelain Transcendence canvas"></div>
    <div class="loading" id="loading">Initializing Enhanced Engine...</div>
    <div class="ui" aria-hidden="false">
        <div class="panel top-left" role="region" aria-label="Scene information">
            <div id="sceneLabel" class="scene-indicator" role="status" aria-live="polite">Scene 1 / 5 — Dawn Vessel</div>
            <div class="small">← → : Change Scene • SPACE : Toggle Motion • Click : Reactive Pulse</div>
        </div>
        <div class="panel top-right" role="region" aria-label="Effects toggles">
            <label><input id="toggleBloom" type="checkbox" checked> Bloom</label><br>
            <label><input id="toggleDOF" type="checkbox"> DOF</label><br>
            <label><input id="toggleParticles" type="checkbox" checked> Particles</label><br>
            <label><input id="toggleScanner" type="checkbox"> Material Scanner</label><br>
            <label><input id="toggleTemporal" type="checkbox"> Day/Night Cycle</label>
            <label><input id="toggleWater" type="checkbox" checked> Water Surface</label>
        </div>
        <div class="panel bottom-left" role="region" aria-label="Controls">
            <div class="small">DRAG: Orbit • PINCH: Zoom • SCROLL: Stage Chapters</div>
            <div class="small" id="timeDisplay">Time: 12:00 PM</div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
        import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // ---------- Core Engine Setup ----------
        const container = document.getElementById('container');
        const loading = document.getElementById('loading');
        const DPR = Math.min(window.devicePixelRatio || 1, 2);
        const WIDTH = () => window.innerWidth;
        const HEIGHT = () => window.innerHeight;

        // ---------- Enhanced Scene Setup ----------
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000010);
        scene.fog = new THREE.FogExp2(0x000010, 0.035);

        const camera = new THREE.PerspectiveCamera(45, WIDTH()/HEIGHT(), 0.05, 2000);
        camera.position.set(8, 4.5, 9);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setPixelRatio(DPR);
        renderer.setSize(WIDTH(), HEIGHT());
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.9;
        renderer.physicallyCorrectLights = true;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // ---------- Enhanced Controls ----------
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.maxPolarAngle = Math.PI * 0.495;
        controls.enableZoom = false;
        controls.minDistance = 1.6;
        controls.maxDistance = 40;

        // ---------- Enhanced Post-Processing ----------
        const composer = new EffectComposer(renderer);
        composer.setSize(WIDTH(), HEIGHT());
        composer.setPixelRatio(DPR);

        composer.addPass(new RenderPass(scene, camera));

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(WIDTH(), HEIGHT()), 0.55, 0.6, 0.85);
        composer.addPass(bloomPass);

        const bokehPass = new BokehPass(scene, camera, {
            focus: 20.0,
            aperture: 0.0009,
            maxblur: 0.01,
            width: WIDTH(),
            height: HEIGHT()
        });
        bokehPass.enabled = false;
        composer.addPass(bokehPass);

        const smaaPass = new SMAAPass(WIDTH(), HEIGHT());
        composer.addPass(smaaPass);

        // ---------- Water Surface System ----------
        class WaterSurface {
            constructor(size = 200, resolution = 256) {
                this.size = size;
                this.resolution = resolution;
                this.mesh = null;
                this.texture = null;
                this.enabled = true;
                
                this.ripples = [];
                this.waves = [];
                
                this.init();
            }
            
            init() {
                // Create water geometry
                const geometry = new THREE.PlaneGeometry(this.size, this.size, this.resolution, this.resolution);
                
                // Create water material with custom shader
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uResolution: { value: new THREE.Vector2(this.resolution, this.resolution) },
                        uSize: { value: this.size },
                        uRippleData: { value: null },
                        uWaveData: { value: null },
                        uRippleCount: { value: 0 },
                        uWaveCount: { value: 0 },
                        uDayNight: { value: 0.5 },
                        uCameraPosition: { value: new THREE.Vector3() },
                        uLightDirection: { value: new THREE.Vector3(0, 1, 0) }
                    },
                    vertexShader: `
                        uniform float uTime;
                        uniform vec2 uResolution;
                        uniform float uSize;
                        uniform sampler2D uRippleData;
                        uniform sampler2D uWaveData;
                        uniform int uRippleCount;
                        uniform int uWaveCount;
                        uniform float uDayNight;
                        uniform vec3 uCameraPosition;
                        
                        varying vec2 vUv;
                        varying vec3 vWorldPosition;
                        varying float vDepth;
                        varying float vFoam;
                        
                        void main() {
                            vUv = uv;
                            
                            // Base position
                            vec3 pos = position;
                            
                            // Apply ripples
                            float height = 0.0;
                            float foam = 0.0;
                            
                            // Process ripples
                            for (int i = 0; i < 20; i++) {
                                if (i >= uRippleCount) break;
                                
                                vec4 ripple = texelFetch(uRippleData, ivec2(i, 0), 0);
                                vec2 center = ripple.xy;
                                float radius = ripple.z;
                                float intensity = ripple.w;
                                
                                vec2 worldPos = (uv - 0.5) * uSize;
                                float dist = distance(worldPos, center);
                                
                                if (dist < radius) {
                                    float falloff = 1.0 - smoothstep(0.0, radius, dist);
                                    float wave = sin(dist * 15.0 - uTime * 8.0) * 0.5 + 0.5;
                                    height += wave * falloff * intensity * 0.3;
                                    foam += falloff * intensity * 0.5;
                                }
                            }
                            
                            // Process waves
                            for (int i = 0; i < 10; i++) {
                                if (i >= uWaveCount) break;
                                
                                vec4 wave = texelFetch(uWaveData, ivec2(i, 0), 0);
                                vec2 direction = wave.xy;
                                float speed = wave.z;
                                float amplitude = wave.w;
                                
                                vec2 worldPos = (uv - 0.5) * uSize;
                                float wavePos = dot(worldPos, direction) * 0.1;
                                height += sin(wavePos + uTime * speed) * amplitude * 0.1;
                            }
                            
                            // Apply height displacement
                            pos.y += height;
                            
                            // Calculate depth for coloring
                            vDepth = height;
                            vFoam = foam;
                            
                            vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                            vWorldPosition = worldPosition.xyz;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float uTime;
                        uniform float uDayNight;
                        uniform vec3 uCameraPosition;
                        uniform vec3 uLightDirection;
                        
                        varying vec2 vUv;
                        varying vec3 vWorldPosition;
                        varying float vDepth;
                        varying float vFoam;
                        
                        void main() {
                            // Day/night color variation
                            vec3 dayColor = vec3(0.1, 0.3, 0.6);
                            vec3 nightColor = vec3(0.02, 0.05, 0.15);
                            vec3 waterColor = mix(nightColor, dayColor, uDayNight);
                            
                            // Add depth-based color variation
                            float depthFactor = clamp(vDepth * 5.0, 0.0, 1.0);
                            waterColor = mix(waterColor * 0.7, waterColor, depthFactor);
                            
                            // Foam effect
                            vec3 foamColor = vec3(0.9, 0.95, 1.0);
                            float foam = smoothstep(0.3, 0.8, vFoam);
                            waterColor = mix(waterColor, foamColor, foam * 0.3);
                            
                            // Specular highlights based on day/night
                            vec3 viewDir = normalize(uCameraPosition - vWorldPosition);
                            float specular = pow(max(0.0, dot(reflect(-uLightDirection, vec3(0,1,0)), viewDir)), 32.0);
                            specular *= uDayNight * 0.5;
                            
                            // Final color with specular
                            vec3 finalColor = waterColor + vec3(specular);
                            
                            // Add subtle noise for texture
                            float noise = fract(sin(dot(vUv, vec2(12.9898, 78.233))) * 43758.5453);
                            finalColor += (noise - 0.5) * 0.02;
                            
                            gl_FragColor = vec4(finalColor, 0.9);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                
                // Create water mesh
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.rotation.x = -Math.PI / 2;
                this.mesh.position.y = -0.1;
                this.mesh.receiveShadow = true;
                
                // Create data textures for ripples and waves
                this.rippleDataTexture = new THREE.DataTexture(
                    new Float32Array(20 * 4), 20, 1, THREE.RGBAFormat, THREE.FloatType
                );
                this.waveDataTexture = new THREE.DataTexture(
                    new Float32Array(10 * 4), 10, 1, THREE.RGBAFormat, THREE.FloatType
                );
                
                material.uniforms.uRippleData.value = this.rippleDataTexture;
                material.uniforms.uWaveData.value = this.waveDataTexture;
                
                scene.add(this.mesh);
                
                // Initialize some gentle waves
                this.createGentleWaves();
            }
            
            createGentleWaves() {
                this.waves = [];
                const waveDirections = [
                    new THREE.Vector2(1, 0), new THREE.Vector2(0.7, 0.7),
                    new THREE.Vector2(0, 1), new THREE.Vector2(-0.7, 0.7)
                ];
                
                waveDirections.forEach(dir => {
                    this.waves.push({
                        direction: dir,
                        speed: 0.5 + Math.random() * 0.5,
                        amplitude: 0.1 + Math.random() * 0.1
                    });
                });
            }
            
            addRipple(center, intensity = 1.0, radius = 8.0) {
                this.ripples.push({
                    center: center.clone(),
                    radius: radius,
                    intensity: intensity,
                    age: 0,
                    maxAge: 3.0
                });
                
                // Limit number of ripples
                if (this.ripples.length > 20) {
                    this.ripples.shift();
                }
            }
            
            addSplash(center, count = 5) {
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const distance = 0.5 + Math.random() * 2;
                    const splashCenter = new THREE.Vector2(
                        center.x + Math.cos(angle) * distance,
                        center.y + Math.sin(angle) * distance
                    );
                    this.addRipple(splashCenter, 0.3, 2.0 + Math.random() * 3);
                }
            }
            
            update(delta, time, dayNightValue, cameraPosition) {
                if (!this.enabled || !this.mesh) return;
                
                const material = this.mesh.material;
                material.uniforms.uTime.value = time;
                material.uniforms.uDayNight.value = dayNightValue;
                material.uniforms.uCameraPosition.value.copy(cameraPosition);
                
                // Update ripples
                for (let i = this.ripples.length - 1; i >= 0; i--) {
                    const ripple = this.ripples[i];
                    ripple.age += delta;
                    ripple.intensity *= 0.95;
                    ripple.radius += delta * 8;
                    
                    if (ripple.age >= ripple.maxAge || ripple.intensity < 0.01) {
                        this.ripples.splice(i, 1);
                    }
                }
                
                // Update ripple data texture
                const rippleData = this.rippleDataTexture.image.data;
                for (let i = 0; i < 20; i++) {
                    if (i < this.ripples.length) {
                        const ripple = this.ripples[i];
                        rippleData[i * 4] = ripple.center.x;
                        rippleData[i * 4 + 1] = ripple.center.y;
                        rippleData[i * 4 + 2] = ripple.radius;
                        rippleData[i * 4 + 3] = ripple.intensity;
                    } else {
                        rippleData[i * 4] = 0;
                        rippleData[i * 4 + 1] = 0;
                        rippleData[i * 4 + 2] = 0;
                        rippleData[i * 4 + 3] = 0;
                    }
                }
                this.rippleDataTexture.needsUpdate = true;
                material.uniforms.uRippleCount.value = this.ripples.length;
                
                // Update wave data texture
                const waveData = this.waveDataTexture.image.data;
                for (let i = 0; i < 10; i++) {
                    if (i < this.waves.length) {
                        const wave = this.waves[i];
                        waveData[i * 4] = wave.direction.x;
                        waveData[i * 4 + 1] = wave.direction.y;
                        waveData[i * 4 + 2] = wave.speed;
                        waveData[i * 4 + 3] = wave.amplitude;
                    } else {
                        waveData[i * 4] = 0;
                        waveData[i * 4 + 1] = 0;
                        waveData[i * 4 + 2] = 0;
                        waveData[i * 4 + 3] = 0;
                    }
                }
                this.waveDataTexture.needsUpdate = true;
                material.uniforms.uWaveCount.value = this.waves.length;
            }
            
            setEnabled(enabled) {
                this.enabled = enabled;
                if (this.mesh) {
                    this.mesh.visible = enabled;
                }
            }
        }

        // Initialize water surface
        const waterSurface = new WaterSurface(200, 256);

        // ---------- Material Scanner Shader ----------
        const scannerPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                uTime: { value: 0 },
                uScannerPos: { value: new THREE.Vector3() },
                uScannerRadius: { value: 3.0 },
                uScannerIntensity: { value: 0.0 },
                uScannerEnabled: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vWorldPos;
                void main() {
                    vUv = uv;
                    vec4 worldPos = modelMatrix * vec4(position, 1.0);
                    vWorldPos = worldPos.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float uTime;
                uniform vec3 uScannerPos;
                uniform float uScannerRadius;
                uniform float uScannerIntensity;
                uniform float uScannerEnabled;
                varying vec2 vUv;
                varying vec3 vWorldPos;
                
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    if (uScannerEnabled > 0.5) {
                        float dist = distance(vWorldPos, uScannerPos);
                        float scan = 1.0 - smoothstep(0.0, uScannerRadius, dist);
                        float pulse = sin(uTime * 8.0) * 0.5 + 0.5;
                        float scannerEffect = scan * pulse * uScannerIntensity;
                        // Add emissive glow and color shift
                        color.rgb += vec3(0.3, 0.6, 1.0) * scannerEffect * 0.8;
                        color.rgb = mix(color.rgb, color.rgb * vec3(1.1, 1.2, 1.4), scannerEffect * 0.3);
                    }
                    gl_FragColor = color;
                }
            `
        });
        scannerPass.enabled = false;
        composer.addPass(scannerPass);

        // ---------- Environment Setup ----------
        let pmrem = new THREE.PMREMGenerator(renderer);
        pmrem.compileEquirectangularShader();
        let currentEnv = null;

        function assignEnvironment(envTex) {
            if (currentEnv && currentEnv.dispose) {
                try { currentEnv.dispose(); } catch (e) {}
            }
            currentEnv = envTex;
            scene.environment = currentEnv;
        }

        // Placeholder environment
        (function bakePlaceholder() {
            const cubeUrls = new Array(6).fill('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==');
            const tmp = new THREE.CubeTextureLoader().load(cubeUrls, () => {
                const envRT = pmrem.fromCubemap(tmp).texture;
                try { tmp.dispose(); } catch(e) {}
                assignEnvironment(envRT);
            });
        })();

        // Try load HDR
        const rgbeLoader = new RGBELoader();
        rgbeLoader.setDataType(THREE.UnsignedByteType);
        rgbeLoader.load('textures/studio_small_04_1k.hdr', (hdr) => {
            hdr.mapping = THREE.EquirectangularReflectionMapping;
            const envRT = pmrem.fromEquirectangular(hdr).texture;
            try { hdr.dispose && hdr.dispose(); } catch (e) {}
            assignEnvironment(envRT);
            try { pmrem.dispose(); } catch (e) {}
            pmrem = new THREE.PMREMGenerator(renderer);
        }, undefined, (err) => {
            console.warn('HDR failed to load (optional):', err);
        });

        // ---------- Enhanced Ground System ----------
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(400,400),
            new THREE.MeshStandardMaterial({ color: 0x040405, roughness: 0.85 })
        );
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        scene.add(ground);

        const disc = new THREE.Mesh(
            new THREE.CircleGeometry(10, 64),
            new THREE.MeshStandardMaterial({ color: 0x0e0e10, roughness: 0.45, metalness: 0.04 })
        );
        disc.rotation.x = -Math.PI/2;
        disc.position.y = 0.001;
        disc.receiveShadow = true;
        scene.add(disc);

        // ---------- Enhanced Cursor System ----------
        function generateGlowTexture(size = 512, color = '#fff3d9') {
            const c = document.createElement('canvas');
            c.width = c.height = size;
            const ctx = c.getContext('2d');
            const cx = size/2, cy = size/2;
            const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, size/2);
            g.addColorStop(0.0, color);
            g.addColorStop(0.25, color);
            g.addColorStop(0.6, 'rgba(255,243,217,0.45)');
            g.addColorStop(1.0, 'rgba(255,243,217,0.0)');
            ctx.fillStyle = g;
            ctx.fillRect(0,0,size,size);
            const tx = new THREE.CanvasTexture(c);
            tx.minFilter = THREE.LinearFilter;
            tx.magFilter = THREE.LinearFilter;
            tx.needsUpdate = true;
            return tx;
        }

        const cursorLight = new THREE.PointLight(0xfff7ea, 0.0, 28, 2.2);
        cursorLight.castShadow = false;
        scene.add(cursorLight);

        const cursorBall = new THREE.Mesh(
            new THREE.SphereGeometry(0.06, 12, 12),
            new THREE.MeshBasicMaterial({ color: 0xfff3d9 })
        );
        cursorBall.frustumCulled = false;
        scene.add(cursorBall);

        const glow = new THREE.Sprite(new THREE.SpriteMaterial({
            map: generateGlowTexture(512, '#fff3d9'),
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.65,
            depthWrite: false
        }));
        glow.scale.setScalar(0.8);
        scene.add(glow);

        // ---------- Enhanced Particle System ----------
        const pulsePool = [];
        const activePulses = [];

        function createPulse(count = 80) {
            const geom = new THREE.BufferGeometry();
            const pos = new Float32Array(count*3);
            const vel = new Float32Array(count*3);
            const colors = new Float32Array(count*3);
            for (let i = 0; i < count; i++) {
                colors[i*3] = 1.0; // R
                colors[i*3+1] = 0.9; // G
                colors[i*3+2] = 0.8; // B
            }
            geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geom.setAttribute('vel', new THREE.BufferAttribute(vel, 3));
            geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({
                size: 0.05,
                transparent: true,
                opacity: 1,
                depthWrite: false,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            const pts = new THREE.Points(geom, mat);
            pts.userData = { life: 0, count };
            return pts;
        }

        function getPulse(count = 80) {
            if (pulsePool.length) return pulsePool.pop();
            return createPulse(count);
        }

        function recyclePulse(pts) {
            pts.visible = false;
            pts.userData.life = 0;
            pulsePool.push(pts);
        }

        function spawnPulse(pos3, color = 0xfff0d8, count = 80) {
            const pts = getPulse(count);
            const posAttr = pts.geometry.attributes.position;
            const velAttr = pts.geometry.attributes.vel;
            const colorAttr = pts.geometry.attributes.color;
            const r = ((color >> 16) & 255) / 255;
            const g = ((color >> 8) & 255) / 255;
            const b = (color & 255) / 255;

            for (let i = 0; i < pts.userData.count; i++) {
                const phi = Math.acos(2*Math.random()-1);
                const theta = Math.random()*Math.PI*2;
                const radius = 0.02 + Math.random()*0.08;
                posAttr.array[i*3] = pos3.x + radius*Math.sin(phi)*Math.cos(theta);
                posAttr.array[i*3+1] = pos3.y + radius*Math.cos(phi);
                posAttr.array[i*3+2] = pos3.z + radius*Math.sin(phi)*Math.sin(theta);
                velAttr.array[i*3] = (Math.random()-0.5)*0.9;
                velAttr.array[i*3+1] = Math.random()*1.2 + 0.2;
                velAttr.array[i*3+2] = (Math.random()-0.5)*0.9;
                // Color variation
                colorAttr.array[i*3] = r * (0.8 + Math.random()*0.2);
                colorAttr.array[i*3+1] = g * (0.8 + Math.random()*0.2);
                colorAttr.array[i*3+2] = b * (0.8 + Math.random()*0.2);
            }
            posAttr.needsUpdate = true;
            velAttr.needsUpdate = true;
            colorAttr.needsUpdate = true;
            pts.userData.life = 1.0;
            pts.visible = true;
            if (!pts.parent) scene.add(pts);
            activePulses.push(pts);
        }

        // ---------- Enhanced Instanced Particle System ----------
        function createInstancedParticles(maxInstances = 2000, texture=null) {
            const geom = new THREE.PlaneGeometry(1,1);
            const inst = new THREE.InstancedBufferGeometry();
            inst.index = geom.index;
            inst.attributes.position = geom.attributes.position;
            inst.attributes.uv = geom.attributes.uv;

            const offsets = new Float32Array(maxInstances * 3);
            const sizes = new Float32Array(maxInstances);
            const hues = new Float32Array(maxInstances);
            const phases = new Float32Array(maxInstances);
            const drag = new Float32Array(maxInstances);
            const velocities = new Float32Array(maxInstances * 3);

            for (let i=0;i<maxInstances;i++){
                offsets[i*3] = (Math.random()-0.5)*20;
                offsets[i*3+1] = (Math.random())*10;
                offsets[i*3+2] = (Math.random()-0.5)*20;
                sizes[i] = Math.random() * 0.6 + 0.1;
                hues[i] = Math.random();
                phases[i] = Math.random() * Math.PI * 2;
                drag[i] = Math.random() * 0.12 + 0.02;
                // Initial velocities for physics
                velocities[i*3] = (Math.random()-0.5)*0.1;
                velocities[i*3+1] = Math.random()*0.05;
                velocities[i*3+2] = (Math.random()-0.5)*0.1;
            }

            inst.setAttribute('offset', new THREE.InstancedBufferAttribute(offsets, 3));
            inst.setAttribute('sizeAttr', new THREE.InstancedBufferAttribute(sizes, 1));
            inst.setAttribute('hue', new THREE.InstancedBufferAttribute(hues, 1));
            inst.setAttribute('phase', new THREE.InstancedBufferAttribute(phases, 1));
            inst.setAttribute('drag', new THREE.InstancedBufferAttribute(drag, 1));
            inst.setAttribute('velocity', new THREE.InstancedBufferAttribute(velocities, 3));

            const material = new THREE.ShaderMaterial({
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                uniforms: {
                    uTime: { value: 0 },
                    map: { value: texture },
                    uColorGrade: { value: new THREE.Vector3(1,1,1) },
                    uOpacity: { value: 0.7 },
                    uGravity: { value: -0.1 },
                    uTemporalFactor: { value: 1.0 }
                },
                vertexShader: `
                    attribute vec3 offset;
                    attribute float sizeAttr;
                    attribute float hue;
                    attribute float phase;
                    attribute float drag;
                    attribute vec3 velocity;
                    uniform float uTime;
                    uniform float uGravity;
                    uniform float uTemporalFactor;
                    varying float vHue;
                    varying float vPhase;
                    
                    void main(){
                        float t = uTime * (0.2 + drag) * uTemporalFactor;
                        vec3 pos = offset;
                        vec3 vel = velocity;
                        // Enhanced physics with gravity
                        vel.y += uGravity * t;
                        pos += vel * t;
                        // Reset particles that fall too low
                        if(pos.y < -5.0) {
                            pos.y = 10.0;
                            vel = vec3((fract(sin(dot(vec2(phase),vec2(12.9898,78.233)))*43758.5453)-0.5)*0.2,
                                      fract(sin(dot(vec2(phase+1.0),vec2(12.9898,78.233)))*43758.5453)*0.1,
                                      (fract(sin(dot(vec2(phase+2.0),vec2(12.9898,78.233)))*43758.5453)-0.5)*0.2);
                        }
                        // Procedural motion with temporal influence
                        pos.x += sin(t * 2.0 + phase) * 0.3 * uTemporalFactor;
                        pos.y += sin((t*0.7) + phase*0.5) * 0.2;
                        pos.z += cos(t * 1.5 + phase) * 0.25 * uTemporalFactor;
                        
                        vec4 mvPosition = modelMatrix * vec4(pos, 1.0);
                        vec4 worldPos = mvPosition;
                        vec4 mv = viewMatrix * worldPos;
                        vec3 scale = vec3(sizeAttr);
                        vec4 finalPos = projectionMatrix * (mv + vec4(position.xy * scale, 0.0, 0.0));
                        gl_Position = finalPos;
                        vHue = hue;
                        vPhase = phase;
                    }
                `,
                fragmentShader: `
                    varying float vHue;
                    varying float vPhase;
                    uniform sampler2D map;
                    uniform vec3 uColorGrade;
                    uniform float uOpacity;
                    
                    void main(){
                        vec4 c = texture2D(map, gl_PointCoord);
                        // Hue-based color variation with grading
                        vec3 baseColor = mix(vec3(1.0, 0.9, 0.8), vec3(0.8, 0.9, 1.0), vHue);
                        vec3 color = c.rgb * baseColor * uColorGrade;
                        float alpha = c.a * uOpacity * (0.7 + 0.3 * sin(vPhase + vHue * 6.283));
                        gl_FragColor = vec4(color, alpha);
                    }
                `
            });

            const mesh = new THREE.Mesh(inst, material);
            mesh.frustumCulled = false;
            return mesh;
        }

        // ---------- Enhanced Scene Class with Temporal Support ----------
        class PorcelainScene {
            constructor(opts = {}) {
                this.id = opts.id || 0;
                this.name = opts.name || 'Untitled';
                this.palette = opts.palette || { bg:0x000000, key:0xffffff, grade: new THREE.Vector3(1,1,1) };
                this.make = opts.make;
                this.group = new THREE.Group();
                this.porcelain = null;
                this.meshCache = [];
                this.instancedParticles = null;
                this.motionEnabled = true;
                this.chapters = opts.chapters || 5;
                this.rail = opts.rail || [];
                this.setup();
            }

            setup(){
                this.group.clear();
                this.mesh
