<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Porcelain Illumination</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html,body,#container{height:100%;width:100%}
    body{
      background:#000;
      color:#fff;
      font-family:"Segoe UI",Inter,system-ui,-apple-system,Roboto,"Helvetica Neue",Arial;
      overflow:hidden;
    }
    #container{position:fixed;inset:0}
    canvas{display:block;touch-action:none}
    .ui{position:absolute;z-index:60;inset:0;pointer-events:none}
    .panel{pointer-events:auto;position:absolute;background:rgba(0,0,0,0.8);padding:12px;border-radius:8px;font-size:13px}
    .top-left{left:16px;top:16px}
    .top-right{right:16px;top:16px;text-align:right}
    .bottom-left{left:16px;bottom:16px}
    .loading{position:fixed;inset:0;background:#000;display:flex;justify-content:center;align-items:center;z-index:1000;font-size:18px;}
  </style>
</head>
<body>
  <div id="container"></div>
  <div class="loading" id="loading">Loading Porcelain...</div>

  <div class="ui">
    <div class="panel top-left">
      <div>PORCELAIN ILLUMINATION</div>
      <div style="font-size:11px;opacity:0.8;margin-top:4px;">Drag: Orbit • Scroll: Zoom • Space: Rotate</div>
    </div>

    <div class="panel top-right">
      <label><input id="toggleBloom" type="checkbox" checked> Bloom</label><br>
      <label><input id="toggleParticles" type="checkbox" checked> Particles</label><br>
      <button id="fsBtn">Fullscreen</button>
    </div>

    <div class="panel bottom-left" style="font-size:11px;opacity:0.8;">
      <div>1-4: Material Presets • R: Reset Camera</div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

  // Core setup
  const container = document.getElementById('container');
  const loading = document.getElementById('loading');
  
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0a1a);
  
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(6, 4, 6);
  
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  // Controls
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.minDistance = 2;
  controls.maxDistance = 20;

  // Professional lighting
  const ambientLight = new THREE.AmbientLight(0x404080, 0.6);
  scene.add(ambientLight);

  const keyLight = new THREE.DirectionalLight(0xffffff, 2.5);
  keyLight.position.set(10, 12, 8);
  keyLight.castShadow = true;
  keyLight.shadow.mapSize.width = 2048;
  keyLight.shadow.mapSize.height = 2048;
  scene.add(keyLight);

  const fillLight = new THREE.DirectionalLight(0x4a6cff, 1.2);
  fillLight.position.set(-8, 6, -6);
  scene.add(fillLight);

  const rimLight = new THREE.DirectionalLight(0xff9d6b, 0.8);
  rimLight.position.set(0, 8, -10);
  scene.add(rimLight);

  // Ground
  const ground = new THREE.Mesh(
    new THREE.CircleGeometry(10, 32),
    new THREE.MeshStandardMaterial({ 
      color: 0x111122,
      roughness: 0.8,
      metalness: 0.1
    })
  );
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Post-processing
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));

  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight), 
    0.8, 0.4, 0.85
  );
  composer.addPass(bloomPass);

  // Load actual porcelain model
  const loader = new GLTFLoader();
  let porcelain = null;
  let autoRotate = true;

  loader.load(
    './porcelain.glb',
    (gltf) => {
      porcelain = gltf.scene;
      
      // Setup porcelain materials
      porcelain.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
          
          if (child.material) {
            // Professional porcelain material
            child.material.roughness = 0.08;
            child.material.metalness = 0.02;
            child.material.envMapIntensity = 1.5;
          }
        }
      });

      // Center and scale
      const box = new THREE.Box3().setFromObject(porcelain);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      
      porcelain.position.sub(center);
      porcelain.position.y += 1.5;
      
      const scale = 4 / Math.max(size.x, size.y, size.z);
      porcelain.scale.setScalar(scale);

      scene.add(porcelain);
      loading.style.display = 'none';
      
      // Set camera target
      controls.target.copy(porcelain.position);
    },
    (progress) => {
      if (progress.lengthComputable) {
        const percent = Math.round((progress.loaded / progress.total) * 100);
        loading.textContent = `Loading: ${percent}%`;
      }
    },
    (error) => {
      console.error('Load error:', error);
      loading.textContent = 'Error loading porcelain.glb';
      loading.style.color = '#ff4444';
    }
  );

  // Simple particles
  const particleGeometry = new THREE.BufferGeometry();
  const particleCount = 800;
  const posArray = new Float32Array(particleCount * 3);
  
  for(let i = 0; i < particleCount * 3; i++) {
    posArray[i] = (Math.random() - 0.5) * 15;
  }
  
  particleGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
  const particleMaterial = new THREE.PointsMaterial({
    size: 0.08,
    color: 0x4488ff,
    transparent: true,
    opacity: 0.6,
    blending: THREE.AdditiveBlending
  });
  const particles = new THREE.Points(particleGeometry, particleMaterial);
  scene.add(particles);

  // Animation
  function animate() {
    requestAnimationFrame(animate);
    
    // Auto-rotation
    if (porcelain && autoRotate) {
      porcelain.rotation.y += 0.008;
    }
    
    // Subtle particle movement
    particles.rotation.y += 0.002;
    
    controls.update();
    composer.render();
  }
  animate();

  // Controls
  document.addEventListener('keydown', (e) => {
    switch(e.code) {
      case 'Space':
        e.preventDefault();
        autoRotate = !autoRotate;
        break;
      case 'KeyR':
        controls.reset();
        break;
      case 'Digit1':
        setMaterialPreset('porcelain');
        break;
      case 'Digit2':
        setMaterialPreset('ceramic');
        break;
      case 'Digit3':
        setMaterialPreset('glossy');
        break;
      case 'Digit4':
        setMaterialPreset('matte');
        break;
    }
  });

  function setMaterialPreset(preset) {
    if (!porcelain) return;
    
    porcelain.traverse((child) => {
      if (child.isMesh && child.material) {
        switch(preset) {
          case 'porcelain':
            child.material.roughness = 0.08;
            child.material.metalness = 0.02;
            break;
          case 'ceramic':
            child.material.roughness = 0.3;
            child.material.metalness = 0.0;
            break;
          case 'glossy':
            child.material.roughness = 0.02;
            child.material.metalness = 0.1;
            break;
          case 'matte':
            child.material.roughness = 0.8;
            child.material.metalness = 0.0;
            break;
        }
      }
    });
  }

  // UI Controls
  document.getElementById('toggleBloom').addEventListener('change', (e) => {
    bloomPass.enabled = e.target.checked;
  });

  document.getElementById('toggleParticles').addEventListener('change', (e) => {
    particles.visible = e.target.checked;
  });

  document.getElementById('fsBtn').addEventListener('click', () => {
    if (!document.fullscreenElement) {
      container.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  });

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  });
  </script>
</body>
</html>
