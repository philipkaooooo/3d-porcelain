<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Porcelain Transcendence — v7-stable (final)</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html,body,#container { height: 100%; width: 100%; }
    body {
      background: #000;
      color: #fff;
      font-family: "Segoe UI", Inter, system-ui, -apple-system, Roboto, "Helvetica Neue", Arial;
      overflow: hidden;
    }
    #container { position: fixed; inset: 0; }
    canvas { display: block; touch-action: none; }
    .ui { position: absolute; z-index: 60; inset: 0; pointer-events: none; }
    .panel { pointer-events: auto; position: absolute; background: rgba(0,0,0,0.45); backdrop-filter: blur(6px); border: 1px solid rgba(255,255,255,0.06); padding: 10px 12px; border-radius: 10px; font-size: 13px; line-height: 1.3; }
    .top-left { left: 16px; top: 16px; }
    .top-right { right: 16px; top: 16px; text-align: right; }
    .bottom-left { left: 16px; bottom: 16px; }
    .scene-indicator { font-weight: 600; opacity: 0.95; }
    .small { font-size: 12px; opacity: 0.85; }
    button { cursor: pointer; }
  </style>
</head>
<body>
  <div id="container" role="application" aria-label="Porcelain Transcendence canvas"></div>

  <div class="ui" aria-hidden="false">
    <div class="panel top-left" role="region" aria-label="Scene information">
      <div id="sceneLabel" class="scene-indicator" role="status" aria-live="polite">Scene 1 / 5 — Dawn Vessel</div>
      <div class="small">← → : Change Scene • SPACE : Toggle Motion • Click : Reactive Pulse</div>
    </div>

    <div class="panel top-right" role="region" aria-label="Effects toggles">
      <label><input id="toggleBloom" type="checkbox" checked> Bloom</label><br>
      <label><input id="toggleDOF" type="checkbox"> DOF</label><br>
      <label><input id="toggleParticles" type="checkbox" checked> Particles</label><br>
      <button id="fsBtn">Fullscreen</button>
    </div>

    <div class="panel bottom-left" role="region" aria-label="Controls">
      <div class="small">DRAG: Orbit • PINCH: Zoom • SCROLL: Stage Chapters</div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
    }
  }
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
  import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
  import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

  // ===== Overview =====
  // This file is a consolidated, corrected v7 baseline:
  // - Instanced particle quads use vUv (not gl_PointCoord)
  // - InstancedBufferGeometry.instanceCount set immediately; throttled via geometry.instanceCount
  // - All uniform writes use .value
  // - Grade/vignette ramp ordering corrected; highlights clamped
  // - Single interactPlane and hoisted raycaster/mouse; computeHit uses ints/ints2
  // - Idle-skip raycasts, cursor scales with camera distance factor
  // - Micro bump map in enhanceMaterial (bumpMap + bumpScale)
  // - SMAA initialized with DPR and updated on resize; composer.setPixelRatio(DPR) on resize
  // - Env intensity clamped per chapter; per-scene particle textures injected
  // - Performance governor throttles instanceCount and lerps bloom strength

  // ---------- constants and DPR ----------
  const container = document.getElementById('container');
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  const WIDTH = () => window.innerWidth;
  const HEIGHT = () => window.innerHeight;

  // ---------- hoisted raycasting state ----------
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2(-10, -10);
  let lastInteraction = performance.now();

  // ---------- scene, camera, renderer ----------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f0712); // lifted infinity background (1 EV more readable)
  scene.fog = new THREE.FogExp2(0x08010a, 0.03);

  const camera = new THREE.PerspectiveCamera(45, WIDTH()/HEIGHT(), 0.05, 2000);
  camera.position.set(7.8, 3.8, 8.8);

  const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
  renderer.setPixelRatio(DPR);
  renderer.setSize(WIDTH(), HEIGHT());
  if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
  else renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 0.95; // keep exposure stable, adjust lights/materials instead
  renderer.physicallyCorrectLights = true;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  // ---------- controls ----------
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.enableZoom = false; // we own zoom via scrollTarget
  controls.minDistance = 1.6;
  controls.maxDistance = 40;
  controls.maxPolarAngle = Math.PI * 0.495;

  // ---------- composer & passes ----------
  const composer = new EffectComposer(renderer);
  composer.setPixelRatio(DPR);
  composer.setSize(WIDTH(), HEIGHT());
  composer.addPass(new RenderPass(scene, camera));

  const bloomPass = new UnrealBloomPass(new THREE.Vector2(WIDTH(), HEIGHT()), 0.55, 0.6, 0.85);
  composer.addPass(bloomPass);

  const bokehPass = new BokehPass(scene, camera, { focus: 20.0, aperture: 0.00085, maxblur: 0.015, width: WIDTH(), height: HEIGHT() });
  bokehPass.enabled = false;
  composer.addPass(bokehPass);

  const smaaPass = new SMAAPass(Math.floor(WIDTH()*DPR), Math.floor(HEIGHT()*DPR));
  composer.addPass(smaaPass);

  // Grade + vignette: corrected smoothstep ordering and clamp
  const gradePass = new ShaderPass(new THREE.ShaderMaterial({
    uniforms: {
      tDiffuse: { value: null },
      uGrade: { value: new THREE.Vector3(1,1,1) },
      uVignette: { value: 0.36 },
      uVignetteSoft: { value: 0.36 }
    },
    vertexShader: `varying vec2 vUv; void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
    fragmentShader: `
      uniform sampler2D tDiffuse;
      uniform vec3 uGrade;
      uniform float uVignette;
      uniform float uVignetteSoft;
      varying vec2 vUv;
      void main(){
        vec4 c = texture2D(tDiffuse, vUv);
        vec3 graded = pow(c.rgb, vec3(0.96)) * uGrade;
        float d = length(vUv - vec2(0.5));
        float vig = smoothstep(uVignette - uVignetteSoft, uVignette, d);
        graded *= mix(1.0, 0.86, vig);
        graded = min(graded, vec3(1.0));
        gl_FragColor = vec4(graded, c.a);
      }
    `
  }), 'tDiffuse');
  composer.addPass(gradePass);

  // ---------- PMREM / HDR lifecycle ----------
  let pmrem = new THREE.PMREMGenerator(renderer);
  pmrem.compileEquirectangularShader();
  let currentEnv = null;
  function setEnvironment(tex){
    if(currentEnv && currentEnv.dispose) try{ currentEnv.dispose(); }catch(e){}
    currentEnv = tex;
    scene.environment = currentEnv;
  }
  (function bakePlaceholder(){
    const urls = new Array(6).fill('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==');
    new THREE.CubeTextureLoader().load(urls, (cube) => {
      const env = pmrem.fromCubemap(cube).texture;
      try{ cube.dispose(); }catch(e){}
      setEnvironment(env);
    });
  })();
  new RGBELoader().setDataType(THREE.UnsignedByteType).load('textures/studio_small_04_1k.hdr', (hdr) => {
    hdr.mapping = THREE.EquirectangularReflectionMapping;
    const env = pmrem.fromEquirectangular(hdr).texture;
    try{ hdr.dispose && hdr.dispose(); }catch(e){}
    setEnvironment(env);
    try{ pmrem.dispose(); }catch(e){}
    pmrem = new THREE.PMREMGenerator(renderer);
  }, undefined, ()=>{});

  // ---------- ground, disc, interactPlane ----------
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(400,400), new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.86 }));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  const disc = new THREE.Mesh(new THREE.CircleGeometry(10, 64), new THREE.MeshStandardMaterial({ color: 0x0e0e10, roughness: 0.48, metalness: 0.03 }));
  disc.rotation.x = -Math.PI/2; disc.position.y = 0.001; disc.receiveShadow = true; scene.add(disc);

  const interactPlane = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshBasicMaterial({ visible:false }));
  interactPlane.rotation.x = -Math.PI/2; interactPlane.position.y = 0; scene.add(interactPlane);

  // ---------- helper textures per scene ----------
  function canvasTex(kind='bokeh', size=256, color='#fff'){
    const c = document.createElement('canvas'); c.width=c.height=size; const ctx = c.getContext('2d');
    ctx.clearRect(0,0,size,size);
    const cx = size/2, cy = size/2;
    if(kind==='bokeh'){ const g = ctx.createRadialGradient(cx,cy,0,cx,cy,size/2); g.addColorStop(0,color); g.addColorStop(0.35,color); g.addColorStop(0.8,'rgba(255,255,255,0.35)'); g.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=g; ctx.fillRect(0,0,size,size); }
    if(kind==='petal'){ ctx.fillStyle=color; ctx.beginPath(); ctx.ellipse(cx,cy,size*0.46,size*0.34,0,0,Math.PI*2); ctx.fill(); }
    if(kind==='pixel'){ ctx.fillStyle=color; const s=size*0.36; ctx.fillRect(cx-s/2,cy-s/2,s,s); }
    if(kind==='grid'){ ctx.fillStyle=color; ctx.fillRect(0,0,size,size); ctx.strokeStyle='rgba(255,255,255,0.03)'; ctx.lineWidth=1; for(let x=0;x<size;x+=12){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,size); ctx.stroke(); } for(let y=0;y<size;y+=12){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(size,y); ctx.stroke(); } }
    const tx = new THREE.CanvasTexture(c); tx.minFilter = THREE.LinearFilter; tx.magFilter = THREE.LinearFilter; tx.needsUpdate = true; return tx;
  }
  const texBokeh = canvasTex('bokeh',256,'#ffffff');
  const texPetal = canvasTex('petal',256,'#ffdfe8');
  const texPixel = canvasTex('pixel',128,'#ffdfe8');
  const texGrid = canvasTex('grid',256,'#120004');

  // ---------- glow/cursor visuals ----------
  function genGlow(size=512,color='#fff3d9'){ const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d'); const g=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2); g.addColorStop(0,color); g.addColorStop(0.25,color); g.addColorStop(0.6,'rgba(255,243,217,0.45)'); g.addColorStop(1,'rgba(255,243,217,0)'); ctx.fillStyle=g; ctx.fillRect(0,0,size,size); const tx=new THREE.CanvasTexture(c); tx.minFilter=THREE.LinearFilter; tx.magFilter=THREE.LinearFilter; tx.needsUpdate=true; return tx; }
  const cursorLight = new THREE.PointLight(0xfff7ea, 0.0, 28, 2.2); cursorLight.castShadow = false; scene.add(cursorLight);
  const cursorBall = new THREE.Mesh(new THREE.SphereGeometry(0.06, 12, 12), new THREE.MeshBasicMaterial({ color: 0xfff3d9 })); cursorBall.frustumCulled = false; scene.add(cursorBall);
  const glowSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: genGlow(512,'#fff3d9'), blending: THREE.AdditiveBlending, transparent:true, opacity:0.65, depthWrite:false })); glowSprite.scale.setScalar(0.8); scene.add(glowSprite);

  // ---------- pulse pooling ----------
  const pulsePool = [], activePulses = [];
  function createPulse(count=80){ const geom=new THREE.BufferGeometry(); const pos=new Float32Array(count*3); const vel=new Float32Array(count*3); geom.setAttribute('position', new THREE.BufferAttribute(pos,3)); geom.setAttribute('vel', new THREE.BufferAttribute(vel,3)); const mat=new THREE.PointsMaterial({ size:0.05, color:0xfff0d8, transparent:true, opacity:1, depthWrite:false }); const pts=new THREE.Points(geom,mat); pts.userData={life:0,count}; return pts; }
  function getPulse(count=80){ if(pulsePool.length) return pulsePool.pop(); return createPulse(count); }
  function recyclePulse(p){ p.visible=false; p.userData.life=0; pulsePool.push(p); }
  function spawnPulse(pos,color=0xfff0d8,count=80){ const pts=getPulse(count); const posAttr=pts.geometry.attributes.position, velAttr=pts.geometry.attributes.vel; for(let i=0;i<pts.userData.count;i++){ const phi=Math.acos(2*Math.random()-1), theta=Math.random()*Math.PI*2, r=0.02+Math.random()*0.08; posAttr.array[i*3]=pos.x + r*Math.sin(phi)*Math.cos(theta); posAttr.array[i*3+1]=pos.y + r*Math.cos(phi); posAttr.array[i*3+2]=pos.z + r*Math.sin(phi)*Math.sin(theta); velAttr.array[i*3]=(Math.random()-0.5)*0.9; velAttr.array[i*3+1]=Math.random()*1.2+0.2; velAttr.array[i*3+2]=(Math.random()-0.5)*0.9; } posAttr.needsUpdate=true; velAttr.needsUpdate=true; pts.material.color.setHex(color); pts.userData.life=1; pts.visible=true; if(!pts.parent) scene.add(pts); activePulses.push(pts); }

  // ---------- micro bump map ----------
  function microBump(){
    const c=document.createElement('canvas'); c.width=c.height=512; const ctx=c.getContext('2d');
    for(let i=0;i<6000;i++){ const x=Math.random()*512, y=Math.random()*512, s=Math.random()*1.2; ctx.fillStyle=`rgba(200,200,200,${0.02+Math.random()*0.02})`; ctx.fillRect(x,y,s,s); }
    const tx = new THREE.CanvasTexture(c); tx.wrapS=tx.wrapT=THREE.RepeatWrapping; tx.repeat.set(4,4); tx.needsUpdate=true; return tx;
  }
  const microBumpMap = microBump();

  function enhanceMaterial(mat){
    if(!mat) return;
    mat.bumpMap = microBumpMap; // bump map, not normal map
    mat.bumpScale = 0.02;
    mat.clearcoat = Math.max(0.8, mat.clearcoat || 1.0);
    mat.clearcoatRoughness = 0.06;
    mat.needsUpdate = true;
  }

  // ---------- instanced rig factory (vUv) ----------
  function createInstancedRig(maxInstances=1200, texture=texBokeh){
    const base = new THREE.PlaneGeometry(1,1);
    const inst = new THREE.InstancedBufferGeometry();
    inst.index = base.index;
    inst.attributes.position = base.attributes.position;
    inst.attributes.uv = base.attributes.uv;

    const offsets = new Float32Array(maxInstances*3);
    const sizes = new Float32Array(maxInstances);
    const hues = new Float32Array(maxInstances);
    const phases = new Float32Array(maxInstances);
    const drag = new Float32Array(maxInstances);
    for(let i=0;i<maxInstances;i++){
      offsets[i*3] = (Math.random()-0.5)*20;
      offsets[i*3+1] = Math.random()*10;
      offsets[i*3+2] = (Math.random()-0.5)*20;
      sizes[i] = Math.random()*0.8 + 0.08;
      hues[i] = Math.random();
      phases[i] = Math.random()*Math.PI*2;
      drag[i] = Math.random()*0.12 + 0.02;
    }
    inst.setAttribute('offset', new THREE.InstancedBufferAttribute(offsets,3));
    inst.setAttribute('sizeAttr', new THREE.InstancedBufferAttribute(sizes,1));
    inst.setAttribute('hue', new THREE.InstancedBufferAttribute(hues,1));
    inst.setAttribute('phase', new THREE.InstancedBufferAttribute(phases,1));
    inst.setAttribute('drag', new THREE.InstancedBufferAttribute(drag,1));

    // IMPORTANT: set draw count on geometry (not mesh)
    inst.instanceCount = maxInstances;

    const mat = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uFlow: { value: 0.0 },
        uStage: { value: 0 },
        uColorGrade: { value: new THREE.Vector3(1,1,1) },
        uOpacity: { value: 0.6 },
        map: { value: texture }
      },
      vertexShader: `
        attribute vec3 offset;
        attribute float sizeAttr;
        attribute float phase;
        attribute float drag;
        attribute vec2 uv;
        varying vec2 vUv;
        varying float vPhase;
        uniform float uTime;
        uniform float uFlow;
        uniform float uStage;
        void main(){
          vUv = uv;
          vPhase = phase;
          float t = uTime * (0.2 + drag);
          vec3 p = offset;
          if(uFlow < 0.5){
            p.y += t * 0.12 * (1.0 + uStage*0.3);
            p.x += sin(t + phase) * 0.25 * (0.5 + uStage*0.8);
            p.z += cos(t*0.9 + phase) * 0.2;
          } else if(uFlow < 1.5){
            float line = sin(offset.x*0.12 + offset.z*0.08 + phase);
            p.x += mix(0.0, sign(line)*0.7, uStage) * 0.6;
            p.y += t*0.06;
          } else if(uFlow < 2.5){
            p.x += sin(t*1.2 + phase) * (0.6 + uStage*0.9);
            p.y += t * 0.1;
          } else if(uFlow < 3.5){
            float theta = uTime*1.2 + phase*2.0;
            p.x += cos(theta) * (uStage*0.6);
            p.z += sin(theta) * (uStage*0.6);
            p.y += t*0.18;
          } else {
            p.x += sin(phase*3.0) * (0.2 + uStage*0.9);
            p.y += t * 0.08;
            p.z += cos(phase*3.0) * (0.2 + uStage*0.9);
          }
          float finalSize = sizeAttr * (1.4) * (1.0 + uStage*0.25);
          vec4 mv = modelViewMatrix * vec4(p, 1.0);
          vec3 right = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
          vec3 up = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);
          vec3 pos = mv.xyz + (right * position.x + up * position.y) * finalSize;
          gl_Position = projectionMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        varying float vPhase;
        uniform sampler2D map;
        uniform vec3 uColorGrade;
        uniform float uOpacity;
        void main(){
          vec4 c = texture2D(map, vUv);
          vec3 col = c.rgb * uColorGrade;
          gl_FragColor = vec4(col, c.a * uOpacity);
          if (gl_FragColor.a < 0.01) discard;
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const mesh = new THREE.Mesh(inst, mat);
    mesh.frustumCulled = false;
    return mesh;
  }

  // ---------- SceneNode / Scenes creation ----------
  function railPoints(base,target){ const r=[]; for(let i=0;i<4;i++){ const j=(i-1.5)*0.5; r.push({ position: base.clone().add(new THREE.Vector3(j,i*0.08,-j)), target: target.clone().add(new THREE.Vector3(0,i*0.04,0)) }); } return r; }
  const defs = [
    { id:0, name:'Dawn Vessel', palette:{ bg:0x19070a, key:0xffe6c8, grade:new THREE.Vector3(1.06,0.95,0.9) }, make:makeVesselA, rail:railPoints(new THREE.Vector3(6,3.5,6), new THREE.Vector3(0,1.1,0)), texture:texBokeh },
    { id:1, name:'Calm Mirror', palette:{ bg:0x081224, key:0xbfe8ff, grade:new THREE.Vector3(0.95,1.02,1.05) }, make:makePlateB, rail:railPoints(new THREE.Vector3(5.5,2.8,5.8), new THREE.Vector3(0,0.85,0)), texture:texBokeh },
    { id:2, name:'Whim', palette:{ bg:0x12040a, key:0xffefe9, grade:new THREE.Vector3(1.06,0.96,1.05) }, make:makeMiniSculptC, rail:railPoints(new THREE.Vector3(7,3.4,7), new THREE.Vector3(0,0.8,0)), texture:texPixel },
    { id:3, name:'Echo Column', palette:{ bg:0x071011, key:0xfffff6, grade:new THREE.Vector3(1.0,0.98,1.05) }, make:makeTallCylinderD, rail:railPoints(new THREE.Vector3(6.2,3.8,6.2), new THREE.Vector3(0,1.4,0)), texture:texGrid },
    { id:4, name:'Night Bloom', palette:{ bg:0x05051a, key:0xe6f0ff, grade:new THREE.Vector3(0.92,0.98,1.08) }, make:makeBowlE, rail:railPoints(new THREE.Vector3(7.5,3.6,7.8), new THREE.Vector3(0,0.9,0)), texture:texPetal }
  ];
  const scenes = defs.map(d => { const n = new SceneNode({ id:d.id, name:d.name, palette:d.palette, make:d.make, rail:d.rail, chapters:4, texture:d.texture }); n.id=d.id; return n; });

  // add initial scene
  let currentIndex = 0, currentChapter = 0;
  scene.add(scenes[0].group);
  scenes[0].enter(0);
  document.getElementById('sceneLabel').textContent = `Scene 1 / 5 — ${scenes[0].name}`;

  // ---------- applySceneState helper (centralized state machine) ----------
  function applySceneState(sceneIndex, chapterIndex){
    currentIndex = sceneIndex;
    currentChapter = chapterIndex;
    const node = scenes[sceneIndex];
    // set grade and vignette (uniform .value)
    gradePass.material.uniforms.uGrade.value.copy(node.palette.grade || new THREE.Vector3(1,1,1));
    gradePass.material.uniforms.uVignette.value = 0.34;
    // particles: set uniforms via .value
    if(node.particleRig && node.particleRig.material && node.particleRig.material.uniforms){
      node.particleRig.material.uniforms.uStage.value = chapterIndex;
      node.particleRig.material.uniforms.uFlow.value = node.id;
      node.particleRig.material.uniforms.uOpacity.value = 0.35 + 0.45 * (chapterIndex / Math.max(1, node.chapters - 1));
    }
    // camera rail snap
    const rail = node.rail[chapterIndex] || node.rail[0];
    if(rail){
      gsap.to(camera.position, { x: rail.position.x, y: rail.position.y, z: rail.position.z, duration: 0.95, ease:'expo.inOut', onUpdate: ()=>controls.update() });
      gsap.to(controls.target, { x: rail.target.x, y: rail.target.y, z: rail.target.z, duration: 0.95, ease:'expo.inOut', onUpdate: ()=>controls.update() });
    }
    // clamp env intensity per chapter
    node.meshCache.forEach(m => { m.material.envMapIntensity = Math.min(1.8, 1.0 + chapterIndex * 0.28); });
    // ground motif blend
    gsap.to(disc.material.color, { r: ((node.palette.bg>>16)&0xff)/255*0.12 + 0.02, g: ((node.palette.bg>>8)&0xff)/255*0.12 + 0.02, b: (node.palette.bg&0xff)/255*0.12 + 0.02, duration: 0.9 });
    if(chapterIndex >= node.chapters - 1) prefetchNext(sceneIndex);
    document.getElementById('sceneLabel').textContent = `Scene ${sceneIndex+1} / 5 — ${node.name}`;
  }
  function prefetchNext(i){ const next=(i+1)%scenes.length; console.log('prefetch hook for', next); /* lazy-load assets here */ }

  // ---------- input wiring (scoped) ----------
  function isOverUI(e){ const el = document.elementFromPoint(e.clientX, e.clientY); return el && el.closest && el.closest('.panel'); }
  renderer.domElement.addEventListener('mousemove', (e)=>{ if(isOverUI(e)) return; const r = renderer.domElement.getBoundingClientRect(); mouse.x = ((e.clientX - r.left)/r.width)*2 - 1; mouse.y = -((e.clientY - r.top)/r.height)*2 + 1; lastInteraction = performance.now(); }, { passive:true });

  let scrollAccum = 0;
  renderer.domElement.addEventListener('wheel', (e)=>{ if(isOverUI(e)) return; e.preventDefault(); scrollAccum += e.deltaY; const step = scrollAccum > 160 ? 1 : (scrollAccum < -160 ? -1 : 0); if(step !== 0){ scrollAccum = 0; currentChapter = THREE.MathUtils.clamp(currentChapter + step, 0, scenes[currentIndex].chapters - 1); applySceneState(currentIndex, currentChapter); } const delta = e.deltaY * 0.003; scrollTarget += delta*6; scrollTarget = THREE.MathUtils.clamp(scrollTarget, controls.minDistance, controls.maxDistance); }, { passive:false });

  renderer.domElement.addEventListener('pointerdown', (e)=>{ if(isOverUI(e)) return; lastInteraction = performance.now(); const hit = computeHit(); if(hit && hit.object && scenes[currentIndex].meshCache.includes(hit.object)) spawnPulse(hit.point, 0xfff0d8, 100); }, { passive:true });

  window.addEventListener('keydown', (e)=>{ const active = document.activeElement; const typing = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable); if(!typing){ if(e.code === 'ArrowRight'){ e.preventDefault(); gotoScene((currentIndex+1)%scenes.length); } if(e.code === 'ArrowLeft'){ e.preventDefault(); gotoScene((currentIndex-1+scenes.length)%scenes.length); } if(e.code === 'Space'){ e.preventDefault(); toggleGlobalMotion(); } } }, { passive:false });

  document.getElementById('toggleBloom').addEventListener('change', (e) => { bloomPass.enabled = e.target.checked; });
  document.getElementById('toggleDOF').addEventListener('change', (e) => { bokehPass.enabled = e.target.checked; });
  document.getElementById('toggleParticles').addEventListener('change', (e) => { scenes.forEach(s => { if(s.particleRig) s.particleRig.visible = e.target.checked; }); });

  document.getElementById('fsBtn').addEventListener('click', async ()=>{ if(!document.fullscreenElement){ await container.requestFullscreen().catch(()=>{}); resize(); } else { await document.exitFullscreen().catch(()=>{}); resize(); } });

  // ---------- computeHit (ints and ints2) ----------
  function computeHit(){
    if(performance.now() - lastInteraction > 900) return null;
    raycaster.setFromCamera(mouse, camera);
    const node = scenes[currentIndex];
    if(node && node.meshCache.length){
      const ints = raycaster.intersectObjects(node.meshCache, true);
      if(ints && ints.length) return ints[0];
    }
    const ints2 = raycaster.intersectObject(interactPlane);
    if(ints2 && ints2.length) return ints2[0];
    return null;
  }

  // ---------- scene switching (safe crossfade) ----------
  function prepareFade(group){ group.traverse(m=>{ if(m.isMesh && m.material && !m.material.__pf){ m.material.__pf=true; m.material.__origTransparent=m.material.transparent; m.material.__origOpacity = m.material.opacity !== undefined ? m.material.opacity : 1.0; m.material.transparent = true; } }); }
  function fadeGroup(group,to,d=0.9){ group.traverse(m=>{ if(m.isMesh && m.material && m.material.__pf) gsap.to(m.material, { opacity: to, duration: d, ease:'power2.inOut' }); }); }
  function restoreFade(group){ group.traverse(m=>{ if(m.isMesh && m.material && m.material.__pf){ gsap.to(m.material, { opacity: m.material.__origOpacity || 1.0, duration: 0.02, onComplete: ()=>{ m.material.transparent = m.material.__origTransparent; delete m.material.__origTransparent; delete m.material.__origOpacity; delete m.material.__pf; } }); } }); }

  let transitioning = false;
  function gotoScene(i){
    if(transitioning || i===currentIndex) return;
    transitioning = true;
    const from = scenes[currentIndex], to = scenes[i];
    if(!to.group.parent) scene.add(to.group);
    prepareFade(from.group); prepareFade(to.group);
    to.group.traverse(m=>{ if(m.isMesh && m.material) m.material.opacity = 0.0; });
    controls.enabled = false;
    gsap.to(disc.material, { opacity: 0.6, duration: 0.6 });
    const tl = gsap.timeline({ onComplete: ()=>{ scene.remove(from.group); restoreFade(from.group); restoreFade(to.group); currentIndex = i; document.getElementById('sceneLabel').textContent = `Scene ${i+1} / 5 — ${to.name}`; transitioning=false; controls.enabled=true; gsap.to(disc.material,{opacity:1.0,duration:0.6}); }});
    const rail = to.rail[0] || { position: camera.position.clone(), target: controls.target.clone() };
    tl.to(camera.position, { x: rail.position.x, y: rail.position.y, z: rail.position.z, duration: 1.05, ease:'expo.inOut', onUpdate: ()=>controls.update() }, 0);
    tl.to(controls.target, { x: rail.target.x, y: rail.target.y, z: rail.target.z, duration: 1.05, ease:'expo.inOut', onUpdate: ()=>controls.update() }, 0);
    tl.add(()=>from.exit(), 0.02); tl.add(()=>to.enter(0), 0.02); tl.add(()=>fadeGroup(from.group,0.0,0.9),0.04); tl.add(()=>fadeGroup(to.group,1.0,1.0),0.06);
  }

  // ---------- performance governor (throttle geometry.instanceCount) ----------
  const perf = { samples: [], lastAdjust: performance.now() };
  function perfTick(dt){
    perf.samples.push(dt);
    if(perf.samples.length>60) perf.samples.shift();
    const avg = perf.samples.reduce((a,b)=>a+b,0) / perf.samples.length;
    const fps = 1/avg;
    const now = performance.now();
    if(now - perf.lastAdjust > 1000){
      perf.lastAdjust = now;
      if(fps < 45){
        bloomPass.strength = Math.max(0.25, bloomPass.strength * 0.88);
        bokehPass.enabled = false;
        scenes.forEach(s => { if(s.particleRig && s.particleRig.geometry) s.particleRig.geometry.instanceCount = Math.floor(1200 * 0.6); });
      } else {
        bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, 0.55, 0.06);
        scenes.forEach(s => { if(s.particleRig && s.particleRig.geometry) s.particleRig.geometry.instanceCount = 1200; });
        bokehPass.enabled = document.getElementById('toggleDOF').checked;
      }
    }
  }

  // ---------- resize (DPR-aware SMAA and composer pixel ratio) ----------
  function resize(){
    const w = WIDTH(), h = HEIGHT();
    camera.aspect = w/h; camera.updateProjectionMatrix();
    renderer.setSize(w,h);
    composer.setSize(w,h);
    composer.setPixelRatio(DPR);
    try{
      if(bokehPass && bokehPass.materialBokeh && bokehPass.materialBokeh.uniforms && ('aspect' in bokehPass.materialBokeh.uniforms)) bokehPass.materialBokeh.uniforms.aspect.value = camera.aspect;
      else if(bokehPass && bokehPass.uniforms){ bokehPass.uniforms['width'].value = w; bokehPass.uniforms['height'].value = h; }
      if(smaaPass) smaaPass.setSize(Math.floor(w*DPR), Math.floor(h*DPR));
    }catch(e){ console.warn('resize pass update failed', e); }
  }
  window.addEventListener('resize', resize);

  // ---------- animation loop ----------
  const clock = new THREE.Clock();
  let scrollTarget = camera.position.distanceTo(controls.target);

  function animate(){
    const dt = Math.min(0.05, clock.getDelta());
    const elapsed = clock.getElapsedTime();
    perfTick(dt);

    // smooth zoom
    const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
    const desiredDistance = THREE.MathUtils.lerp(camera.position.distanceTo(controls.target), scrollTarget, 0.06);
    const clampedDistance = THREE.MathUtils.clamp(desiredDistance, controls.minDistance, controls.maxDistance);
    const newCamPos = new THREE.Vector3().copy(camDir).multiplyScalar(-clampedDistance).add(controls.target);
    camera.position.lerp(newCamPos, 0.08);

    // hit test (idle skip)
    let hit = null;
    if(performance.now() - lastInteraction <= 900){
      raycaster.setFromCamera(mouse, camera);
      const node = scenes[currentIndex];
      if(node && node.meshCache.length){
        const ints = raycaster.intersectObjects(node.meshCache, true);
        if(ints && ints.length) hit = ints[0];
      }
      if(!hit){
        const ints2 = raycaster.intersectObject(interactPlane);
        if(ints2 && ints2.length) hit = ints2[0];
      }
    }

    // cursor light scaling & clamp
    if(hit && hit.object && scenes[currentIndex].meshCache.includes(hit.object)){
      const N = hit.face.normal.clone().transformDirection(hit.object.matrixWorld);
      const V = camera.position.clone().sub(hit.point).normalize();
      const d = hit.distance;
      const align = Math.max(0, N.dot(V));
      const Iraw = (1 - Math.min(10, d)/10) * align;
      const I = THREE.MathUtils.clamp(Iraw, 0.04, 1.0);
      const camFactor = THREE.MathUtils.clamp(8.0 / Math.max(0.001, d), 0.0, 1.0);
      const intended = I * camFactor;
      cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, intended, 0.12);
      cursorLight.position.lerp(hit.point, 0.18);
      cursorBall.position.lerp(hit.point, 0.18);
      const targetScale = 0.3 + I * 1.6 * camFactor;
      glow.scale.setScalar(THREE.MathUtils.lerp(glow.scale.x, targetScale, 0.12));
      glow.position.lerp(hit.point.clone().add(new THREE.Vector3().subVectors(camera.position, hit.point).setLength(0.06)), 0.18);
      glow.material.opacity = THREE.MathUtils.lerp(glow.material.opacity, 0.65 * I, 0.12);
    } else {
      cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, 0.0, 0.06);
      glow.material.opacity = THREE.MathUtils.lerp(glow.material.opacity, 0.0, 0.05);
    }

    // pulses update
    for(let i=activePulses.length-1;i>=0;i--){
      const p = activePulses[i];
      p.userData.life -= dt * 0.8;
      const posAttr = p.geometry.attributes.position, velAttr = p.geometry.attributes.vel;
      for(let v=0; v<posAttr.count; v++){ posAttr.array[v*3]+=velAttr.array[v*3]*dt; posAttr.array[v*3+1]+=velAttr.array[v*3+1]*dt; posAttr.array[v*3+2]+=velAttr.array[v*3+2]*dt; velAttr.array[v*3+1]-=dt*0.9; }
      posAttr.needsUpdate=true; velAttr.needsUpdate=true;
      p.material.opacity = Math.max(0, p.userData.life);
      if(p.userData.life <= 0){ const idx = activePulses.indexOf(p); if(idx!==-1) activePulses.splice(idx,1); if(p.parent) p.parent.remove(p); recyclePulse(p); }
    }

    // update active scene
    scenes[currentIndex].update(dt, elapsed, hit ? hit.point.clone() : null, 0);

    controls.update();
    composer.render();
    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  // ---------- utilities ----------
  function toggleGlobalMotion(){ scenes.forEach(s => s.toggleMotion(!s.motionEnabled)); }
  window.__porcelain = { scenes, gotoScene, applySceneState, resize };

  // ensure initial resize
  resize();

  </script>
</body>
</html>
