<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Porcelain Transcendence — Five Scenes</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body,#container{height:100%;width:100%}
    body{background:#000;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#fff;overflow:hidden}
    #container{position:fixed;inset:0}
    canvas{display:block; touch-action:none;} /* pinch/touch handled manually */
    .ui {
      position: absolute; z-index: 60; pointer-events: none; inset: 0;
    }
    .panel {
      pointer-events: auto;
      position: absolute;
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,0.05);
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
    }
    .top-left{left:16px;top:16px}
    .bottom-left{left:16px;bottom:16px}
    .top-right{right:16px;top:16px;text-align:right}
    .scene-indicator{font-weight:600;opacity:0.95}
    .controls small{opacity:0.8;display:block;margin-top:6px}
    .hint{opacity:0.75;font-size:12px;margin-top:6px}
  </style>
</head>
<body>
  <div id="container" role="application" aria-label="Porcelain Transcendence canvas"></div>

  <div class="ui" aria-hidden="false">
    <div class="panel top-left" role="region" aria-label="Scene information">
      <div id="sceneLabel" class="scene-indicator" role="status" aria-live="polite">Scene 1 / 5 — Dawn Vessel</div>
      <div class="hint">← → : Change Scene • SPACE : toggle motion • Click : reactive pulses</div>
    </div>

    <div class="panel top-right" id="toggles" style="text-align:right" role="region" aria-label="Effects toggles">
      <label><input id="toggleBloom" type="checkbox" checked> Bloom</label><br>
      <label><input id="toggleDOF" type="checkbox" checked> DOF</label><br>
      <label><input id="toggleParticles" type="checkbox" checked> Particles</label>
    </div>

    <div class="panel bottom-left controls" role="region" aria-label="Controls">
      <div>DRAG: Orbit • SCROLL: Smooth Zoom</div>
      <small>Move your mouse to let the cursor light "scan" the porcelain</small>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
    }
  }
  </script>

  <!-- GSAP (used for transitions) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';

  // --------------------------
  // Globals & sizing normalization
  // --------------------------
  const canvasContainer = document.getElementById('container');
  const WIDTH = () => window.innerWidth;
  const HEIGHT = () => window.innerHeight;
  // clamp DPR ONCE
  const DPR = Math.min(window.devicePixelRatio || 1, 2);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  // STEP 4 — exponential fog
  scene.fog = new THREE.FogExp2(0x000010, 0.035);

  const camera = new THREE.PerspectiveCamera(45, WIDTH()/HEIGHT(), 0.05, 2000);
  camera.position.set(8, 4.5, 9);

  const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
  renderer.setPixelRatio(DPR);
  renderer.setSize(WIDTH(), HEIGHT());
  // output color space
  if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
  else renderer.outputEncoding = THREE.sRGBEncoding;
  // STEP 4 — tone mapping exposure target
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 0.9;
  renderer.physicallyCorrectLights = true;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  // attach canvas
  canvasContainer.appendChild(renderer.domElement);

  // controls: disable zoom—we own zoom via smooth lerp
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.minDistance = 1.6;
  controls.maxDistance = 40;
  controls.enableZoom = false; // disable OrbitControls zoom
  controls.maxPolarAngle = Math.PI * 0.495;

  // composer & passes
  const composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);

  // STEP 1 — bloom tuned
  const bloomPass = new UnrealBloomPass(new THREE.Vector2(WIDTH(), HEIGHT()), 0.55, 0.6, 0.85);
  composer.addPass(bloomPass);

  // bokeh (DOF) pass
  const bokehPass = new BokehPass(scene, camera, {
    focus: 20.0,
    aperture: 0.0009,
    maxblur: 0.01,
    width: WIDTH(),
    height: HEIGHT()
  });
  composer.addPass(bokehPass);

  // FilmPass intentionally not added to composer by default (disabled until toggled)
  let filmPass = null;

  // PMREM lifecycle
  let pmrem = new THREE.PMREMGenerator(renderer);
  pmrem.compileEquirectangularShader();
  let currentEnv = null; // tracks current environment texture for proper disposal

  // placeholder cubemap -> bake into PMREM temp and dispose source
  (function initPlaceholderEnv() {
    const cubeUrls = [
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=='
    ];
    const tempCube = new THREE.CubeTextureLoader().load(cubeUrls, () => {
      const envRT = pmrem.fromCubemap(tempCube).texture;
      // dispose temp cube
      try { tempCube.dispose(); } catch (e) {}
      assignEnvironment(envRT);
    });
  })();

  // STEP 4 — HDRI loader (replace environment when available)
  const rgbeLoader = new RGBELoader();
  rgbeLoader.setDataType(THREE.UnsignedByteType);
  rgbeLoader.load('textures/studio_small_04_1k.hdr', (hdrTex) => {
    hdrTex.mapping = THREE.EquirectangularReflectionMapping;
    // bake to PMREM
    const envRT = pmrem.fromEquirectangular(hdrTex).texture;
    // dispose hdrTex (source)
    try { hdrTex.dispose && hdrTex.dispose(); } catch(e) {}
    assignEnvironment(envRT);
    // regenerate a fresh pmrem for further replacements
    try { pmrem.dispose(); } catch (e) {}
    pmrem = new THREE.PMREMGenerator(renderer);
  }, undefined, (err) => {
    console.warn('HDR load failed (optional):', err);
  });

  function assignEnvironment(envTexture) {
    // dispose prior env safely
    if (currentEnv && currentEnv.dispose) {
      try { currentEnv.dispose(); } catch (e) {}
    }
    currentEnv = envTexture;
    scene.environment = currentEnv;
    // update existing materials' envMap references (done later when scenes build)
  }

  // --------------------------
  // Shared ground/disc
  // --------------------------
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(400, 400),
    new THREE.MeshStandardMaterial({ color: 0x040405, roughness: 0.85 })
  );
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  const disc = new THREE.Mesh(new THREE.CircleGeometry(10, 64), new THREE.MeshStandardMaterial({ color:0x0e0e10, roughness:0.5, metalness:0.04, transparent:true, opacity:1 }));
  disc.rotation.x = -Math.PI/2;
  disc.position.y = 0.001;
  disc.receiveShadow = true;
  scene.add(disc);

  // interaction plane
  const interactPlane = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000), new THREE.MeshBasicMaterial({ visible:false }));
  interactPlane.rotation.x = -Math.PI/2;
  interactPlane.position.y = 0;
  scene.add(interactPlane);

  // --------------------------
  // Cursor glow generation (STEP 2)
  // --------------------------
  function generateGlowTexture(size = 512, color = '#fff3d9') {
    const c = document.createElement('canvas');
    c.width = c.height = size;
    const ctx = c.getContext('2d');
    const cx = size/2, cy = size/2;
    const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, size/2);
    g.addColorStop(0.0, color);
    g.addColorStop(0.25, color);
    g.addColorStop(0.6, 'rgba(255,243,217,0.45)');
    g.addColorStop(1.0, 'rgba(255,243,217,0.0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,size,size);
    const tx = new THREE.CanvasTexture(c);
    tx.needsUpdate = true;
    tx.minFilter = THREE.LinearFilter;
    tx.magFilter = THREE.LinearFilter;
    return tx;
  }

  // cursor lights & visuals
  const cursorLight = new THREE.PointLight(0xfff7ea, 0.0, 28, 2.2);
  cursorLight.castShadow = false; // STEP 5 disable cursor shadows
  scene.add(cursorLight);

  const cursorBall = new THREE.Mesh(new THREE.SphereGeometry(0.06, 12, 12), new THREE.MeshBasicMaterial({ color: 0xfff3d9 }));
  cursorBall.frustumCulled = false;
  scene.add(cursorBall);

  const glowTexture = generateGlowTexture(512, '#fff3d9');
  const glowMaterial = new THREE.SpriteMaterial({ map: glowTexture, color:0xffffff, blending:THREE.AdditiveBlending, transparent:true, opacity:0.65, depthWrite:false });
  const glow = new THREE.Sprite(glowMaterial);
  glow.scale.setScalar(0.8);
  scene.add(glow);

  // --------------------------
  // Pulse pooling (reuse geometries/materials)
  // --------------------------
  const pulsePool = [];
  const activePulses = [];
  function createPulseMesh(count = 60) {
    const geom = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const vel = new Float32Array(count * 3);
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geom.setAttribute('vel', new THREE.BufferAttribute(vel, 3));
    const mat = new THREE.PointsMaterial({ color:0xffe6d1, size:0.05, transparent:true, opacity:1, depthWrite:false });
    const pts = new THREE.Points(geom, mat);
    pts.userData = { life: 0, count };
    return pts;
  }
  function getPulse(count=60) {
    if (pulsePool.length) return pulsePool.pop();
    return createPulseMesh(count);
  }
  function recyclePulse(pts) {
    pts.visible = false;
    pts.userData.life = 0;
    // reset attributes if needed
    pulsePool.push(pts);
  }
  function spawnPulse(position, color = 0xffe6d1, count = 60) {
    const pts = getPulse(count);
    const posAttr = pts.geometry.attributes.position;
    const velAttr = pts.geometry.attributes.vel;
    for (let i=0;i<count;i++){
      const phi = Math.acos(2*Math.random()-1);
      const theta = Math.random()*Math.PI*2;
      const r = 0.02 + Math.random()*0.08;
      posAttr.array[i*3] = position.x + r*Math.sin(phi)*Math.cos(theta);
      posAttr.array[i*3+1] = position.y + r*Math.cos(phi);
      posAttr.array[i*3+2] = position.z + r*Math.sin(phi)*Math.sin(theta);
      velAttr.array[i*3] = (Math.random()-0.5)*0.9;
      velAttr.array[i*3+1] = Math.random()*1.2 + 0.2;
      velAttr.array[i*3+2] = (Math.random()-0.5)*0.9;
    }
    posAttr.needsUpdate = true;
    velAttr.needsUpdate = true;
    pts.material.color.setHex(color);
    pts.userData.life = 1.0;
    pts.visible = true;
    if (!pts.parent) scene.add(pts);
    activePulses.push(pts);
  }

  // --------------------------
  // Scene class with cached meshes for raycasting and tighter shadow frustum
  // --------------------------
  class PorcelainScene {
    constructor(opts = {}) {
      this.name = opts.name || 'Untitled';
      this.palette = opts.palette || { bg:0x000000, key:0xffffff };
      this.group = new THREE.Group();
      this.porcelain = null;
      this.porcelainMeshes = []; // cached meshes for raycasting
      this.id = opts.id || 0;
      this.lights = [];
      this.particles = null;
      this.motionEnabled = true;
      this.make = opts.make;
      this.setup();
    }

    setup(){
      this.group.clear();
      this.porcelainMeshes.length = 0;

      this.hemi = new THREE.HemisphereLight(0xddddff, 0x0a0a0d, 0.45);
      this.group.add(this.hemi);

      this.key = new THREE.DirectionalLight(this.palette.key, 1.8);
      this.key.castShadow = true;
      // STEP 5 — right-size mapSize for balance
      this.key.shadow.mapSize.set(1024,1024);
      this.key.shadow.camera.near = 0.5;
      this.key.shadow.camera.far = 200;
      this.key.position.set(6,10,6);
      this.group.add(this.key);

      this.fill = new THREE.DirectionalLight(0x8fb3ff, 0.45);
      this.fill.castShadow = false;
      this.fill.position.set(-6,5,-6);
      this.group.add(this.fill);

      this.rim = new THREE.DirectionalLight(0xffe6d0, 0.6);
      this.rim.castShadow = false;
      this.rim.position.set(0,6,-8);
      this.group.add(this.rim);

      // porcelain
      const p = this.make();
      this.porcelain = p;
      // ensure physical materials & cache meshes
      p.traverse((c) => {
        if (c.isMesh) {
          c.castShadow = true;
          c.receiveShadow = true;
          this.porcelainMeshes.push(c);
          if (!(c.material && c.material.isMeshPhysicalMaterial)) {
            const base = (c.material && c.material.color) ? c.material.color.clone() : new THREE.Color(0xffffff);
            const newMat = new THREE.MeshPhysicalMaterial({
              color: base,
              roughness: 0.06,
              metalness: 0.0,
              clearcoat: 1.0,
              clearcoatRoughness: 0.04,
              envMap: scene.environment,
              envMapIntensity: 1.2,
              side: THREE.FrontSide
            });
            if (c.material && c.material.map) newMat.map = c.material.map;
            c.material = newMat;
            c.material.userData = { baseRoughness: newMat.roughness, baseEnv: newMat.envMapIntensity, baseClearcoat: newMat.clearcoat };
          }
        }
      });
      this.group.add(p);

      // particles: STEP 3 changes
      const halo = new THREE.BufferGeometry();
      const N = 600;
      const pos = new Float32Array(N*3);
      const col = new Float32Array(N*3);
      for (let i=0;i<N;i++){
        const i3 = i*3;
        const r = 12 + Math.random()*8; // per spec
        const theta = Math.random()*Math.PI*2;
        const phi = Math.acos(2*Math.random()-1);
        pos[i3] = r*Math.sin(phi)*Math.cos(theta);
        pos[i3+1] = r*Math.cos(phi)*0.45;
        pos[i3+2] = r*Math.sin(phi)*Math.sin(theta);
        const c = new THREE.Color().setHSL(Math.random()*0.12 + (Math.random()*0.02+0.5), 0.7, 0.6);
        col[i3] = c.r; col[i3+1]=c.g; col[i3+2]=c.b;
      }
      halo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      halo.setAttribute('color', new THREE.BufferAttribute(col,3));
      const pts = new THREE.Points(halo, new THREE.PointsMaterial({ size:0.12, vertexColors:true, transparent:true, opacity:0.6, blending:THREE.AdditiveBlending, depthWrite:false }));
      pts.renderOrder = 1;
      this.particles = pts;
      this.group.add(pts);

      // bounding: center & scale, align to ground
      const box = new THREE.Box3().setFromObject(this.group);
      const center = box.getCenter(new THREE.Vector3());
      this.group.position.sub(center);
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x,size.y,size.z);
      const target = 4.6;
      const s = (maxDim>0) ? (target/maxDim) : 1;
      this.group.scale.setScalar(s);
      this.group.updateWorldMatrix(true,true);
      const box2 = new THREE.Box3().setFromObject(this.group);
      const minY = box2.min.y;
      this.group.position.y -= minY;

      // tighten shadow frustum to porcelain bounds (STEP: tighten & bias)
      const tightened = new THREE.Box3().setFromObject(this.group);
      const diag = tightened.getSize(new THREE.Vector3());
      const pad = 0.5;
      try {
        this.key.shadow.camera.left = -diag.x/2 - pad;
        this.key.shadow.camera.right = diag.x/2 + pad;
        this.key.shadow.camera.top = diag.y/2 + pad;
        this.key.shadow.camera.bottom = -diag.y/2 - pad;
        // small bias to avoid acne
        this.key.shadow.bias = -0.0005;
        this.key.shadow.camera.updateProjectionMatrix && this.key.shadow.camera.updateProjectionMatrix();
      } catch (e) {
        // ignore if cannot set
      }
    }

    enter(cameraTarget = { position: new THREE.Vector3(), target: new THREE.Vector3() }) {
      gsap.to(scene.background, { r: ((this.palette.bg >> 16) & 0xff)/255, g: ((this.palette.bg >> 8) & 0xff)/255, b: (this.palette.bg & 0xff)/255, duration: 0.9 });
      gsap.fromTo(this.key, { intensity: 0.0 }, { intensity: 1.8, duration: 0.9, ease:'power2.out' });
      gsap.fromTo(this.rim, { intensity:0.0 }, { intensity: 0.6, duration: 0.9, delay:0.1 });
      gsap.fromTo(this.fill, { intensity:0.0 }, { intensity:0.45, duration:0.9, delay:0.12 });

      if (cameraTarget.position) gsap.to(camera.position, { x: cameraTarget.position.x, y: cameraTarget.position.y, z: cameraTarget.position.z, duration: 1.2, ease: 'expo.inOut', onUpdate: () => controls.update() });
      if (cameraTarget.target) gsap.to(controls.target, { x: cameraTarget.target.x, y: cameraTarget.target.y, z: cameraTarget.target.z, duration: 1.2, ease: 'expo.inOut', onUpdate: () => controls.update() });

      gsap.to(bloomPass, { strength: 0.55 + (this.id*0.06), duration: 0.9 });
      gsap.fromTo(this.particles.material, { opacity: 0.0 }, { opacity: 0.6, duration: 1.2, ease: 'power2.out' });

      // ensure porcelain materials reference latest environment if it exists
      if (scene.environment) {
        this.porcelain.traverse((m) => {
          if (m.isMesh && m.material && m.material.isMeshPhysicalMaterial) {
            m.material.envMap = scene.environment;
            m.material.needsUpdate = true;
          }
        });
      }
    }

    exit() {
      gsap.to(this.key, { intensity: 0.0, duration: 0.9, ease:'power2.in' });
      gsap.to(this.fill, { intensity: 0.0, duration: 0.85 });
      gsap.to(this.rim, { intensity: 0.0, duration: 0.85 });
      gsap.to(this.particles.material, { opacity: 0.0, duration: 0.7 });
    }

    update(dt, elapsed, cursorWorld, cursorIntensity) {
      // particles
      this.particles.rotation.y += dt * (0.02 + this.id*0.01);
      this.particles.rotation.x = Math.sin(elapsed * (0.05 + this.id*0.02)) * 0.06;

      if (this.motionEnabled) {
        this.porcelain.rotation.y += dt * (0.09 + this.id * 0.03);
        this.porcelain.position.y = Math.sin(elapsed * (0.4 + this.id*0.1)) * 0.03 * (1 + this.id*0.3);
      }

      // material response using cached meshes
      if (cursorWorld && cursorIntensity > 0.02) {
        for (let m of this.porcelainMeshes) {
          const w = new THREE.Vector3(); m.getWorldPosition(w);
          const d = Math.min(1.0, cursorWorld.distanceTo(w) / 4.5);
          const effect = 1.0 - d;
          const origR = m.material.userData?.baseRoughness ?? 0.06;
          const origEnv = m.material.userData?.baseEnv ?? 1.2;
          const targetR = THREE.MathUtils.clamp(origR * (0.25 + (1 - effect)*1.0), 0.02, 1.0);
          const targetEnv = THREE.MathUtils.lerp(origEnv, origEnv + 2.2 * effect * cursorIntensity, 0.9);
          m.material.roughness = THREE.MathUtils.lerp(m.material.roughness, targetR, 0.18);
          m.material.envMapIntensity = THREE.MathUtils.lerp(m.material.envMapIntensity || origEnv, targetEnv, 0.18);
          m.material.clearcoat = THREE.MathUtils.lerp(m.material.clearcoat || 1.0, Math.min(1.0, (m.material.userData.baseClearcoat || 1.0) + 0.5 * effect), 0.18);
        }
      } else {
        for (let m of this.porcelainMeshes) {
          if (m.material && m.material.userData) {
            m.material.roughness = THREE.MathUtils.lerp(m.material.roughness, m.material.userData.baseRoughness || 0.06, 0.04);
            m.material.envMapIntensity = THREE.MathUtils.lerp(m.material.envMapIntensity || (m.material.userData.baseEnv || 1.2), m.material.userData.baseEnv || 1.2, 0.03);
            m.material.clearcoat = THREE.MathUtils.lerp(m.material.clearcoat || (m.material.userData.baseClearcoat||1.0), m.material.userData.baseClearcoat||1.0, 0.03);
          }
        }
      }
    }

    toggleMotion(flag) {
      this.motionEnabled = flag;
      // also enable/disable particle rotation by toggling motionEnabled (global toggle will call)
    }
  }

  // --------------------------
  // Procedural porcelain makers
  // --------------------------
  function makeVesselA() {
    const lathePts = [];
    for (let i=0;i<20;i++){
      const t = i/19;
      const x = 0.6 + Math.sin(t*Math.PI)*0.8 * (0.5 + 0.5*t);
      const y = -1 + t*2.2;
      lathePts.push(new THREE.Vector2(x, y));
    }
    const geo = new THREE.LatheGeometry(lathePts, 128);
    const mat = new THREE.MeshPhysicalMaterial({ color:0xf7f8fb, roughness:0.06, clearcoat:1.0, envMap: scene.environment, envMapIntensity: 1.4});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = mesh.receiveShadow = true;
    return mesh;
  }
  function makePlateB() {
    const ring = new THREE.RingGeometry(0.5, 2.0, 128);
    const bowl = new THREE.SphereGeometry(2.2, 128, 128, 0, Math.PI*2, 0, Math.PI/2);
    bowl.scale(1,0.38,1);
    const mat = new THREE.MeshPhysicalMaterial({ color:0xeaf6ff, roughness:0.03, clearcoat:1.0, envMap: scene.environment, envMapIntensity: 1.6 });
    const combo = new THREE.Group();
    const rim = new THREE.Mesh(ring, mat.clone());
    rim.rotation.x = -Math.PI/2; rim.position.y = 0.01; rim.receiveShadow = true;
    const center = new THREE.Mesh(bowl, mat.clone()); center.position.y = 0.02; center.castShadow = true;
    combo.add(center, rim);
    return combo;
  }
  function makeMiniSculptC() {
    const geo = new THREE.TorusKnotGeometry(0.9, 0.25, 256, 32, 2, 3);
    geo.rotateX(Math.PI*0.1);
    const mat = new THREE.MeshPhysicalMaterial({ color: 0xffefef, roughness: 0.08, clearcoat: 1.0, envMap: scene.environment, envMapIntensity: 1.2 });
    const m = new THREE.Mesh(geo, mat);
    m.castShadow = m.receiveShadow = true;
    return m;
  }
  function makeTallCylinderD() {
    const geo = new THREE.CylinderGeometry(0.8,0.8,3.6,64,1,true);
    const mat = new THREE.MeshPhysicalMaterial({ color: 0xfffffb, roughness: 0.06, clearcoat: 1.0, envMap: scene.environment, envMapIntensity: 1.2 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = mesh.receiveShadow = true;
    return mesh;
  }
  function makeBowlE() {
    const geo = new THREE.SphereGeometry(1.8, 128, 128, 0, Math.PI*2, 0, Math.PI/1.7);
    geo.scale(1,0.7,1);
    const mat = new THREE.MeshPhysicalMaterial({ color: 0xe8f2ff, roughness: 0.02, clearcoat:0.9, envMap: scene.environment, envMapIntensity:1.8 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = mesh.receiveShadow = true;
    return mesh;
  }

  // --------------------------
  // Build scenes array
  // --------------------------
  const scenes = [
    new PorcelainScene({ id:0, name:'Dawn Vessel', palette:{ bg:0x05050A, key:0xfff8e8 }, make: makeVesselA }),
    new PorcelainScene({ id:1, name:'Calm Mirror', palette:{ bg:0x071022, key:0xdfefff }, make: makePlateB }),
    new PorcelainScene({ id:2, name:'Whim', palette:{ bg:0x10040a, key:0xffefe9 }, make: makeMiniSculptC }),
    new PorcelainScene({ id:3, name:'Echo Column', palette:{ bg:0x071011, key:0xfffff6 }, make: makeTallCylinderD }),
    new PorcelainScene({ id:4, name:'Night Bloom', palette:{ bg:0x040618, key:0xe6f0ff }, make: makeBowlE })
  ];

  let currentIndex = 0;
  scene.add(scenes[0].group);

  const sceneCameraTargets = [
    { position: new THREE.Vector3(6,3.5,6), target: new THREE.Vector3(0,1.1,0) },
    { position: new THREE.Vector3(5.5,2.8,5.8), target: new THREE.Vector3(0,0.85,0) },
    { position: new THREE.Vector3(7,3.4,7), target: new THREE.Vector3(0,0.8,0) },
    { position: new THREE.Vector3(6.2,3.8,6.2), target: new THREE.Vector3(0,1.4,0) },
    { position: new THREE.Vector3(7.5,3.6,7.8), target: new THREE.Vector3(0,0.9,0) }
  ];

  const sceneLabel = document.getElementById('sceneLabel');
  function updateSceneLabel() {
    sceneLabel.textContent = `Scene ${currentIndex+1} / 5 — ${scenes[currentIndex].name}`;
  }
  updateSceneLabel();
  scenes[currentIndex].enter(sceneCameraTargets[currentIndex]);

  // --------------------------
  // Helper: setGroupOpacity (set transparent once, then tween opacity)
  // --------------------------
  function prepareGroupForOpacity(group) {
    group.traverse((c) => {
      if (c.isMesh && c.material) {
        if (!('__preparedTransparent' in c.material)) {
          c.material.__preparedTransparent = true;
          c.material.__origTransparent = c.material.transparent;
          c.material.__origOpacity = (c.material.opacity !== undefined) ? c.material.opacity : 1.0;
          c.material.transparent = true; // set once
        }
      }
    });
  }
  function tweenGroupOpacity(group, value) {
    group.traverse((c) => {
      if (c.isMesh && c.material && ('__preparedTransparent' in c.material)) {
        // tween opacity directly (GSAP will animate)
        gsap.to(c.material, { opacity: value, duration: 0.9, ease: 'power2.inOut' });
      }
    });
  }
  function restoreGroupMaterialStates(group) {
    group.traverse((c) => {
      if (c.isMesh && c.material && ('__preparedTransparent' in c.material)) {
        // restore original flags and remove prepared marker
        gsap.to(c.material, { opacity: c.material.__origOpacity || 1.0, duration: 0.01, onComplete: () => {
          c.material.transparent = c.material.__origTransparent;
          delete c.material.__origTransparent;
          delete c.material.__origOpacity;
          delete c.material.__preparedTransparent;
        }});
      }
    });
  }

  // --------------------------
  // Scene transitions (STEP 6: GSAP timeline, controls disabled during transition)
  // --------------------------
  let transitioning = false;
  function gotoScene(index) {
    if (transitioning || index === currentIndex || index < 0 || index >= scenes.length) return;
    transitioning = true;
    const from = scenes[currentIndex];
    const to = scenes[index];

    // add to scene if not already
    if (!to.group.parent) scene.add(to.group);

    // prepare for opacity tweening
    prepareGroupForOpacity(from.group);
    prepareGroupForOpacity(to.group);
    tweenGroupOpacity(from.group, 1.0);
    // set new scene opacity 0 initially
    to.group.traverse((c) => { if (c.isMesh && c.material) c.material.opacity = 0.0; });

    // controls disabled
    controls.enabled = false;

    const tl = gsap.timeline({
      onComplete: () => {
        // cleanup
        scene.remove(from.group);
        restoreGroupMaterialStates(to.group);
        restoreGroupMaterialStates(from.group);
        currentIndex = index;
        updateSceneLabel();
        transitioning = false;
        controls.enabled = true;
      }
    });

    // camera flight
    tl.to(camera.position, { x: sceneCameraTargets[index].position.x, y: sceneCameraTargets[index].position.y, z: sceneCameraTargets[index].position.z, duration: 1.1, ease:'expo.inOut', onUpdate: () => controls.update() }, 0);
    tl.to(controls.target, { x: sceneCameraTargets[index].target.x, y: sceneCameraTargets[index].target.y, z: sceneCameraTargets[index].target.z, duration: 1.1, ease:'expo.inOut', onUpdate: () => controls.update() }, 0);

    // fade out old group and fade in new group (just opacity tween)
    tl.to({}, { duration: 0.02 });
    tl.add(() => { from.exit(); });
    tl.to({}, { duration: 0.05 });
    tl.to({}, { duration: 0.9, onStart: () => {
      tweenGroupOpacity(from.group, 0.0);
      tweenGroupOpacity(to.group, 1.0);
    }}, 0.05);

    // ensure to.enter lighting adjustments start near the end
    tl.add(() => to.enter(sceneCameraTargets[index]), 0.1);
  }

  // keyboard nav + prevent page scrolling for arrows/space
  window.addEventListener('keydown', (e) => {
    const activeTag = document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || document.activeElement.isContentEditable);
    if (!activeTag) {
      if (e.code === 'ArrowRight') { e.preventDefault(); gotoScene((currentIndex+1)%scenes.length); }
      if (e.code === 'ArrowLeft') { e.preventDefault(); gotoScene((currentIndex-1+scenes.length)%scenes.length); }
      if (e.code === 'Space') { e.preventDefault(); scenes[currentIndex].toggleMotion(!scenes[currentIndex].motionEnabled); }
    }
  }, { passive:false });

  // --------------------------
  // Pointer, wheel, touch - scope to canvas and ignore UI panels
  // --------------------------
  const rectForCanvas = () => renderer.domElement.getBoundingClientRect();
  const isOverUI = (event) => {
    // if pointer hits any element with .panel ancestor, consider it UI
    const el = document.elementFromPoint(event.clientX, event.clientY);
    return el && el.closest && el.closest('.panel');
  };

  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2(-10,-10);
  let pointerActive = false;
  let lastInteractionTime = performance.now();
  let idleFadeDelay = 900; // ms

  function onCanvasPointerMove(e) {
    if (isOverUI(e)) return;
    const rect = rectForCanvas();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    pointerActive = true;
    lastInteractionTime = performance.now();
  }

  function onCanvasPointerDown(e) {
    if (isOverUI(e)) return;
    onCanvasPointerMove(e);
    const pos = computeCursorWorld();
    spawnPulse(pos, 0xfff0d8, 80);
  }

  renderer.domElement.addEventListener('mousemove', onCanvasPointerMove, { passive: true });
  renderer.domElement.addEventListener('pointerdown', onCanvasPointerDown, { passive: true });
  renderer.domElement.addEventListener('pointerup', () => { pointerActive = false; lastInteractionTime = performance.now(); }, { passive: true });

  // wheel (zoom) on canvas only
  renderer.domElement.addEventListener('wheel', (e) => {
    if (isOverUI(e)) return;
    const delta = e.deltaY * 0.003;
    scrollTarget += delta * 6.0;
    // clamp to orbit control bounds
    scrollTarget = THREE.MathUtils.clamp(scrollTarget, controls.minDistance, controls.maxDistance);
  }, { passive: true });

  // touch pinch-to-zoom implementation (basic)
  let touchZoomStart = null;
  renderer.domElement.addEventListener('touchstart', (e) => {
    if (e.touches && e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      touchZoomStart = Math.hypot(dx, dy);
    }
  }, { passive: true });

  renderer.domElement.addEventListener('touchmove', (e) => {
    if (isOverUI(e)) return;
    if (e.touches && e.touches.length === 2 && touchZoomStart) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const nowDist = Math.hypot(dx, dy);
      const diff = (touchZoomStart - nowDist) * 0.0025;
      scrollTarget += diff * 8.0;
      scrollTarget = THREE.MathUtils.clamp(scrollTarget, controls.minDistance, controls.maxDistance);
      touchZoomStart = nowDist;
    }
  }, { passive: true });

  renderer.domElement.addEventListener('touchend', (e) => {
    if (!e.touches || e.touches.length < 2) touchZoomStart = null;
  }, { passive: true });

  // compute cursor world using cached porcelain meshes
  function computeCursorWorld() {
    raycaster.setFromCamera(mouse, camera);
    const cur = scenes[currentIndex];
    if (cur && cur.porcelainMeshes.length) {
      const ints = raycaster.intersectObjects(cur.porcelainMeshes, true);
      if (ints.length) return ints[0].point.clone();
    }
    const ints2 = raycaster.intersectObject(interactPlane);
    if (ints2.length) return ints2[0].point.clone();
    return new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);
  }

  // --------------------------
  // smooth scroll zoom state (we own zoom)
  // --------------------------
  let scrollTarget = camera.position.distanceTo(controls.target);

  // --------------------------
  // Resize handler (single resize() per requirement STEP 7)
  // --------------------------
  function resize() {
    camera.aspect = WIDTH()/HEIGHT();
    camera.updateProjectionMatrix();
    renderer.setSize(WIDTH(), HEIGHT());
    composer.setSize(WIDTH(), HEIGHT());
    // bokeh official uniform update if present
    try {
      if (bokehPass && bokehPass.materialBokeh && bokehPass.materialBokeh.uniforms && ('aspect' in bokehPass.materialBokeh.uniforms)) {
        bokehPass.materialBokeh.uniforms.aspect.value = camera.aspect;
      } else if (bokehPass && bokehPass.uniforms && ('width' in bokehPass.uniforms)) {
        bokehPass.uniforms['width'].value = WIDTH();
        bokehPass.uniforms['height'].value = HEIGHT();
      }
    } catch (e) {}
  }
  window.addEventListener('resize', resize);

  // --------------------------
  // UI toggles
  // --------------------------
  const toggleBloom = document.getElementById('toggleBloom');
  const toggleDOF = document.getElementById('toggleDOF');
  const toggleParticles = document.getElementById('toggleParticles');

  toggleBloom.addEventListener('change', () => bloomPass.enabled = toggleBloom.checked);
  toggleDOF.addEventListener('change', () => bokehPass.enabled = toggleDOF.checked);
  toggleParticles.addEventListener('change', () => {
    scenes.forEach(s => { if (s.particles) s.particles.visible = toggleParticles.checked; });
  });

  // --------------------------
  // Animation loop & idle management
  // --------------------------
  const clock = new THREE.Clock();

  function animate() {
    const dt = Math.min(0.05, clock.getDelta());
    const elapsed = clock.getElapsedTime();

    // smooth camera zoom by moving camera along forward vector and clamping
    const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
    const desiredDistance = THREE.MathUtils.lerp(camera.position.distanceTo(controls.target), scrollTarget, 0.06);
    const newCamPos = new THREE.Vector3().copy(camDir).multiplyScalar(-desiredDistance).add(controls.target);
    camera.position.lerp(newCamPos, 0.08);

    // cursor world & intensity
    let cursorWorld = null;
    let cursorIntensity = 0;
    if (mouse.x > -9) {
      cursorWorld = computeCursorWorld();
      const worldCenter = new THREE.Vector3();
      scenes[currentIndex].group.getWorldPosition(worldCenter);
      const dist = cursorWorld.distanceTo(worldCenter);
      cursorIntensity = THREE.MathUtils.clamp(1.0 - (dist / 10.0), 0.0, 1.0);
    }

    // idle: fade cursor after inactivity
    const inactive = (performance.now() - lastInteractionTime) > idleFadeDelay;
    if (inactive) pointerActive = false;

    // update cursor visuals if present
    if (cursorWorld && !inactive) {
      cursorLight.position.lerp(cursorWorld, 0.18);
      cursorBall.position.lerp(cursorWorld, 0.17);
      glow.position.lerp(new THREE.Vector3().copy(cursorWorld).add(new THREE.Vector3().subVectors(camera.position, cursorWorld).setLength(0.06)), 0.18);

      // STEP 1 — reduce multiplier, clamp intensity and lerp (smooth interpolation)
      // also cap by camera distance to avoid bloom spikes
      const camDist = camera.position.distanceTo(cursorWorld);
      const camFactor = THREE.MathUtils.clamp(8.0 / Math.max(0.001, camDist), 0.0, 1.0); // closer gives stronger cap
      const intendedRaw = 0.04 + cursorIntensity * 1.6;
      const intendedClamped = THREE.MathUtils.clamp(intendedRaw * camFactor, 0.04, 1.8);
      cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, intendedClamped, 0.12);

      glow.material.opacity = THREE.MathUtils.lerp(glow.material.opacity, 0.65 * (cursorIntensity*0.85 + 0.15), 0.12);
      const gS = THREE.MathUtils.lerp(glow.scale.x, 0.3 + cursorIntensity*1.8, 0.12);
      glow.scale.setScalar(gS);
    } else {
      cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, 0.0, 0.06);
      glow.material.opacity = THREE.MathUtils.lerp(glow.material.opacity, 0.0, 0.05);
    }

    // update pulses (recycle to pool)
    for (let i = activePulses.length-1; i >= 0; i--) {
      const p = activePulses[i];
      p.userData.life -= dt * 0.8;
      const posAttr = p.geometry.attributes.position;
      const velAttr = p.geometry.attributes.vel;
      for (let v=0; v<posAttr.count; v++){
        posAttr.array[v*3] += velAttr.array[v*3] * dt;
        posAttr.array[v*3+1] += velAttr.array[v*3+1] * dt;
        posAttr.array[v*3+2] += velAttr.array[v*3+2] * dt;
        velAttr.array[v*3+1] -= dt * 0.9;
      }
      posAttr.needsUpdate = true;
      velAttr.needsUpdate = true;
      p.material.opacity = Math.max(0, p.userData.life);
      if (p.userData.life <= 0) {
        // remove and recycle
        const idx = activePulses.indexOf(p);
        if (idx !== -1) activePulses.splice(idx, 1);
        if (p.parent) p.parent.remove(p);
        recyclePulse(p);
      }
    }

    // update current scene
    scenes[currentIndex].update(dt, elapsed, cursorWorld, cursorIntensity);

    controls.update();
    composer.render();

    requestAnimationFrame(animate);
  }

  requestAnimationFrame(animate);
  </script>
</body>
</html>
