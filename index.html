<!doctype html>
<html lang="en">
  <head>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>Porcelain 3D</title>
      <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"></script>
      <style>
        html,
        body {
          height: 100%;
          margin: 0;
          background: #101113;
        }

        canvas {
          width: 100%;
          height: 100%;
          display: block;
        }

        .hud {
          position: fixed;
          top: 10px;
          left: 10px;
          color: #cfcfcf;
          font: 14px system-ui;
          opacity: 0.9;
          z-index: 5;
        }

        .viewer-pocket {
          position: fixed;
          right: 20px;
          bottom: 20px;
          width: min(320px, 30vw);
          aspect-ratio: 1;
          border-radius: 18px;
          overflow: hidden;
          border: 1px solid #2a2c31;
          box-shadow: 0 12px 25px rgba(0, 0, 0, 0.35);
          background: radial-gradient(circle at top, rgba(29, 33, 40, 0.9), rgba(10, 12, 15, 0.9));
          z-index: 4;
        }

        .viewer-pocket::after {
          content: "model-viewer demo";
          position: absolute;
          left: 16px;
          bottom: 16px;
          font: 500 12px/1.2 "Inter", system-ui, sans-serif;
          letter-spacing: 0.08em;
          text-transform: uppercase;
          color: rgba(222, 229, 255, 0.75);
          backdrop-filter: blur(2px);
        }

        model-viewer {
          width: 100%;
          height: 100%;
          --poster-color: rgba(22, 24, 28, 0.85);
        }

        @media (max-width: 768px) {
          .viewer-pocket {
            width: min(260px, 50vw);
          }
        }
      </style>
</head>
<body>
    <div class="hud">drag = orbit â€¢ wheel = zoom â€¢ dbl-click = focus</div>
    <canvas id="c"></canvas>
    <div class="viewer-pocket">
      <model-viewer
        alt="Neil Armstrong's Spacesuit from the Smithsonian Digitization Programs Office and National Air and Space Museum"
        src="https://modelviewer.dev/shared-assets/models/Astronaut.glb"
        ar
        environment-image="https://modelviewer.dev/shared-assets/environments/moon_1k.hdr"
        poster="https://modelviewer.dev/shared-assets/models/Astronaut.webp"
        shadow-intensity="1"
        camera-controls
        touch-action="pan-y"
      >
      </model-viewer>
    </div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js";
      import { GLTFLoader } from "https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js";
      import { EffectComposer } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/EffectComposer.js";
      import { RenderPass } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/UnrealBloomPass.js";
      import { FilmPass } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/FilmPass.js";
      import { ShaderPass } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/ShaderPass.js";

        const canvas = document.getElementById("c");
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x080811);
        scene.fog = new THREE.Fog(0x090a15, 10, 35);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 150);
        camera.position.set(1.6, 1.1, 1.6);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.065;
        controls.minDistance = 0.2;
        controls.maxDistance = 12;

        const hemi = new THREE.HemisphereLight(0xd7e0ff, 0x1a1b1f, 0.55);
        scene.add(hemi);

        const key = new THREE.DirectionalLight(0xffffff, 1.6);
        key.position.set(2, 3, 1);
        key.castShadow = true;
        key.shadow.mapSize.set(2048, 2048);
        scene.add(key);

        const rim = new THREE.DirectionalLight(0x92b7ff, 0.75);
        rim.position.set(-2.5, 1.8, -1.4);
        scene.add(rim);

        const ground = new THREE.Mesh(
          new THREE.CylinderGeometry(3.5, 3.5, 0.02, 48),
          new THREE.MeshStandardMaterial({
            color: 0x121222,
            roughness: 0.8,
            metalness: 0.08,
            emissive: 0x040408,
            emissiveIntensity: 0.15
          })
        );
        ground.receiveShadow = true;
        ground.position.y = -0.01;
        scene.add(ground);

        const grid = new THREE.GridHelper(4, 40, 0x3a3c3f, 0x222427);
        grid.position.y = 0;
        grid.material.opacity = 0.15;
        grid.material.transparent = true;
        scene.add(grid);

        const modelGroup = new THREE.Group();
        scene.add(modelGroup);

        const sparkleCount = 450;
        const sparkleGeometry = new THREE.BufferGeometry();
        const sparklePositions = new Float32Array(sparkleCount * 3);
        for (let i = 0; i < sparkleCount; i++) {
          const radius = 2 + Math.random() * 5.5;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          sparklePositions[i * 3 + 0] = radius * Math.sin(phi) * Math.cos(theta);
          sparklePositions[i * 3 + 1] = radius * Math.cos(phi) * 0.45;
          sparklePositions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
        }
        sparkleGeometry.setAttribute("position", new THREE.BufferAttribute(sparklePositions, 3));

        const sparkleMaterial = new THREE.PointsMaterial({
          color: new THREE.Color(0x84c2ff),
          size: 0.08,
          transparent: true,
          opacity: 0.85,
          depthWrite: false,
          blending: THREE.AdditiveBlending
        });

        const sparkles = new THREE.Points(sparkleGeometry, sparkleMaterial);
        sparkles.position.y = 0.35;
        sparkles.visible = false;
        scene.add(sparkles);

        const envCanvas = document.createElement("canvas");
        envCanvas.width = 512;
        envCanvas.height = 256;
        const envCtx = envCanvas.getContext("2d");
        const gradient = envCtx.createLinearGradient(0, 0, 0, envCanvas.height);
        gradient.addColorStop(0, "#1e1a3e");
        gradient.addColorStop(0.35, "#3e1a6b");
        gradient.addColorStop(0.7, "#0b2048");
        gradient.addColorStop(1, "#06121f");
        envCtx.fillStyle = gradient;
        envCtx.fillRect(0, 0, envCanvas.width, envCanvas.height);
        const envTexture = new THREE.CanvasTexture(envCanvas);
        envTexture.mapping = THREE.EquirectangularReflectionMapping;
        envTexture.colorSpace = THREE.SRGBColorSpace;
        envTexture.anisotropy = 4;
        scene.environment = envTexture;

        const composer = new EffectComposer(renderer);
        composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        composer.setSize(window.innerWidth, window.innerHeight);

        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          0.7,
          0.45,
          0.85
        );
        composer.addPass(bloomPass);

        const filmPass = new FilmPass(0.32, 0.55, 1024, false);
        composer.addPass(filmPass);

        const AuroraShader = {
          uniforms: {
            tDiffuse: { value: null },
            time: { value: 0 },
            resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
          },
          vertexShader: /* glsl */ `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = vec4(position, 1.0);
            }
          `,
          fragmentShader: /* glsl */ `
            precision highp float;
            varying vec2 vUv;
            uniform sampler2D tDiffuse;
            uniform vec2 resolution;
            uniform float time;

            float hash(vec2 p) {
              p = fract(p * vec2(123.34, 456.21));
              p += dot(p, p + 45.32);
              return fract(p.x * p.y);
            }

            float noise(vec2 p) {
              vec2 i = floor(p);
              vec2 f = fract(p);
              float a = hash(i);
              float b = hash(i + vec2(1.0, 0.0));
              float c = hash(i + vec2(0.0, 1.0));
              float d = hash(i + vec2(1.0, 1.0));
              vec2 u = f * f * (3.0 - 2.0 * f);
              return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }

            float fbm(vec2 p) {
              float value = 0.0;
              float amplitude = 0.5;
              for (int i = 0; i < 5; i++) {
                value += amplitude * noise(p);
                p *= 2.2;
                amplitude *= 0.55;
              }
              return value;
            }

            void main() {
              vec2 uv = vUv;
              vec3 base = texture2D(tDiffuse, uv).rgb;

              vec2 swirl = uv * vec2(2.8, 1.6);
              float aurora = fbm(swirl + vec2(0.0, time * 0.06));
              float veil = fbm(swirl * mat2(1.2, -0.7, 0.7, 1.2) + time * 0.03);
              float beam = smoothstep(0.35, 0.95, aurora * 1.4 + veil * 0.5);
              float spark = fbm(uv * 12.0 + time * 0.5);
              float sparkle = smoothstep(0.8, 1.0, spark);

              vec3 auroraColor = mix(vec3(0.26, 0.4, 0.98), vec3(0.9, 0.3, 0.95), aurora);
              vec3 glow = auroraColor * beam * 0.6 + vec3(0.2, 0.6, 1.0) * sparkle * 0.25;

              vec3 finalColor = mix(base, base + glow, 0.38);
              finalColor += beam * 0.08;

              gl_FragColor = vec4(finalColor, 1.0);
            }
          `
        };

        const auroraPass = new ShaderPass(AuroraShader);
        composer.addPass(auroraPass);

        // ðŸ‘‡ If you upload your file to /assets/, change path to "/assets/porcelain.glb"
        const loader = new GLTFLoader();
        const glbUrl = "./porcelain.glb";

        const frameBox = new THREE.Box3();
        const frameVec = new THREE.Vector3();

        loader.load(
          glbUrl,
          (gltf) => {
            const model = gltf.scene;

            model.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material && Array.isArray(child.material)) {
                  child.material.forEach((mat) => (mat.toneMapped = true));
                } else if (child.material) {
                  child.material.toneMapped = true;
                }
              }
            });

          modelGroup.clear();
          modelGroup.add(model);

          frameBox.setFromObject(model);
          const center = frameBox.getCenter(frameVec);
          model.position.sub(center);

          frameBox.setFromObject(model);
          const floorOffset = frameBox.min.y;
          model.position.y -= floorOffset;

          frameBox.setFromObject(model);
          const size = frameBox.getSize(frameVec);
          const radius = size.length() * 0.5;
          const fov = THREE.MathUtils.degToRad(camera.fov);
          const distance = radius / Math.tan(fov * 0.5);

            const framedCenter = frameBox.getCenter(frameVec);
            controls.target.copy(framedCenter);
            camera.position.set(distance * 0.9, distance * 0.6 + size.y * 0.15, distance * 0.9);
            camera.near = Math.max(0.01, radius * 0.02);
            camera.far = radius * 20;
            camera.updateProjectionMatrix();

            const hud = document.querySelector(".hud");
            if (hud) {
              hud.textContent = "drag = orbit â€¢ wheel = zoom â€¢ dbl-click = focus";
              hud.style.color = "#cfcfcf";
            }

            sparkles.visible = true;
          },
          undefined,
          (error) => {
            console.error("Failed to load porcelain.glb", error);
            const hud = document.querySelector(".hud");
            if (hud) {
              hud.textContent = "Could not load porcelain.glb â€“ check the file path.";
              hud.style.color = "#ff8a8a";
            }
            sparkles.visible = false;
          }
        );

        const clock = new THREE.Clock();
        let spinSpeed = 0.25;

        function animate() {
          const delta = clock.getDelta();
          const elapsed = clock.elapsedTime;

            modelGroup.rotation.y += spinSpeed * delta;
            sparkles.rotation.y += delta * 0.1;
            sparkles.rotation.x = Math.sin(elapsed * 0.08) * 0.1;

          bloomPass.strength = 0.65 + Math.sin(elapsed * 0.45) * 0.18;
          bloomPass.radius = 0.6 + Math.cos(elapsed * 0.35) * 0.05;
          filmPass.uniforms.nIntensity.value = 0.35 + Math.sin(elapsed * 0.7) * 0.06;
          filmPass.uniforms.sIntensity.value = 0.45 + Math.cos(elapsed * 0.4) * 0.08;
            auroraPass.uniforms.time.value = elapsed;

          controls.update();
          composer.render();
          requestAnimationFrame(animate);
        }

        animate();

        addEventListener("resize", () => {
          const width = window.innerWidth;
          const height = window.innerHeight;

          renderer.setSize(width, height);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

          composer.setSize(width, height);
          bloomPass.setSize(width, height);

          camera.aspect = width / height;
          camera.updateProjectionMatrix();

            auroraPass.uniforms.resolution.value.set(width, height);
        });

        // double-click to focus
        renderer.domElement.addEventListener("dblclick", (e) => {
          const r = renderer.domElement.getBoundingClientRect();
          const ndc = new THREE.Vector2(
            ((e.clientX - r.left) / r.width) * 2 - 1,
            -((e.clientY - r.top) / r.height) * 2 + 1
          );
          const ray = new THREE.Raycaster();
          ray.setFromCamera(ndc, camera);
          const hit = ray.intersectObjects(modelGroup.children, true)[0];
          if (hit) {
            controls.target.copy(hit.point);
          }
        });

        document.addEventListener("keydown", (event) => {
          if (event.code === "Space") {
            spinSpeed = spinSpeed > 0 ? 0 : 0.25;
          }
        });
      </script>
</body>
</html>
