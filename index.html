<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Porcelain Transcendence — v7-stable corrected</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html,body,#container{height:100%;width:100%}
    body{
      background:#000;
      color:#fff;
      font-family:"Segoe UI",Inter,system-ui,-apple-system,Roboto,"Helvetica Neue",Arial;
      overflow:hidden;
    }
    #container{position:fixed;inset:0}
    canvas{display:block;touch-action:none}
    .ui{position:absolute;z-index:60;inset:0;pointer-events:none}
    .panel{pointer-events:auto;position:absolute;background:rgba(0,0,0,0.45);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,0.06);padding:10px 12px;border-radius:10px;font-size:13px}
    .top-left{left:16px;top:16px}
    .top-right{right:16px;top:16px;text-align:right}
    .bottom-left{left:16px;bottom:16px}
    .scene-indicator{font-weight:600;opacity:.95}
    .small{font-size:12px;opacity:.85}
    button{cursor:pointer}
  </style>
</head>
<body>
  <div id="container" role="application" aria-label="Porcelain Transcendence canvas"></div>

  <div class="ui" aria-hidden="false">
    <div class="panel top-left" role="region" aria-label="Scene information">
      <div id="sceneLabel" class="scene-indicator" role="status" aria-live="polite">Scene 1 / 5 — Dawn Vessel</div>
      <div class="small">← → : Change Scene • SPACE : Toggle Motion • Click : reactive pulse</div>
    </div>

    <div class="panel top-right" role="region" aria-label="Effects">
      <label><input id="toggleBloom" type="checkbox" checked> Bloom</label><br>
      <label><input id="toggleDOF" type="checkbox"> DOF</label><br>
      <label><input id="toggleParticles" type="checkbox" checked> Particles</label><br>
      <button id="fsBtn">Fullscreen</button>
    </div>

    <div class="panel bottom-left" role="region" aria-label="Controls">
      <div class="small">Drag: orbit • Pinch: zoom • Scroll: chapter (one notch → next)</div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
    }
  }
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
  import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
  import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

  // ---------- One-time sizing & DPR ----------
  const container = document.getElementById('container');
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  const WIDTH = () => window.innerWidth;
  const HEIGHT = () => window.innerHeight;

  // ---------- Hoisted raycast state (single source) ----------
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2(-10, -10);
  let lastInteraction = performance.now();

  // ---------- Core scene/camera/renderer ----------
  const scene = new THREE.Scene();
  // slightly brighter infinity background and subtle fog to help upper-half sunset read
  scene.background = new THREE.Color(0x0f0712);
  scene.fog = new THREE.FogExp2(0x08010a, 0.03);

  const camera = new THREE.PerspectiveCamera(45, WIDTH()/HEIGHT(), 0.05, 2000);
  camera.position.set(7.8, 3.8, 8.8);

  const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
  renderer.setPixelRatio(DPR);
  renderer.setSize(WIDTH(), HEIGHT());
  if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
  else renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 0.95;
  renderer.physicallyCorrectLights = true;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  // ---------- Controls ----------
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.enableZoom = false; // disable so our scroll owns zoom
  controls.minDistance = 1.6;
  controls.maxDistance = 40;
  controls.maxPolarAngle = Math.PI * 0.495;

  // ---------- Composer & passes ----------
  const composer = new EffectComposer(renderer);
  composer.setSize(WIDTH(), HEIGHT());
  composer.setPixelRatio(DPR);
  composer.addPass(new RenderPass(scene, camera));

  const bloomPass = new UnrealBloomPass(new THREE.Vector2(WIDTH(), HEIGHT()), 0.55, 0.6, 0.85);
  composer.addPass(bloomPass);

  const bokehPass = new BokehPass(scene, camera, { focus: 20.0, aperture: 0.00085, maxblur: 0.015, width: WIDTH(), height: HEIGHT() });
  bokehPass.enabled = false;
  composer.addPass(bokehPass);

  const smaaPass = new SMAAPass(Math.floor(WIDTH()*DPR), Math.floor(HEIGHT()*DPR));
  composer.addPass(smaaPass);

  // small grade + vignette shader (fixed smoothstep ordering)
  const gradePass = new ShaderPass(new THREE.ShaderMaterial({
    uniforms: {
      tDiffuse: { value: null },
      uGrade: { value: new THREE.Vector3(1,1,1) },
      uVignette: { value: 0.36 },
      uVignetteSoft: { value: 0.36 }
    },
    vertexShader: `
      varying vec2 vUv;
      void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
    `,
    fragmentShader: `
      uniform sampler2D tDiffuse;
      uniform vec3 uGrade;
      uniform float uVignette;
      uniform float uVignetteSoft;
      varying vec2 vUv;
      void main(){
        vec4 c = texture2D(tDiffuse, vUv);
        vec3 graded = pow(c.rgb, vec3(0.96)) * uGrade;
        float d = length(vUv - vec2(0.5));
        float vig = smoothstep(uVignette - uVignetteSoft, uVignette, d);
        graded *= mix(1.0, 0.86, vig);
        graded = min(graded, vec3(1.0));
        gl_FragColor = vec4(graded, c.a);
      }
    `
  }), 'tDiffuse');
  composer.addPass(gradePass);

  // ---------- PMREM / HDR lifecycle ----------
  let pmrem = new THREE.PMREMGenerator(renderer);
  pmrem.compileEquirectangularShader();
  let currentEnv = null;
  function assignEnv(envTex){
    if(currentEnv && currentEnv.dispose) try{ currentEnv.dispose(); }catch(e){}
    currentEnv = envTex;
    scene.environment = currentEnv;
  }
  (function bakePlaceholder(){
    const urls = new Array(6).fill('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==');
    new THREE.CubeTextureLoader().load(urls, (cube) => {
      const env = pmrem.fromCubemap(cube).texture;
      try{ cube.dispose(); }catch(e){}
      assignEnv(env);
    });
  })();
  new RGBELoader().setDataType(THREE.UnsignedByteType).load('textures/studio_small_04_1k.hdr', (hdr) => {
    hdr.mapping = THREE.EquirectangularReflectionMapping;
    const env = pmrem.fromEquirectangular(hdr).texture;
    try{ hdr.dispose && hdr.dispose(); }catch(e){}
    assignEnv(env);
    try{ pmrem.dispose(); }catch(e){}
    pmrem = new THREE.PMREMGenerator(renderer);
  }, undefined, ()=>{});

  // ---------- ground/disc/interaction plane ----------
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(400,400), new THREE.MeshStandardMaterial({ color:0x050505, roughness:0.86 }));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  const disc = new THREE.Mesh(new THREE.CircleGeometry(10, 64), new THREE.MeshStandardMaterial({ color:0x0e0e10, roughness:0.48, metalness:0.03 }));
  disc.rotation.x = -Math.PI/2; disc.position.y = 0.001; disc.receiveShadow = true; scene.add(disc);

  // interact plane (single)
  const interactPlane = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshBasicMaterial({ visible:false }));
  interactPlane.rotation.x = -Math.PI/2; interactPlane.position.y = 0; scene.add(interactPlane);

  // ---------- helper textures for particles ----------
  function canvasTex(kind='bokeh', size=256, color='#fff'){
    const c = document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
    const cx=size/2,cy=size/2;
    ctx.clearRect(0,0,size,size);
    if(kind==='bokeh'){ const g = ctx.createRadialGradient(cx,cy,0,cx,cy,size/2); g.addColorStop(0,color); g.addColorStop(0.35,color); g.addColorStop(0.8,'rgba(255,255,255,0.35)'); g.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=g; ctx.fillRect(0,0,size,size); }
    if(kind==='petal'){ ctx.fillStyle=color; ctx.beginPath(); ctx.ellipse(cx,cy,size*0.46,size*0.34,0,0,Math.PI*2); ctx.fill(); }
    if(kind==='pixel'){ ctx.fillStyle=color; const s=size*0.36; ctx.fillRect(cx-s/2,cy-s/2,s,s); }
    if(kind==='grid'){ ctx.fillStyle=color; ctx.fillRect(0,0,size,size); ctx.strokeStyle='rgba(255,255,255,0.03)'; ctx.lineWidth=1; for(let x=0;x<size;x+=12){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,size); ctx.stroke(); } for(let y=0;y<size;y+=12){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(size,y); ctx.stroke(); } }
    const tx = new THREE.CanvasTexture(c); tx.minFilter = THREE.LinearFilter; tx.magFilter = THREE.LinearFilter; tx.needsUpdate = true; return tx;
  }
  const texBokeh = canvasTex('bokeh',256,'#ffffff');
  const texPetal = canvasTex('petal',256,'#ffdfe8');
  const texPixel = canvasTex('pixel',128,'#ffdfe8');
  const texGrid = canvasTex('grid',256,'#120004');

  // ---------- glow sprite & cursor ----------
  function genGlow(size=512,color='#fff3d9'){ const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d'); const g=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2); g.addColorStop(0,color); g.addColorStop(0.25,color); g.addColorStop(0.6,'rgba(255,243,217,0.45)'); g.addColorStop(1,'rgba(255,243,217,0)'); ctx.fillStyle=g; ctx.fillRect(0,0,size,size); const tx=new THREE.CanvasTexture(c); tx.minFilter=THREE.LinearFilter; tx.magFilter=THREE.LinearFilter; tx.needsUpdate=true; return tx; }
  const cursorLight = new THREE.PointLight(0xfff7ea, 0.0, 28, 2.2); cursorLight.castShadow=false; scene.add(cursorLight);
  const cursorBall = new THREE.Mesh(new THREE.SphereGeometry(0.06,12,12), new THREE.MeshBasicMaterial({ color:0xfff3d9 })); cursorBall.frustumCulled=false; scene.add(cursorBall);
  const glowSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: genGlow(512,'#fff3d9'), blending: THREE.AdditiveBlending, transparent:true, opacity:0.65, depthWrite:false }));
  glowSprite.scale.setScalar(0.8); scene.add(glowSprite);

  // ---------- pulse pool ----------
  const pulsePool = [], activePulses = [];
  function createPulse(count=80){ const geom=new THREE.BufferGeometry(); const pos=new Float32Array(count*3); const vel=new Float32Array(count*3); geom.setAttribute('position', new THREE.BufferAttribute(pos,3)); geom.setAttribute('vel', new THREE.BufferAttribute(vel,3)); const mat=new THREE.PointsMaterial({ size:0.05, color:0xfff0d8, transparent:true, opacity:1, depthWrite:false }); const pts=new THREE.Points(geom,mat); pts.userData={life:0,count}; return pts; }
  function getPulse(c=80){ if(pulsePool.length) return pulsePool.pop(); return createPulse(c); }
  function recyclePulse(p){ p.visible=false; p.userData.life=0; pulsePool.push(p); }
  function spawnPulse(point,color=0xfff0d8,count=80){ const pts=getPulse(count); const posAttr=pts.geometry.attributes.position; const velAttr=pts.geometry.attributes.vel; for(let i=0;i<pts.userData.count;i++){ const phi=Math.acos(2*Math.random()-1), theta=Math.random()*Math.PI*2, r=0.02+Math.random()*0.08; posAttr.array[i*3]=point.x + r*Math.sin(phi)*Math.cos(theta); posAttr.array[i*3+1]=point.y + r*Math.cos(phi); posAttr.array[i*3+2]=point.z + r*Math.sin(phi)*Math.sin(theta); velAttr.array[i*3]=(Math.random()-0.5)*0.9; velAttr.array[i*3+1]=Math.random()*1.2+0.2; velAttr.array[i*3+2]=(Math.random()-0.5)*0.9; } posAttr.needsUpdate=true; velAttr.needsUpdate=true; pts.material.color.setHex(color); pts.userData.life=1; pts.visible=true; if(!pts.parent) scene.add(pts); activePulses.push(pts); }

  // ---------- instanced particle rig: uses vUv and sets geometry.instanceCount ----------
  function createInstancedRig(maxInstances=1200, texture=texBokeh){
    const base = new THREE.PlaneGeometry(1,1);
    const inst = new THREE.InstancedBufferGeometry();
    inst.index = base.index;
    inst.attributes.position = base.attributes.position;
    inst.attributes.uv = base.attributes.uv;

    const offsets = new Float32Array(maxInstances*3);
    const sizes = new Float32Array(maxInstances);
    const hues = new Float32Array(maxInstances);
    const phases = new Float32Array(maxInstances);
    const drag = new Float32Array(maxInstances);
    for(let i=0;i<maxInstances;i++){
      offsets[i*3] = (Math.random()-0.5)*20;
      offsets[i*3+1] = Math.random()*10;
      offsets[i*3+2] = (Math.random()-0.5)*20;
      sizes[i] = Math.random()*0.8 + 0.08;
      hues[i] = Math.random();
      phases[i] = Math.random()*Math.PI*2;
      drag[i] = Math.random()*0.12 + 0.02;
    }
    inst.setAttribute('offset', new THREE.InstancedBufferAttribute(offsets,3));
    inst.setAttribute('sizeAttr', new THREE.InstancedBufferAttribute(sizes,1));
    inst.setAttribute('hue', new THREE.InstancedBufferAttribute(hues,1));
    inst.setAttribute('phase', new THREE.InstancedBufferAttribute(phases,1));
    inst.setAttribute('drag', new THREE.InstancedBufferAttribute(drag,1));

    // set the draw count on the geometry directly
    inst.instanceCount = maxInstances;

    const mat = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uFlow: { value: 0.0 },
        uStage: { value: 0 },
        uColorGrade: { value: new THREE.Vector3(1,1,1) },
        uOpacity: { value: 0.6 },
        map: { value: texture }
      },
      vertexShader: `
        attribute vec3 offset;
        attribute float sizeAttr;
        attribute float phase;
        attribute float drag;
        attribute vec2 uv;
        varying vec2 vUv;
        varying float vPhase;
        uniform float uTime;
        uniform float uFlow;
        uniform float uStage;
        void main(){
          vUv = uv;
          vPhase = phase;
          float t = uTime * (0.2 + drag);
          vec3 p = offset;
          if(uFlow < 0.5){
            p.y += t * 0.12 * (1.0 + uStage*0.3);
            p.x += sin(t + phase) * 0.25 * (0.5 + uStage*0.8);
            p.z += cos(t*0.9 + phase) * 0.2;
          } else if(uFlow < 1.5){
            float line = sin(offset.x*0.12 + offset.z*0.08 + phase);
            p.x += mix(0.0, sign(line)*0.7, uStage) * 0.6;
            p.y += t*0.06;
          } else if(uFlow < 2.5){
            p.x += sin(t*1.2 + phase) * (0.6 + uStage*0.9);
            p.y += t * 0.1;
          } else if(uFlow < 3.5){
            float theta = uTime*1.2 + phase*2.0;
            p.x += cos(theta) * (uStage*0.6);
            p.z += sin(theta) * (uStage*0.6);
            p.y += t*0.18;
          } else {
            p.x += sin(phase*3.0) * (0.2 + uStage*0.9);
            p.y += t * 0.08;
            p.z += cos(phase*3.0) * (0.2 + uStage*0.9);
          }
          float finalSize = sizeAttr * (0.6 + 0.8) * (1.0 + uStage*0.25);
          vec4 mv = modelViewMatrix * vec4(p, 1.0);
          vec3 right = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
          vec3 up = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);
          vec3 pos = mv.xyz + (right * position.x + up * position.y) * finalSize;
          gl_Position = projectionMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        varying float vPhase;
        uniform sampler2D map;
        uniform vec3 uColorGrade;
        uniform float uOpacity;
        void main(){
          vec4 c = texture2D(map, vUv);
          vec3 col = c.rgb * uColorGrade;
          gl_FragColor = vec4(col, c.a * uOpacity);
          if (gl_FragColor.a < 0.01) discard;
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const mesh = new THREE.Mesh(inst, mat);
    mesh.frustumCulled = false;
    return mesh;
  }

  // ---------- micro bump map & material enhancement ----------
  function microBump(){
    const c = document.createElement('canvas'); c.width=c.height=512; const ctx=c.getContext('2d');
    for(let i=0;i<6000;i++){ const x=Math.random()*512, y=Math.random()*512, s=Math.random()*1.2; ctx.fillStyle=`rgba(200,200,200,${0.02+Math.random()*0.02})`; ctx.fillRect(x,y,s,s); }
    const tx = new THREE.CanvasTexture(c); tx.wrapS=tx.wrapT=THREE.RepeatWrapping; tx.repeat.set(4,4); tx.needsUpdate=true; return tx;
  }
  const microBumpMap = microBump();

  function enhanceMaterial(mat){
    if(!mat) return;
    mat.bumpMap = microBumpMap;
    mat.bumpScale = 0.02;
    mat.clearcoat = Math.max(0.8, mat.clearcoat || 1.0);
    mat.clearcoatRoughness = 0.06;
    mat.needsUpdate = true;
  }

  // ---------- SceneNode (v7 style with fixes) ----------
  class SceneNode {
    constructor(opts){
      this.id = opts.id;
      this.name = opts.name;
      this.palette = opts.palette;
      this.make = opts.make;
      this.rail = opts.rail || [];
      this.chapters = opts.chapters || 4;
      this.texture = opts.texture || texBokeh;
      this.group = new THREE.Group();
      this.meshCache = [];
      this.particleRig = null;
      this.motionEnabled = true;
      this.setup();
    }
    setup(){
      this.group.clear();
      this.meshCache.length = 0;
      this.hemi = new THREE.HemisphereLight(0xdeeefe, 0x020204, 0.45); this.group.add(this.hemi);
      this.key = new THREE.DirectionalLight(this.palette.key || 0xffffff, 2.05); this.key.castShadow=true; this.key.shadow.mapSize.set(1024,1024); this.key.shadow.bias=-0.0005; this.key.position.set(5.8,9.2,5.6); this.group.add(this.key);
      this.fill = new THREE.DirectionalLight(0x8fb3ff, 0.45); this.fill.castShadow=false; this.fill.position.set(-6,5,-6); this.group.add(this.fill);
      this.rim = new THREE.DirectionalLight(0xfff3d9,0.56); this.rim.castShadow=false; this.rim.position.set(0,6,-8); this.group.add(this.rim);

      const obj = this.make();
      obj.traverse(c => {
        if(c.isMesh){
          c.castShadow=true; c.receiveShadow=true;
          enhanceMaterial(c.material);
          this.meshCache.push(c);
        }
      });
      this.group.add(obj); this.porcelain = obj;

      const box = new THREE.Box3().setFromObject(this.group); const size = box.getSize(new THREE.Vector3()); const pad = Math.max(0.4, Math.min(size.length()*0.22, 2.0));
      try{ this.key.shadow.camera.left=-size.x/2 - pad; this.key.shadow.camera.right=size.x/2 + pad; this.key.shadow.camera.top=size.y/2 + pad; this.key.shadow.camera.bottom=-size.y/2 - pad; this.key.shadow.camera.updateProjectionMatrix && this.key.shadow.camera.updateProjectionMatrix(); }catch(e){}

      this.particleRig = createInstancedRig(1200, this.texture);
      if(this.particleRig.geometry) this.particleRig.geometry.instanceCount = 1200;
      this.particleRig.material.uniforms.uColorGrade.value = this.palette.grade || new THREE.Vector3(1,1,1);
      this.particleRig.material.uniforms.uOpacity.value = 0.6;
      this.group.add(this.particleRig);

      // center & scale to target size
      const b = new THREE.Box3().setFromObject(this.group);
      const c = b.getCenter(new THREE.Vector3()); this.group.position.sub(c);
      const s = Math.max(0.0001, (4.6 / Math.max(...Object.values(b.getSize(new THREE.Vector3()))))); this.group.scale.setScalar(s);
      this.group.updateWorldMatrix(true,true);
      const b2 = new THREE.Box3().setFromObject(this.group); const minY = b2.min.y; this.group.position.y -= minY;
    }
    enter(railIdx=0){
      gsap.to(scene.background, { r: ((this.palette.bg>>16)&0xff)/255, g: ((this.palette.bg>>8)&0xff)/255, b: (this.palette.bg&0xff)/255, duration:0.9 });
      gsap.to(this.key, { intensity: 2.05, duration: 0.9, ease:'power2.out' });
      const rail = this.rail[0];
      if(rail){ gsap.to(camera.position, { x: rail.position.x, y: rail.position.y, z: rail.position.z, duration:1.0, ease:'expo.inOut', onUpdate: ()=>controls.update() }); gsap.to(controls.target, { x: rail.target.x, y: rail.target.y, z: rail.target.z, duration:1.0, ease:'expo.inOut', onUpdate: ()=>controls.update() }); }
      this.meshCache.forEach(m=>{ if(m.material){ m.material.envMap = scene.environment; m.material.needsUpdate = true; }});
      gsap.to(disc.material.color, { r: ((this.palette.bg>>16)&0xff)/255*0.12+0.02, g: ((this.palette.bg>>8)&0xff)/255*0.12+0.02, b: (this.palette.bg&0xff)/255*0.12+0.02, duration: 0.9 });
    }
    exit(){ gsap.to(this.key, { intensity: 0, duration:0.9 }); if(this.particleRig && this.particleRig.material && this.particleRig.material.uniforms) gsap.to(this.particleRig.material.uniforms.uOpacity, { value: 0.0, duration: 0.9 }); }
    update(dt, elapsed, cursorPoint, cursorIntensity){
      if(this.particleRig && this.particleRig.material && this.particleRig.material.uniforms){
        this.particleRig.material.uniforms.uTime.value = elapsed;
      }
      if(this.motionEnabled) this.porcelain.rotation.y += dt * (0.05 + (this.id * 0.02));
      // gentle restore
      this.meshCache.forEach(m=>{ m.material.roughness = THREE.MathUtils.lerp(m.material.roughness, m.material.userData?.baseRoughness||0.06, 0.03); m.material.envMapIntensity = THREE.MathUtils.lerp(m.material.envMapIntensity || (m.material.userData?.baseEnv||1.2), m.material.userData?.baseEnv||1.2, 0.03); });
    }
    toggleMotion(flag){ this.motionEnabled = flag; }
  }

  // ---------- procedural porcelain makers (v7) ----------
  function makeVesselA(){ const pts=[]; for(let i=0;i<20;i++){ const t=i/19; pts.push(new THREE.Vector2(0.6 + Math.sin(t*Math.PI)*0.8*(0.5+0.5*t), -1 + t*2.2)); } const g=new THREE.LatheGeometry(pts,128); const m=new THREE.Mesh(g, new THREE.MeshPhysicalMaterial({ color:0xf7f8fb, roughness:0.06, clearcoat:1.0, envMap:scene.environment })); m.castShadow=m.receiveShadow=true; return m; }
  function makePlateB(){ const ring=new THREE.RingGeometry(0.5,2.0,128); const bowl=new THREE.SphereGeometry(2.2,128,128,0,Math.PI*2,0,Math.PI/2); bowl.scale(1,0.38,1); const mat=new THREE.MeshPhysicalMaterial({ color:0xeaf6ff, roughness:0.03, clearcoat:1.0, envMap:scene.environment }); const g=new THREE.Group(); const rim=new THREE.Mesh(ring, mat.clone()); rim.rotation.x=-Math.PI/2; rim.position.y=0.01; const center=new THREE.Mesh(bowl, mat.clone()); center.position.y=0.02; center.castShadow=true; rim.receiveShadow=true; g.add(center,rim); return g; }
  function makeMiniSculptC(){ const geo=new THREE.TorusKnotGeometry(0.9,0.25,256,32,2,3); geo.rotateX(Math.PI*0.1); const m=new THREE.Mesh(geo,new THREE.MeshPhysicalMaterial({ color:0xffefef, roughness:0.08, clearcoat:1.0, envMap:scene.environment })); m.castShadow=m.receiveShadow=true; return m; }
  function makeTallCylinderD(){ const geo=new THREE.CylinderGeometry(0.8,0.8,3.6,64,1,true); const m=new THREE.Mesh(geo,new THREE.MeshPhysicalMaterial({ color:0xfffffb, roughness:0.06, clearcoat:1.0, envMap:scene.environment })); m.castShadow=m.receiveShadow=true; return m; }
  function makeBowlE(){ const geo=new THREE.SphereGeometry(1.8,128,128,0,Math.PI*2,0,Math.PI/1.7); geo.scale(1,0.7,1); const m=new THREE.Mesh(geo,new THREE.MeshPhysicalMaterial({ color:0xe8f2ff, roughness:0.02, clearcoat:0.9, envMap:scene.environment })); m.castShadow=m.receiveShadow=true; return m; }

  // ---------- scene definitions ----------
  function railPoints(base,target){ const r=[]; for(let i=0;i<4;i++){ const j=(i-1.5)*0.5; r.push({ position: base.clone().add(new THREE.Vector3(j,i*0.08,-j)), target: target.clone().add(new THREE.Vector3(0,i*0.04,0)) }); } return r; }
  const defs = [
    { id:0, name:'Dawn Vessel', palette:{ bg:0x19070a, key:0xffe6c8, grade:new THREE.Vector3(1.06,0.95,0.9) }, make:makeVesselA, rail:railPoints(new THREE.Vector3(6,3.5,6), new THREE.Vector3(0,1.1,0)), texture:texBokeh },
    { id:1, name:'Calm Mirror', palette:{ bg:0x081224, key:0xbfe8ff, grade:new THREE.Vector3(0.95,1.02,1.05) }, make:makePlateB, rail:railPoints(new THREE.Vector3(5.5,2.8,5.8), new THREE.Vector3(0,0.85,0)), texture:texBokeh },
    { id:2, name:'Whim', palette:{ bg:0x12040a, key:0xffefe9, grade:new THREE.Vector3(1.06,0.96,1.05) }, make:makeMiniSculptC, rail:railPoints(new THREE.Vector3(7,3.4,7), new THREE.Vector3(0,0.8,0)), texture:texPixel },
    { id:3, name:'Echo Column', palette:{ bg:0x071011, key:0xfffff6, grade:new THREE.Vector3(1.0,0.98,1.05) }, make:makeTallCylinderD, rail:railPoints(new THREE.Vector3(6.2,3.8,6.2), new THREE.Vector3(0,1.4,0)), texture:texGrid },
    { id:4, name:'Night Bloom', palette:{ bg:0x05051a, key:0xe6f0ff, grade:new THREE.Vector3(0.92,0.98,1.08) }, make:makeBowlE, rail:railPoints(new THREE.Vector3(7.5,3.6,7.8), new THREE.Vector3(0,0.9,0)), texture:texPetal }
  ];

  const scenes = defs.map(d => {
    const node = new SceneNode({ id:d.id, name:d.name, palette:d.palette, make:d.make, rail:d.rail, chapters:4, texture:d.texture });
    node.id = d.id;
    return node;
  });

  // add first
  let currentIndex = 0, currentChapter = 0;
  scene.add(scenes[0].group);
  scenes[0].enter(0);
  document.getElementById('sceneLabel').textContent = `Scene 1 / 5 — ${scenes[0].name}`;

  // ---------- central apply state ----------
  function applySceneState(i, chapter){
    currentIndex = i;
    currentChapter = chapter;
    const node = scenes[i];
    gradePassMaterialSet(node.palette.grade || new THREE.Vector3(1,1,1), 0.34);
    if(node.particleRig && node.particleRig.material && node.particleRig.material.uniforms){
      node.particleRig.material.uniforms.uStage.value = chapter;
      node.particleRig.material.uniforms.uFlow.value = node.id;
      node.particleRig.material.uniforms.uOpacity.value = 0.35 + 0.45 * (chapter / Math.max(1, node.chapters - 1));
    }
    const rail = node.rail[chapter] || node.rail[0];
    if(rail){
      gsap.to(camera.position, { x: rail.position.x, y: rail.position.y, z: rail.position.z, duration: 0.95, ease:'expo.inOut', onUpdate: ()=>controls.update() });
      gsap.to(controls.target, { x: rail.target.x, y: rail.target.y, z: rail.target.z, duration: 0.95, ease:'expo.inOut', onUpdate: ()=>controls.update() });
    }
    node.meshCache.forEach(m => { m.material.envMapIntensity = Math.min(1.8, 1.0 + chapter * 0.28); });
    gsap.to(disc.material.color, { r: ((node.palette.bg>>16)&0xff)/255*0.12 + 0.02, g: ((node.palette.bg>>8)&0xff)/255*0.12 + 0.02, b: (node.palette.bg&0xff)/255*0.12 + 0.02, duration: 0.9 });
    if(chapter >= node.chapters - 1) prefetchNext(i);
    document.getElementById('sceneLabel').textContent = `Scene ${i+1} / 5 — ${node.name}`;
  }

  function gradePassMaterialSet(gradeVec, vign){
    // set .value correctly
    gradePass.material.uniforms.uGrade.value.copy(gradeVec);
    gradePass.material.uniforms.uVignette.value = vign;
  }

  function prefetchNext(i){
    const next = (i+1) % scenes.length;
    console.log('prefetch hook for', next);
  }

  // ---------- input handlers (scoped) ----------
  function isOverUI(e){ const el = document.elementFromPoint(e.clientX, e.clientY); return el && el.closest && el.closest('.panel'); }
  renderer.domElement.addEventListener('mousemove', (e)=>{ if(isOverUI(e)) return; const r=renderer.domElement.getBoundingClientRect(); mouse.x = ((e.clientX - r.left)/r.width)*2 - 1; mouse.y = -((e.clientY - r.top)/r.height)*2 + 1; lastInteraction = performance.now(); }, { passive:true });

  let wheelAcc = 0;
  renderer.domElement.addEventListener('wheel', (e)=>{ if(isOverUI(e)) return; e.preventDefault(); wheelAcc += e.deltaY; const step = wheelAcc > 160 ? 1 : (wheelAcc < -160 ? -1 : 0); if(step !== 0){ wheelAcc = 0; currentChapter = THREE.MathUtils.clamp(currentChapter + step, 0, scenes[currentIndex].chapters - 1); applySceneState(currentIndex, currentChapter); } // zoom smoothing
    const d = e.deltaY * 0.003; scrollTarget += d*6; scrollTarget = THREE.MathUtils.clamp(scrollTarget, controls.minDistance, controls.maxDistance); }, { passive:false });

  renderer.domElement.addEventListener('pointerdown', (e)=>{ if(isOverUI(e)) return; lastInteraction = performance.now(); const hit = computeHit(); if(hit && hit.object && scenes[currentIndex].meshCache.includes(hit.object)) spawnPulse(hit.point, 0xfff0d8, 100); }, { passive:true });

  window.addEventListener('keydown', (e)=>{ const active = document.activeElement; const typing = active && (active.tagName==='INPUT'||active.tagName==='TEXTAREA'||active.isContentEditable); if(!typing){ if(e.code==='ArrowRight'){ e.preventDefault(); gotoScene((currentIndex+1)%scenes.length); } if(e.code==='ArrowLeft'){ e.preventDefault(); gotoScene((currentIndex-1+scenes.length)%scenes.length); } if(e.code==='Space'){ e.preventDefault(); toggleGlobalMotion(); } } }, { passive:false });

  document.getElementById('fsBtn').addEventListener('click', async ()=>{
    if(!document.fullscreenElement){ await container.requestFullscreen().catch(()=>{}); resize(); } else { await document.exitFullscreen().catch(()=>{}); resize(); }
  });

  // ---------- computeHit (ints, ints2) and idle skip ----------
  function computeHit(){
    if(performance.now() - lastInteraction > 900) return null;
    raycaster.setFromCamera(mouse, camera);
    const node = scenes[currentIndex];
    if(node && node.meshCache.length){
      const ints = raycaster.intersectObjects(node.meshCache, true);
      if(ints && ints.length) return ints[0];
    }
    const ints2 = raycaster.intersectObject(interactPlane);
    if(ints2 && ints2.length) return ints2[0];
    return null;
  }

  // ---------- scene switching ----------
  function prepareFade(g){ g.traverse(m=>{ if(m.isMesh && m.material && !m.material.__pf){ m.material.__pf=true; m.material.__origTransparent = m.material.transparent; m.material.__origOpacity = m.material.opacity !== undefined ? m.material.opacity : 1.0; m.material.transparent = true; } }); }
  function fadeGroup(g,to,d=0.9){ g.traverse(m=>{ if(m.isMesh && m.material && m.material.__pf) gsap.to(m.material,{opacity:to,duration:d,ease:'power2.inOut'}); }); }
  function restoreFade(g){ g.traverse(m=>{ if(m.isMesh && m.material && m.material.__pf){ gsap.to(m.material,{opacity:m.material.__origOpacity||1.0,duration:0.02,onComplete:()=>{ m.material.transparent = m.material.__origTransparent; delete m.material.__origTransparent; delete m.material.__origOpacity; delete m.material.__pf; }}); } }); }

  let transitioning=false;
  function gotoScene(i){
    if(transitioning || i===currentIndex) return;
    transitioning=true;
    const from = scenes[currentIndex], to = scenes[i];
    if(!to.group.parent) scene.add(to.group);
    prepareFade(from.group); prepareFade(to.group);
    to.group.traverse(m=>{ if(m.isMesh && m.material) m.material.opacity = 0.0; });
    controls.enabled = false; gsap.to(disc.material, { opacity: 0.6, duration: 0.6 });
    const tl = gsap.timeline({ onComplete: ()=>{ scene.remove(from.group); restoreFade(from.group); restoreFade(to.group); currentIndex = i; updateLabel(); transitioning=false; controls.enabled = true; gsap.to(disc.material,{opacity:1.0,duration:0.6}); }});
    const rail = to.rail[0] || { position: camera.position.clone(), target: controls.target.clone() };
    tl.to(camera.position, { x: rail.position.x, y: rail.position.y, z: rail.position.z, duration:1.05, ease:'expo.inOut', onUpdate: ()=>controls.update() }, 0);
    tl.to(controls.target, { x: rail.target.x, y: rail.target.y, z: rail.target.z, duration:1.05, ease:'expo.inOut', onUpdate: ()=>controls.update() }, 0);
    tl.add(()=>from.exit(), 0.02); tl.add(()=>to.enter(0), 0.02);
    tl.add(()=>fadeGroup(from.group,0.0,0.9),0.04); tl.add(()=>fadeGroup(to.group,1.0,1.0),0.06);
  }

  // ---------- performance governor ----------
  const perf = { samples: [], lastAdjust: performance.now() };
  function perfTick(dt){
    perf.samples.push(dt);
    if(perf.samples.length>60) perf.samples.shift();
    const avg = perf.samples.reduce((a,b)=>a+b,0)/perf.samples.length;
    const fps = 1/avg;
    const now = performance.now();
    if(now - perf.lastAdjust > 1000){
      perf.lastAdjust = now;
      if(fps < 45){
        bloomPass.strength = Math.max(0.25, bloomPass.strength * 0.88);
        bokehPass.enabled = false;
        scenes.forEach(s => { if(s.particleRig && s.particleRig.geometry) s.particleRig.geometry.instanceCount = Math.floor(1200*0.6); });
      } else {
        bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, 0.55, 0.06);
        scenes.forEach(s => { if(s.particleRig && s.particleRig.geometry) s.particleRig.geometry.instanceCount = 1200; });
        bokehPass.enabled = document.getElementById('toggleDOF').checked;
      }
    }
  }

  // ---------- resize (DPR-aware SMAA + composer pixel ratio) ----------
  function resize(){
    const w = WIDTH(), h = HEIGHT();
    camera.aspect = w/h; camera.updateProjectionMatrix();
    renderer.setSize(w,h);
    composer.setSize(w,h);
    composer.setPixelRatio(DPR);
    try{
      if(bokehPass && bokehPass.materialBokeh && bokehPass.materialBokeh.uniforms && ('aspect' in bokehPass.materialBokeh.uniforms)) bokehPass.materialBokeh.uniforms.aspect.value = camera.aspect;
      else if(bokehPass && bokehPass.uniforms){ bokehPass.uniforms['width'].value = w; bokehPass.uniforms['height'].value = h; }
      if(smaaPass) smaaPass.setSize(Math.floor(w*DPR), Math.floor(h*DPR));
    }catch(e){ console.warn('resize pass update failed', e); }
  }
  window.addEventListener('resize', resize);

  // ---------- animation ----------
  const clock = new THREE.Clock();
  let scrollTarget = camera.position.distanceTo(controls.target);
  function animate(){
    const dt = Math.min(0.05, clock.getDelta());
    const elapsed = clock.getElapsedTime();
    perfTick(dt);

    // smooth zoom
    const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
    const desiredDistance = THREE.MathUtils.lerp(camera.position.distanceTo(controls.target), scrollTarget, 0.06);
    const clampedDistance = THREE.MathUtils.clamp(desiredDistance, controls.minDistance, controls.maxDistance);
    const newCamPos = new THREE.Vector3().copy(camDir).multiplyScalar(-clampedDistance).add(controls.target);
    camera.position.lerp(newCamPos, 0.08);

    // hit test (skip when idle)
    let hit = null;
    if(performance.now() - lastInteraction <= 900){
      raycaster.setFromCamera(mouse, camera);
      const node = scenes[currentIndex];
      if(node && node.meshCache.length){
        const ints = raycaster.intersectObjects(node.meshCache, true);
        if(ints && ints.length) hit = ints[0];
      }
      if(!hit){
        const ints2 = raycaster.intersectObject(interactPlane);
        if(ints2 && ints2.length) hit = ints2[0];
      }
    }

    // cursor light clamp, scale by cam distance and normal alignment
    if(hit && hit.object && scenes[currentIndex].meshCache.includes(hit.object)){
      const N = hit.face.normal.clone().transformDirection(hit.object.matrixWorld);
      const V = camera.position.clone().sub(hit.point).normalize();
      const d = hit.distance;
      const align = Math.max(0, N.dot(V));
      const Iraw = (1 - Math.min(10, d)/10) * align;
      const I = THREE.MathUtils.clamp(Iraw, 0.04, 1.0);
      const camFactor = THREE.MathUtils.clamp(8.0 / Math.max(0.001, d), 0.0, 1.0);
      const intended = I * camFactor;
      cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, intended, 0.12);
      cursorLight.position.lerp(hit.point, 0.18);
      cursorBall.position.lerp(hit.point, 0.18);
      const targetScale = 0.3 + I * 1.4 * camFactor;
      glowSprite.scale.setScalar(THREE.MathUtils.lerp(glowSprite.scale.x, targetScale, 0.12));
      glowSprite.position.lerp(hit.point.clone().add(new THREE.Vector3().subVectors(camera.position, hit.point).setLength(0.06)), 0.18);
      glowSprite.material.opacity = THREE.MathUtils.lerp(glowSprite.material.opacity, 0.65 * I, 0.12);
    } else {
      cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, 0.0, 0.06);
      glowSprite.material.opacity = THREE.MathUtils.lerp(glowSprite.material.opacity, 0.0, 0.05);
    }

    // pulses update
    for(let i=activePulses.length-1;i>=0;i--){
      const p = activePulses[i]; p.userData.life -= dt * 0.8;
      const posAttr = p.geometry.attributes.position, velAttr = p.geometry.attributes.vel;
      for(let v=0; v<posAttr.count; v++){ posAttr.array[v*3]+=velAttr.array[v*3]*dt; posAttr.array[v*3+1]+=velAttr.array[v*3+1]*dt; posAttr.array[v*3+2]+=velAttr.array[v*3+2]*dt; velAttr.array[v*3+1]-=dt*0.9; }
      posAttr.needsUpdate=true; velAttr.needsUpdate=true; p.material.opacity = Math.max(0, p.userData.life);
      if(p.userData.life<=0){ const idx = activePulses.indexOf(p); if(idx!==-1) activePulses.splice(idx,1); if(p.parent) p.parent.remove(p); recyclePulse(p); }
    }

    // update current scene
    scenes[currentIndex].update(dt, elapsed, hit ? hit.point.clone() : null, 0);

    controls.update();
    composer.render();
    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  // ---------- helpers ----------
  function toggleGlobalMotion(){ scenes.forEach(s=>s.toggleMotion(!s.motionEnabled)); }
  window.__porcelain = { scenes, gotoScene, applySceneState, resize };

  // ensure initial resize
  resize();

  </script>
</body>
</html>
