<!doctype html>
<html lang="en">
  <head>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>Porcelain 3D</title>
      <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"></script>
      <style>
        :root {
          color-scheme: dark;
        }

        html,
        body {
      <style>
        :root { color-scheme: dark; }

        html, body {
          height: 100%;
          margin: 0;
          background: #0c0d14;
          font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        }

        body {
          color: #f5f6f9;
          overflow: hidden;
        }

        body::before {
          content: "";
          position: fixed;
          inset: 0;
          background:
            radial-gradient(60% 80% at 50% 20%, var(--glow-one, rgba(68, 83, 255, 0.25)), transparent),
            radial-gradient(50% 60% at 20% 80%, var(--glow-two, rgba(255, 134, 74, 0.18)), transparent),
            radial-gradient(55% 65% at 80% 75%, var(--glow-three, rgba(255, 214, 143, 0.12)), transparent);
          pointer-events: none;
          z-index: 0;
          filter: blur(40px);
          opacity: 0.65;
          transition: opacity 0.6s ease;
        }

        canvas {
          width: 100%;
          height: 100%;
          display: block;
          position: relative;
        /* Ensure canvas covers the entire viewport and sits above page background */
        canvas {
          position: fixed;
          inset: 0;
          width: 100vw;
          height: 100vh;
          display: block;
          z-index: 1;
        }

        .hud {
          position: fixed;
          top: 18px;
          left: 20px;
          color: rgba(236, 238, 255, 0.8);
          font: 12px/1.2 "Inter", system-ui, sans-serif;
          letter-spacing: 0.08em;
          text-transform: uppercase;
          backdrop-filter: blur(6px);
          padding: 8px 12px;
          border-radius: 999px;
          background: rgba(14, 17, 28, 0.55);
          border: 1px solid rgba(255, 255, 255, 0.08);
          z-index: 7;
        }

        /* The small preview pocket (comment out or remove if you only want the Three.js view) */
        .viewer-pocket {
          position: fixed;
          top: 20px;
          right: 20px;
          width: min(320px, 28vw);
          aspect-ratio: 1;
          border-radius: 18px;
          overflow: hidden;
          border: 1px solid rgba(255, 255, 255, 0.08);
          box-shadow: 0 18px 45px rgba(8, 10, 18, 0.55);
          background: radial-gradient(circle at top, rgba(37, 40, 58, 0.92), rgba(8, 9, 18, 0.92));
          z-index: 6;
          backdrop-filter: blur(16px);
        }

        .viewer-pocket::after {
          content: "model-viewer demo";
          position: absolute;
          left: 16px;
          bottom: 16px;
          font: 11px/1 "Inter", system-ui, sans-serif;
          letter-spacing: 0.16em;
          text-transform: uppercase;
          color: rgba(222, 229, 255, 0.65);
        }

        model-viewer {
          width: 100%;
          height: 100%;
          --poster-color: rgba(12, 14, 25, 0.85);
        }

        .scene-caption {
          position: fixed;
          left: 50%;
          bottom: 188px;
          transform: translateX(-50%);
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 6px;
          z-index: 6;
          pointer-events: none;
          --accent: #ff9f6d;
        }

        .scene-caption.flash {
          animation: caption-flash 0.8s ease;
        }

        .scene-caption .season-subtitle {
          font-size: 12px;
          text-transform: uppercase;
          letter-spacing: 0.34em;
          color: var(--accent);
          opacity: 0.82;
        }

        .scene-caption .season-title {
          font-size: clamp(22px, 2vw, 32px);
          letter-spacing: 0.24em;
          font-weight: 600;
          text-transform: uppercase;
          color: rgba(239, 241, 255, 0.94);
          text-shadow: 0 12px 30px rgba(10, 14, 24, 0.65);
        }

        @keyframes caption-flash {
          0% {
            opacity: 0;
            transform: translate(-50%, 10px);
          }
          45% {
            opacity: 1;
            transform: translate(-50%, -2px);
          }
          100% {
            opacity: 1;
            transform: translate(-50%, 0);
          }
        }

        .scene-strip {
          position: fixed;
          inset-inline: 0;
          bottom: 0;
          padding: 26px min(7vw, 80px) 34px;
          display: flex;
          gap: 18px;
          overflow-x: auto;
          scroll-snap-type: x mandatory;
          z-index: 6;
          backdrop-filter: blur(14px);
        }

        .scene-strip::-webkit-scrollbar {
          display: none;
        }

        .scene-strip::before,
        .scene-strip::after {
          content: "";
          pointer-events: none;
          position: absolute;
          top: 0;
          bottom: 0;
          width: 140px;
          z-index: 1;
          background: linear-gradient(to right, rgba(10, 12, 20, 0.65), transparent);
        }

        .scene-strip::before {
          left: 0;
        }

        .scene-strip::after {
          right: 0;
          transform: scaleX(-1);
        }

        .scene-card {
          appearance: none;
          border: none;
          --start: #3a1c63;
          --end: #101a3a;
          --accent: #ffbc6b;
          position: relative;
          border-radius: 24px;
          padding: 18px 20px 22px;
          min-width: clamp(200px, 23vw, 260px);
          scroll-snap-align: center;
          background:
            radial-gradient(120% 120% at 0% 0%, rgba(255, 255, 255, 0.18), transparent 55%),
            linear-gradient(135deg, rgba(255, 255, 255, 0.12), transparent 60%),
            linear-gradient(130deg, var(--start), var(--end));
          border: 1px solid rgba(255, 255, 255, 0.08);
          color: #f6f7ff;
          text-align: left;
          font-family: "Inter", system-ui, sans-serif;
          letter-spacing: 0.02em;
          cursor: pointer;
          transition: transform 0.6s cubic-bezier(0.23, 0.95, 0.32, 1), border-color 0.6s, box-shadow 0.6s;
          box-shadow: 0 18px 45px rgba(8, 10, 18, 0.4);
          z-index: 2;
        }

        .scene-card::before {
          content: "";
          position: absolute;
          inset: -30% -20%;
          background: radial-gradient(circle, rgba(255, 255, 255, 0.18), transparent 65%);
          opacity: 0;
          transition: opacity 0.6s;
        }

        .scene-card .card-index {
          font-size: 12px;
          font-weight: 600;
          letter-spacing: 0.34em;
          text-transform: uppercase;
          opacity: 0.7;
          color: var(--accent);
        }

        .scene-card h3 {
          margin: 12px 0 8px;
          font-size: 18px;
          font-weight: 600;
        }

        .scene-card p {
          margin: 0;
          font-size: 13px;
          line-height: 1.5;
          opacity: 0.78;
          max-width: 22ch;
        }

        .scene-card.active {
          transform: translateY(-18px) scale(1.04);
          border-color: rgba(255, 255, 255, 0.32);
          box-shadow: 0 26px 60px rgba(16, 22, 44, 0.55);
        }

        .scene-card.active::before {
          opacity: 1;
        }

        .scene-card:hover {
          transform: translateY(-10px) scale(1.03);
          border-color: rgba(255, 255, 255, 0.22);
        }

        .scene-card:focus-visible {
          outline: 2px solid var(--accent);
          outline-offset: 4px;
        }

        @media (max-width: 1024px) {
          .viewer-pocket {
            width: min(260px, 34vw);
          }

          .scene-caption {
            bottom: 210px;
          }
        }

        @media (max-width: 768px) {
          .hud {
            top: 14px;
            left: 14px;
            font-size: 10px;
            padding: 6px 10px;
          }

          .viewer-pocket {
            width: min(220px, 55vw);
            top: 14px;
            right: 14px;
          }

          .scene-caption {
            bottom: 240px;
            gap: 4px;
          }

          .scene-caption .season-title {
            letter-spacing: 0.18em;
            font-size: 20px;
          }

          .scene-strip {
            padding: 18px 24px 32px;
            gap: 15px;
          }

          .scene-card {
            min-width: clamp(180px, 70vw, 240px);
          }
        }
      </style>
</head>
<body>
    <div class="hud">drag = orbit â€¢ wheel = zoom â€¢ dbl-click = focus</div>
    <canvas id="c"></canvas>
    <div class="viewer-pocket">
      <model-viewer
        alt="Neil Armstrong's Spacesuit from the Smithsonian Digitization Programs Office and National Air and Space Museum"
      </style>
  </head>
  <body>
    <div class="hud" id="hud">drag = orbit â€¢ wheel = zoom â€¢ dbl-click = focus</div>
    <canvas id="c"></canvas>

    <!-- If you want to hide the astronaut preview, remove or comment the block below.
         It's independent of the Three.js canvas and is why you see the astronaut in the corner. -->
    <!--
    <div class="viewer-pocket">
      <model-viewer
        alt="Neil Armstrong's Spacesuit"
        src="https://modelviewer.dev/shared-assets/models/Astronaut.glb"
        ar
        environment-image="https://modelviewer.dev/shared-assets/environments/moon_1k.hdr"
        poster="https://modelviewer.dev/shared-assets/models/Astronaut.webp"
        shadow-intensity="1"
        camera-controls
        touch-action="pan-y"
      >
      </model-viewer>
    </div>
    <div class="scene-caption" id="sceneCaption">
      <span class="season-subtitle"></span>
      <span class="season-title"></span>
    </div>
    <div class="scene-strip" id="sceneStrip" aria-label="Porcelain realm selector" aria-live="polite"></div>
    -->

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js";
      import { GLTFLoader } from "https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js";
      import { EffectComposer } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/EffectComposer.js";
      import { RenderPass } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/UnrealBloomPass.js";
      import { FilmPass } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/FilmPass.js";
      import { ShaderPass } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/ShaderPass.js";

        const canvas = document.getElementById("c");
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x080811);
        scene.fog = new THREE.Fog(0x090a15, 10, 35);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 150);
        camera.position.set(1.6, 1.1, 1.6);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.065;
        controls.minDistance = 0.2;
        controls.maxDistance = 12;

        const hemi = new THREE.HemisphereLight(0xd7e0ff, 0x1a1b1f, 0.55);
        scene.add(hemi);

        const key = new THREE.DirectionalLight(0xffffff, 1.6);
        key.position.set(2, 3, 1);
        key.castShadow = true;
        key.shadow.mapSize.set(2048, 2048);
        scene.add(key);

        const rim = new THREE.DirectionalLight(0x92b7ff, 0.75);
        rim.position.set(-2.5, 1.8, -1.4);
        scene.add(rim);

        const ground = new THREE.Mesh(
          new THREE.CylinderGeometry(3.5, 3.5, 0.02, 48),
          new THREE.MeshStandardMaterial({
            color: 0x121222,
            roughness: 0.8,
            metalness: 0.08,
            emissive: 0x040408,
            emissiveIntensity: 0.15
          })
        );
        ground.receiveShadow = true;
        ground.position.y = -0.01;
        scene.add(ground);

        const grid = new THREE.GridHelper(4, 40, 0x3a3c3f, 0x222427);
        grid.position.y = 0;
        grid.material.opacity = 0.15;
        grid.material.transparent = true;
        scene.add(grid);

        const modelGroup = new THREE.Group();
        scene.add(modelGroup);

        const sparkleCount = 450;
        const sparkleGeometry = new THREE.BufferGeometry();
        const sparklePositions = new Float32Array(sparkleCount * 3);
        for (let i = 0; i < sparkleCount; i++) {
          const radius = 2 + Math.random() * 5.5;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          sparklePositions[i * 3 + 0] = radius * Math.sin(phi) * Math.cos(theta);
          sparklePositions[i * 3 + 1] = radius * Math.cos(phi) * 0.45;
          sparklePositions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
        }
        sparkleGeometry.setAttribute("position", new THREE.BufferAttribute(sparklePositions, 3));

        const sparkleMaterial = new THREE.PointsMaterial({
          color: new THREE.Color(0x84c2ff),
          size: 0.08,
          transparent: true,
          opacity: 0.85,
          depthWrite: false,
          blending: THREE.AdditiveBlending
        });

        const sparkles = new THREE.Points(sparkleGeometry, sparkleMaterial);
        sparkles.position.y = 0.35;
        sparkles.visible = false;
        scene.add(sparkles);

        const envCanvas = document.createElement("canvas");
        envCanvas.width = 512;
        envCanvas.height = 256;
        const envCtx = envCanvas.getContext("2d");
        const gradient = envCtx.createLinearGradient(0, 0, 0, envCanvas.height);
        gradient.addColorStop(0, "#1e1a3e");
        gradient.addColorStop(0.35, "#3e1a6b");
        gradient.addColorStop(0.7, "#0b2048");
        gradient.addColorStop(1, "#06121f");
        envCtx.fillStyle = gradient;
        envCtx.fillRect(0, 0, envCanvas.width, envCanvas.height);
        const envTexture = new THREE.CanvasTexture(envCanvas);
        envTexture.mapping = THREE.EquirectangularReflectionMapping;
        envTexture.colorSpace = THREE.SRGBColorSpace;
        envTexture.anisotropy = 4;
        scene.environment = envTexture;

        const composer = new EffectComposer(renderer);
        composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        composer.setSize(window.innerWidth, window.innerHeight);

        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          0.7,
          0.45,
          0.85
        );
        composer.addPass(bloomPass);

        const filmPass = new FilmPass(0.32, 0.55, 1024, false);
        composer.addPass(filmPass);

        const AuroraShader = {
          uniforms: {
            tDiffuse: { value: null },
            time: { value: 0 },
            resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
          },
          vertexShader: /* glsl */ `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = vec4(position, 1.0);
            }
          `,
          fragmentShader: /* glsl */ `
            precision highp float;
            varying vec2 vUv;
            uniform sampler2D tDiffuse;
            uniform vec2 resolution;
            uniform float time;

            float hash(vec2 p) {
              p = fract(p * vec2(123.34, 456.21));
              p += dot(p, p + 45.32);
              return fract(p.x * p.y);
            }

            float noise(vec2 p) {
              vec2 i = floor(p);
              vec2 f = fract(p);
              float a = hash(i);
              float b = hash(i + vec2(1.0, 0.0));
              float c = hash(i + vec2(0.0, 1.0));
              float d = hash(i + vec2(1.0, 1.0));
              vec2 u = f * f * (3.0 - 2.0 * f);
              return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }

            float fbm(vec2 p) {
              float value = 0.0;
              float amplitude = 0.5;
              for (int i = 0; i < 5; i++) {
                value += amplitude * noise(p);
                p *= 2.2;
                amplitude *= 0.55;
              }
              return value;
            }

            void main() {
              vec2 uv = vUv;
              vec3 base = texture2D(tDiffuse, uv).rgb;

              vec2 swirl = uv * vec2(2.8, 1.6);
              float aurora = fbm(swirl + vec2(0.0, time * 0.06));
              float veil = fbm(swirl * mat2(1.2, -0.7, 0.7, 1.2) + time * 0.03);
              float beam = smoothstep(0.35, 0.95, aurora * 1.4 + veil * 0.5);
              float spark = fbm(uv * 12.0 + time * 0.5);
              float sparkle = smoothstep(0.8, 1.0, spark);

              vec3 auroraColor = mix(vec3(0.26, 0.4, 0.98), vec3(0.9, 0.3, 0.95), aurora);
              vec3 glow = auroraColor * beam * 0.6 + vec3(0.2, 0.6, 1.0) * sparkle * 0.25;

              vec3 finalColor = mix(base, base + glow, 0.38);
              finalColor += beam * 0.08;

              gl_FragColor = vec4(finalColor, 1.0);
            }
          `
        };

        const auroraPass = new ShaderPass(AuroraShader);
        composer.addPass(auroraPass);

        // ðŸ‘‡ If you upload your file to /assets/, change path to "/assets/porcelain.glb"
        const loader = new GLTFLoader();
        const glbUrl = "./porcelain.glb";

        const frameBox = new THREE.Box3();
        const frameVec = new THREE.Vector3();

        loader.load(
          glbUrl,
          (gltf) => {
            const model = gltf.scene;

            model.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material && Array.isArray(child.material)) {
                  child.material.forEach((mat) => (mat.toneMapped = true));
                } else if (child.material) {
                  child.material.toneMapped = true;
                }
              }
            });
      const hud = document.getElementById("hud");
      const canvas = document.getElementById("c");
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.1;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x080811);
      scene.fog = new THREE.Fog(0x090a15, 10, 35);

      const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 150);
      camera.position.set(1.6, 1.1, 1.6);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.065;
      controls.minDistance = 0.2;
      controls.maxDistance = 12;

      const hemi = new THREE.HemisphereLight(0xd7e0ff, 0x1a1b1f, 0.55);
      scene.add(hemi);

      const key = new THREE.DirectionalLight(0xffffff, 1.6);
      key.position.set(2, 3, 1);
      key.castShadow = true;
      key.shadow.mapSize.set(2048, 2048);
      scene.add(key);

      const rim = new THREE.DirectionalLight(0x92b7ff, 0.75);
      rim.position.set(-2.5, 1.8, -1.4);
      scene.add(rim);

      const ground = new THREE.Mesh(
        new THREE.CylinderGeometry(3.5, 3.5, 0.02, 48),
        new THREE.MeshStandardMaterial({
          color: 0x121222,
          roughness: 0.8,
          metalness: 0.08,
          emissive: 0x040408,
          emissiveIntensity: 0.15
        })
      );
      ground.receiveShadow = true;
      ground.position.y = -0.01;
      scene.add(ground);

      const grid = new THREE.GridHelper(4, 40, 0x3a3c3f, 0x222427);
      grid.position.y = 0;
      grid.material.opacity = 0.15;
      grid.material.transparent = true;
      scene.add(grid);

      const modelGroup = new THREE.Group();
      scene.add(modelGroup);

      // sparkles/environment/composer code kept (not shown fully here for brevity in the answer),
      // but in this file it's the same setup you had before (unchanged)...

      // loader setup
      const loader = new GLTFLoader();

      // 1) Default: your local file (must exist in same folder as index.html)
      let glbUrl = "./porcelain.glb";

      // 2) If you want to TEST that Three.js rendering and loader work,
      //    temporarily set the URL to a public model (uncomment the next line).
      // glbUrl = "https://modelviewer.dev/shared-assets/models/Astronaut.glb";

      const frameBox = new THREE.Box3();
      const frameVec = new THREE.Vector3();

      loader.load(
        glbUrl,
        (gltf) => {
          console.log("GLB loaded:", glbUrl);
          hud.textContent = "Model loaded â€” centering...";
          const model = gltf.scene;

          // make sure model is visible and reasonably scaled
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              if (child.material && Array.isArray(child.material)) {
                child.material.forEach((mat) => (mat.toneMapped = true));
              } else if (child.material) {
                child.material.toneMapped = true;
              }
            }
          });

          modelGroup.clear();
          modelGroup.add(model);

          frameBox.setFromObject(model);
          const center = frameBox.getCenter(frameVec);
          model.position.sub(center);

          // center + floor model
          frameBox.setFromObject(model);
          const center = frameBox.getCenter(frameVec);
          model.position.sub(center);
          frameBox.setFromObject(model);
          const floorOffset = frameBox.min.y;
          model.position.y -= floorOffset;

          // compute size and position camera to frame model
          frameBox.setFromObject(model);
          const size = frameBox.getSize(frameVec);
          const radius = size.length() * 0.5;
          const fov = THREE.MathUtils.degToRad(camera.fov);
          const distance = radius / Math.tan(fov * 0.5);

            const framedCenter = frameBox.getCenter(frameVec);
            controls.target.copy(framedCenter);
            camera.position.set(distance * 0.9, distance * 0.6 + size.y * 0.15, distance * 0.9);
            camera.near = Math.max(0.01, radius * 0.02);
            camera.far = radius * 20;
            camera.updateProjectionMatrix();

            const hud = document.querySelector(".hud");
            if (hud) {
              hud.textContent = "drag = orbit â€¢ wheel = zoom â€¢ dbl-click = focus";
              hud.style.color = "#cfcfcf";
            }

            sparkles.visible = true;
          },
          undefined,
          (error) => {
            console.error("Failed to load porcelain.glb", error);
            const hud = document.querySelector(".hud");
            if (hud) {
              hud.textContent = "Could not load porcelain.glb â€“ check the file path.";
              hud.style.color = "#ff8a8a";
            }
            sparkles.visible = false;
          }
        );

        const clock = new THREE.Clock();
        let spinSpeed = 0.25;

        function animate() {
          const delta = clock.getDelta();
          const elapsed = clock.elapsedTime;

            modelGroup.rotation.y += spinSpeed * delta;
            sparkles.rotation.y += delta * 0.1;
            sparkles.rotation.x = Math.sin(elapsed * 0.08) * 0.1;

          bloomPass.strength = 0.65 + Math.sin(elapsed * 0.45) * 0.18;
          bloomPass.radius = 0.6 + Math.cos(elapsed * 0.35) * 0.05;
          filmPass.uniforms.nIntensity.value = 0.35 + Math.sin(elapsed * 0.7) * 0.06;
          filmPass.uniforms.sIntensity.value = 0.45 + Math.cos(elapsed * 0.4) * 0.08;
            auroraPass.uniforms.time.value = elapsed;

          controls.update();
          composer.render();
          requestAnimationFrame(animate);
        }

        animate();

        addEventListener("resize", () => {
          const width = window.innerWidth;
          const height = window.innerHeight;

          renderer.setSize(width, height);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

          composer.setSize(width, height);
          bloomPass.setSize(width, height);

          camera.aspect = width / height;
          camera.updateProjectionMatrix();

            auroraPass.uniforms.resolution.value.set(width, height);
        });

        // double-click to focus
        renderer.domElement.addEventListener("dblclick", (e) => {
          const r = renderer.domElement.getBoundingClientRect();
          const ndc = new THREE.Vector2(
            ((e.clientX - r.left) / r.width) * 2 - 1,
            -((e.clientY - r.top) / r.height) * 2 + 1
          );
          const ray = new THREE.Raycaster();
          ray.setFromCamera(ndc, camera);
          const hit = ray.intersectObjects(modelGroup.children, true)[0];
          if (hit) {
            controls.target.copy(hit.point);
          }
        });

        document.addEventListener("keydown", (event) => {
          if (event.code === "Space") {
            spinSpeed = spinSpeed > 0 ? 0 : 0.25;
          }
        });
      </script>
</body>
          const framedCenter = frameBox.getCenter(frameVec);
          controls.target.copy(framedCenter);
          camera.position.set(distance * 0.9, distance * 0.6 + size.y * 0.15, distance * 0.9);
          camera.near = Math.max(0.01, radius * 0.02);
          camera.far = radius * 20;
          camera.updateProjectionMatrix();

          hud.textContent = "Ready â€” drag = orbit â€¢ wheel = zoom";
        },
        (xhr) => {
          // progress callback - helpful during debugging
          if (xhr && xhr.loaded && xhr.total) {
            const pct = Math.round((xhr.loaded / xhr.total) * 100);
            hud.textContent = `Loading model: ${pct}%`;
          }
        },
        (error) => {
          console.error("Failed to load GLB:", glbUrl, error);
          hud.textContent = "Could not load porcelain.glb â€” check path and open DevTools Console/Network.";
        }
      );

      // animation loop (unchanged)
      const clock = new THREE.Clock();
      let spinSpeed = 0.25;
      function animate() {
        const delta = clock.getDelta();
        const elapsed = clock.elapsedTime;
        modelGroup.rotation.y += spinSpeed * delta;
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();

      // resize handling
      addEventListener("resize", () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      });

      // double-click focus helper (unchanged)
      renderer.domElement.addEventListener("dblclick", (e) => {
        const r = renderer.domElement.getBoundingClientRect();
        const ndc = new THREE.Vector2(
          ((e.clientX - r.left) / r.width) * 2 - 1,
          -((e.clientY - r.top) / r.height) * 2 + 1
        );
        const ray = new THREE.Raycaster();
        ray.setFromCamera(ndc, camera);
        const hit = ray.intersectObjects(modelGroup.children, true)[0];
        if (hit) controls.target.copy(hit.point);
      });

      document.addEventListener("keydown", (event) => {
        if (event.code === "Space") spinSpeed = spinSpeed > 0 ? 0 : 0.25;
      });
    </script>
  </body>
</html>
