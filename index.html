<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Porcelain Transcendence — Five Scenes</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body,#container{height:100%;width:100%}
    body{background:#000;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#fff;overflow:hidden}
    #container{position:fixed;inset:0}
    canvas{display:block}
    .ui {
      position: absolute; z-index: 60; pointer-events: none; inset: 0;
    }
    .panel {
      pointer-events: auto;
      position: absolute;
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,0.05);
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
    }
    .top-left{left:16px;top:16px}
    .bottom-left{left:16px;bottom:16px}
    .top-right{right:16px;top:16px;text-align:right}
    .scene-indicator{font-weight:600;opacity:0.95}
    .controls small{opacity:0.8;display:block;margin-top:6px}
    .hint{opacity:0.75;font-size:12px;margin-top:6px}
  </style>
</head>
<body>
  <div id="container"></div>

  <div class="ui">
    <div class="panel top-left">
      <div class="scene-indicator" id="sceneLabel">Scene 1 / 5 — Dawn Vessel</div>
      <div class="hint">← → : Change Scene • SPACE : toggle motion • Click : reactive pulses</div>
    </div>

    <div class="panel top-right" id="toggles" style="text-align:right">
      <label><input id="toggleBloom" type="checkbox" checked> Bloom</label><br>
      <label><input id="toggleDOF" type="checkbox" checked> DOF</label><br>
      <label><input id="toggleParticles" type="checkbox" checked> Particles</label>
    </div>

    <div class="panel bottom-left controls">
      <div>DRAG: Orbit • SCROLL: Smooth Zoom</div>
      <small>Move your mouse to let the cursor light "scan" the porcelain</small>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
    }
  }
  </script>

  <!-- GSAP (used for transitions) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
  import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';

  // ------------------------------------------------------------
  // Core renderer, camera, composer
  // ------------------------------------------------------------
  const container = document.getElementById('container');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  // STEP 4 — exponential fog
  scene.fog = new THREE.FogExp2(0x000010, 0.035);

  const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.05, 2000);
  camera.position.set(8, 4.5, 9);

  const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  // STEP 4 — tone mapping exposure target
  renderer.toneMappingExposure = 0.9;
  renderer.physicallyCorrectLights = true;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  // Controls
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.minDistance = 1.6;
  controls.maxDistance = 40;
  controls.maxPolarAngle = Math.PI * 0.495;

  // Composer & passes
  const composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);

  // STEP 1 — Adjusted UnrealBloomPass according to spec
  const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.55, 0.6, 0.85);
  composer.addPass(bloomPass);

  const bokehPass = new BokehPass(scene, camera, {
    focus: 20.0,
    aperture: 0.0009,
    maxblur: 0.01,
    width: innerWidth,
    height: innerHeight
  });
  composer.addPass(bokehPass);

  const filmPass = new FilmPass(0.0, 0.0, 0, false); // kept optional, disabled by default
  composer.addPass(filmPass);

  // PMREM generator for environment (will accept HDR later)
  let pmrem = new THREE.PMREMGenerator(renderer);
  pmrem.compileEquirectangularShader();

  // small placeholder environment for consistent reflections (kept until HDR loads)
  const env = new THREE.CubeTextureLoader().load([
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=='
  ], () => {
    scene.environment = pmrem.fromCubemap(env).texture;
  });

  // STEP 4 — HDRI loader for better reflections (non-blocking)
  const rgbeLoader = new RGBELoader();
  rgbeLoader.setDataType(THREE.UnsignedByteType); // keep memory reasonable
  rgbeLoader.load('textures/studio_small_04_1k.hdr', (hdrTex) => {
    hdrTex.mapping = THREE.EquirectangularReflectionMapping;
    // create PMREM from equirect
    const envRT = pmrem.fromEquirectangular(hdrTex).texture;
    scene.environment = envRT;
    // dispose HDR source and old pmrem resources
    hdrTex.dispose && hdrTex.dispose();
    try { pmrem.dispose(); } catch (e) { /* ignore */ }
    // create a fresh pmrem reference for future replacements if needed
    pmrem = new THREE.PMREMGenerator(renderer);
  }, undefined, (err) => {
    console.warn('HDR load failed (this is optional):', err);
  });

  // ------------------------------------------------------------
  // Shared environment: ground, subtle disc, shadow catcher
  // ------------------------------------------------------------
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(400, 400),
    new THREE.MeshStandardMaterial({ color: 0x040405, roughness: 0.85 })
  );
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  const disc = new THREE.Mesh(new THREE.CircleGeometry(10, 64), new THREE.MeshStandardMaterial({ color:0x0e0e10, roughness:0.5, metalness:0.04 }));
  disc.rotation.x = -Math.PI/2;
  disc.position.y = 0.001;
  disc.receiveShadow = true;
  scene.add(disc);

  // Raycaster and interaction plane
  const interactPlane = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000), new THREE.MeshBasicMaterial({ visible:false }));
  interactPlane.rotation.x = -Math.PI/2;
  interactPlane.position.y = 0;
  scene.add(interactPlane);

  // ------------------------------------------------------------
  // Helper: generate soft radial gradient texture (STEP 2)
  // ------------------------------------------------------------
  function generateGlowTexture(size = 256, color = '#fff3d9') {
    const c = document.createElement('canvas');
    c.width = c.height = size;
    const ctx = c.getContext('2d');
    // create radial gradient center bright -> transparent edge
    const g = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
    g.addColorStop(0.0, color);
    g.addColorStop(0.25, color);
    g.addColorStop(0.6, 'rgba(255,243,217,0.45)');
    g.addColorStop(1.0, 'rgba(255,243,217,0.0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,size,size);
    const tx = new THREE.CanvasTexture(c);
    tx.needsUpdate = true;
    tx.minFilter = THREE.LinearFilter;
    tx.magFilter = THREE.LinearFilter;
    return tx;
  }

  // ------------------------------------------------------------
  // Cursor light (shared): follows pointer, affects materials
  // ------------------------------------------------------------
  const cursorLight = new THREE.PointLight(0xfff7ea, 0.0, 28, 2.2);
  // STEP 5 — Do not cast shadow from cursor
  cursorLight.castShadow = false;
  scene.add(cursorLight);

  const cursorBall = new THREE.Mesh(
    new THREE.SphereGeometry(0.06, 12, 12),
    new THREE.MeshBasicMaterial({ color: 0xfff3d9 })
  );
  cursorBall.renderOrder = 999;
  scene.add(cursorBall);

  // STEP 2 — replace old sprite with generated radial gradient
  const glowTexture = generateGlowTexture(512, '#fff3d9');
  const glowMaterial = new THREE.SpriteMaterial({
    map: glowTexture,
    color: 0xffffff,
    blending: THREE.AdditiveBlending,
    transparent: true,
    opacity: 0.65,
    depthWrite: false
  });
  const glow = new THREE.Sprite(glowMaterial);
  glow.scale.setScalar(0.8);
  scene.add(glow);

  // ------------------------------------------------------------
  // Simple particle pool to trigger reactive pulses on click
  // ------------------------------------------------------------
  const pulseGroup = new THREE.Group(); scene.add(pulseGroup);
  function spawnPulse(position, color = 0xffe6d1, count = 60) {
    const geom = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const velocities = new Float32Array(count * 3);
    for (let i=0;i<count;i++){
      const phi = Math.acos(2*Math.random()-1);
      const theta = Math.random()*Math.PI*2;
      const r = 0.02 + Math.random()*0.08;
      positions[i*3] = position.x + r*Math.sin(phi)*Math.cos(theta);
      positions[i*3+1] = position.y + r*Math.cos(phi);
      positions[i*3+2] = position.z + r*Math.sin(phi)*Math.sin(theta);
      velocities[i*3] = (Math.random()-0.5)*0.9;
      velocities[i*3+1] = Math.random()*1.2 + 0.2;
      velocities[i*3+2] = (Math.random()-0.5)*0.9;
    }
    geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
    geom.setAttribute('vel', new THREE.BufferAttribute(velocities,3));
    const mat = new THREE.PointsMaterial({ color, size: 0.05, transparent:true, opacity:1, depthWrite:false });
    const points = new THREE.Points(geom, mat);
    points.userData.life = 1.0;
    pulseGroup.add(points);
  }

  // ------------------------------------------------------------
  // Scene class (modular)
  // ------------------------------------------------------------
  class PorcelainScene {
    constructor(opts = {}) {
      this.name = opts.name || 'Untitled';
      this.palette = opts.palette || { bg:0x000000, key:0xffffff };
      this.group = new THREE.Group();
      this.porcelain = null;
      this.id = opts.id || 0;
      this.lights = [];
      this.particles = null;
      this.motionEnabled = true;
      this.make = opts.make; // function that returns mesh or group
      this.setup();
    }

    setup(){
      this.group.clear();
      // hemi
      this.hemi = new THREE.HemisphereLight(0xddddff, 0x0a0a0d, 0.45);
      this.group.add(this.hemi);

      // key light created per scene for tonal control
      this.key = new THREE.DirectionalLight(this.palette.key, 1.8);
      // STEP 5 — keep shadows only for key light and set smaller mapSize
      this.key.castShadow = true;
      this.key.shadow.mapSize.set(1024,1024);
      this.key.shadow.camera.near = 0.5;
      this.key.shadow.camera.far = 200;
      this.key.position.set(6,10,6);
      this.group.add(this.key);

      // fill and rim (do not cast shadows per STEP 5)
      this.fill = new THREE.DirectionalLight(0x8fb3ff, 0.45);
      this.fill.castShadow = false;
      this.fill.position.set(-6,5,-6);
      this.group.add(this.fill);

      this.rim = new THREE.DirectionalLight(0xffe6d0, 0.6);
      this.rim.castShadow = false;
      this.rim.position.set(0,6,-8);
      this.group.add(this.rim);

      // porcelain
      const p = this.make();
      this.porcelain = p;
      this.porcelain.traverse((c) => {
        if (c.isMesh) {
          c.castShadow = true;
          c.receiveShadow = true;
          // ensure physical material
          if (!(c.material && c.material.isMeshPhysicalMaterial)) {
            const base = (c.material && c.material.color) ? c.material.color.clone() : new THREE.Color(0xffffff);
            const newMat = new THREE.MeshPhysicalMaterial({
              color: base,
              roughness: 0.06,
              metalness: 0.0,
              clearcoat: 1.0,
              clearcoatRoughness: 0.04,
              envMap: scene.environment,
              envMapIntensity: 1.2,
              side: THREE.FrontSide
            });
            if (c.material && c.material.map) newMat.map = c.material.map;
            c.material = newMat;
            c.material.userData = { baseRoughness:newMat.roughness, baseEnv:newMat.envMapIntensity, baseClearcoat:newMat.clearcoat };
          }
        }
      });
      this.group.add(this.porcelain);

      // STEP 3 — particles: N=600, radius formula changed, opacity lowered to 0.6
      const halo = new THREE.BufferGeometry();
      const N = 600;
      const pos = new Float32Array(N*3);
      const col = new Float32Array(N*3);
      for (let i=0;i<N;i++){
        const i3 = i*3;
        // r = 12 + Math.random() * 8
        const r = 12 + Math.random()*8;
        const theta = Math.random()*Math.PI*2;
        const phi = Math.acos(2*Math.random()-1);
        pos[i3] = r*Math.sin(phi)*Math.cos(theta);
        pos[i3+1] = r*Math.cos(phi)*0.45;
        pos[i3+2] = r*Math.sin(phi)*Math.sin(theta);
        const c = new THREE.Color().setHSL(Math.random()*0.12 + (Math.random()*0.02+0.5), 0.7, 0.6);
        col[i3] = c.r; col[i3+1]=c.g; col[i3+2]=c.b;
      }
      halo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      halo.setAttribute('color', new THREE.BufferAttribute(col,3));
      const pts = new THREE.Points(halo, new THREE.PointsMaterial({ size:0.12, vertexColors:true, transparent:true, opacity:0.6, blending:THREE.AdditiveBlending, depthWrite:false }));
      pts.renderOrder = 1;
      this.particles = pts;
      this.group.add(pts);

      // bounding/scaling: center & scale to target height
      const box = new THREE.Box3().setFromObject(this.group);
      const center = box.getCenter(new THREE.Vector3());
      this.group.position.sub(center);
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x,size.y,size.z);
      const target = 4.6;
      const s = (maxDim>0) ? (target/maxDim) : 1;
      this.group.scale.setScalar(s);
      this.group.updateWorldMatrix(true,true);
      // align to ground (y=0)
      const box2 = new THREE.Box3().setFromObject(this.group);
      const minY = box2.min.y;
      this.group.position.y -= minY;
    }

    // called when switching to this scene
    enter(cameraTarget = { position: new THREE.Vector3(), target: new THREE.Vector3() }) {
      // subtly tint background
      gsap.to(scene.background, { r: ((this.palette.bg >> 16) & 0xff)/255, g: ((this.palette.bg >> 8) & 0xff)/255, b: (this.palette.bg & 0xff)/255, duration: 0.9 });
      // light intensities
      gsap.fromTo(this.key, { intensity: 0.0 }, { intensity: 1.8, duration: 0.9, ease:'power2.out' });
      gsap.fromTo(this.rim, { intensity:0.0 }, { intensity: 0.6, duration: 0.9, delay:0.1 });
      gsap.fromTo(this.fill, { intensity:0.0 }, { intensity:0.45, duration:0.9, delay:0.12 });

      // animate camera to scene-appropriate vantage
      if (cameraTarget.position) {
        gsap.to(camera.position, { x: cameraTarget.position.x, y: cameraTarget.position.y, z: cameraTarget.position.z, duration: 1.2, ease: 'expo.inOut' });
      }
      if (cameraTarget.target) {
        gsap.to(controls.target, { x: cameraTarget.target.x, y: cameraTarget.target.y, z: cameraTarget.target.z, duration: 1.2, ease: 'expo.inOut', onUpdate: () => controls.update() });
      }
      // gentle bloom change
      gsap.to(bloomPass, { strength: 0.55 + (this.id*0.06), duration: 0.9 });

      // subtle particle show
      gsap.fromTo(this.particles.material, { opacity: 0.0 }, { opacity: 0.6, duration: 1.2, ease: 'power2.out' });
    }

    exit() {
      // fade lights and particles
      gsap.to(this.key, { intensity: 0.0, duration: 0.9, ease:'power2.in' });
      gsap.to(this.fill, { intensity: 0.0, duration: 0.85 });
      gsap.to(this.rim, { intensity: 0.0, duration: 0.85 });
      gsap.to(this.particles.material, { opacity: 0.0, duration: 0.7 });
    }

    // per-frame update
    update(dt, elapsed, cursorWorld, cursorIntensity) {
      // mood particle motion
      this.particles.rotation.y += dt * (0.02 + this.id*0.01);
      this.particles.rotation.x = Math.sin(elapsed * (0.05 + this.id*0.02)) * 0.06;

      // porcelain motion
      if (this.motionEnabled) {
        this.porcelain.rotation.y += dt * (0.09 + this.id * 0.03);
        this.porcelain.position.y = Math.sin(elapsed * (0.4 + this.id*0.1)) * 0.03 * (1 + this.id*0.3);
      }

      // cursor-based material interaction: make highlights sharper where cursor is near
      if (cursorWorld && cursorIntensity > 0.02) {
        const meshes = [];
        this.porcelain.traverse((m) => { if (m.isMesh) meshes.push(m); });
        for (let m of meshes) {
          const w = new THREE.Vector3(); m.getWorldPosition(w);
          const d = Math.min(1.0, cursorWorld.distanceTo(w) / 4.5); // 0..1
          const effect = 1.0 - d;
          const origR = m.material.userData?.baseRoughness ?? 0.06;
          const origEnv = m.material.userData?.baseEnv ?? 1.2;
          const targetR = THREE.MathUtils.clamp(origR * (0.25 + (1 - effect)*1.0), 0.02, 1.0);
          const targetEnv = THREE.MathUtils.lerp(origEnv, origEnv + 2.2 * effect * cursorIntensity, 0.9);
          m.material.roughness = THREE.MathUtils.lerp(m.material.roughness, targetR, 0.18);
          m.material.envMapIntensity = THREE.MathUtils.lerp(m.material.envMapIntensity || origEnv, targetEnv, 0.18);
          m.material.clearcoat = THREE.MathUtils.lerp(m.material.clearcoat || 1.0, Math.min(1.0, (m.material.userData.baseClearcoat || 1.0) + 0.5 * effect), 0.18);
          m.material.needsUpdate = true;
        }
      } else {
        // gently restore
        this.porcelain.traverse((m) => {
          if (m.isMesh && m.material && m.material.userData) {
            m.material.roughness = THREE.MathUtils.lerp(m.material.roughness, m.material.userData.baseRoughness || 0.06, 0.04);
            m.material.envMapIntensity = THREE.MathUtils.lerp(m.material.envMapIntensity || (m.material.userData.baseEnv || 1.2), m.material.userData.baseEnv || 1.2, 0.03);
            m.material.clearcoat = THREE.MathUtils.lerp(m.material.clearcoat || (m.material.userData.baseClearcoat||1.0), m.material.userData.baseClearcoat||1.0, 0.03);
            m.material.needsUpdate = true;
          }
        });
      }
    }

    toggleMotion(flag) { this.motionEnabled = flag; }
  }

  // ------------------------------------------------------------
  // Five porcelain "makers" — procedural stand-ins
  // ------------------------------------------------------------
  function makeVesselA() {
    const lathePts = [];
    for (let i=0;i<20;i++){
      const t = i/19;
      const x = 0.6 + Math.sin(t*Math.PI)*0.8 * (0.5 + 0.5*t);
      const y = -1 + t*2.2;
      lathePts.push(new THREE.Vector2(x, y));
    }
    const geo = new THREE.LatheGeometry(lathePts, 128);
    const mat = new THREE.MeshPhysicalMaterial({ color:0xf7f8fb, roughness:0.06, clearcoat:1.0, envMap: scene.environment, envMapIntensity: 1.4});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = mesh.receiveShadow = true;
    return mesh;
  }

  function makePlateB() {
    const ring = new THREE.RingGeometry(0.5, 2.0, 128);
    const bowl = new THREE.SphereGeometry(2.2, 128, 128, 0, Math.PI*2, 0, Math.PI/2);
    bowl.scale(1,0.38,1);
    const mat = new THREE.MeshPhysicalMaterial({ color:0xeaf6ff, roughness:0.03, clearcoat:1.0, envMap: scene.environment, envMapIntensity: 1.6 });
    const combo = new THREE.Group();
    const rim = new THREE.Mesh(ring, mat.clone());
    rim.rotation.x = -Math.PI/2; rim.position.y = 0.01; rim.receiveShadow = true;
    const center = new THREE.Mesh(bowl, mat.clone()); center.position.y = 0.02; center.castShadow = true;
    combo.add(center, rim);
    return combo;
  }

  function makeMiniSculptC() {
    const geo = new THREE.TorusKnotGeometry(0.9, 0.25, 256, 32, 2, 3);
    geo.rotateX(Math.PI*0.1);
    const mat = new THREE.MeshPhysicalMaterial({ color: 0xffefef, roughness: 0.08, clearcoat: 1.0, envMap: scene.environment, envMapIntensity: 1.2 });
    const m = new THREE.Mesh(geo, mat);
    m.castShadow = m.receiveShadow = true;
    return m;
  }

  function makeTallCylinderD() {
    const geo = new THREE.CylinderGeometry(0.8,0.8,3.6,64,1,true);
    const mat = new THREE.MeshPhysicalMaterial({ color: 0xfffffb, roughness: 0.06, clearcoat: 1.0, envMap: scene.environment, envMapIntensity: 1.2 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = mesh.receiveShadow = true;
    return mesh;
  }

  function makeBowlE() {
    const geo = new THREE.SphereGeometry(1.8, 128, 128, 0, Math.PI*2, 0, Math.PI/1.7);
    geo.scale(1,0.7,1);
    const mat = new THREE.MeshPhysicalMaterial({ color: 0xe8f2ff, roughness: 0.02, clearcoat:0.9, envMap: scene.environment, envMapIntensity:1.8 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = mesh.receiveShadow = true;
    return mesh;
  }

  // ------------------------------------------------------------
  // Build scenes array
  // ------------------------------------------------------------
  const scenes = [
    new PorcelainScene({ id:0, name:'Dawn Vessel', palette:{ bg:0x05050A, key:0xfff8e8 }, make: makeVesselA }),
    new PorcelainScene({ id:1, name:'Calm Mirror', palette:{ bg:0x071022, key:0xdfefff }, make: makePlateB }),
    new PorcelainScene({ id:2, name:'Whim', palette:{ bg:0x10040a, key:0xffefe9 }, make: makeMiniSculptC }),
    new PorcelainScene({ id:3, name:'Echo Column', palette:{ bg:0x071011, key:0xfffff6 }, make: makeTallCylinderD }),
    new PorcelainScene({ id:4, name:'Night Bloom', palette:{ bg:0x040618, key:0xe6f0ff }, make: makeBowlE })
  ];

  // add first scene to world
  let currentIndex = 0;
  scene.add(scenes[0].group);

  // set camera framing target for each scene
  const sceneCameraTargets = [
    { position: new THREE.Vector3(6,3.5,6), target: new THREE.Vector3(0,1.1,0) },
    { position: new THREE.Vector3(5.5,2.8,5.8), target: new THREE.Vector3(0,0.85,0) },
    { position: new THREE.Vector3(7,3.4,7), target: new THREE.Vector3(0,0.8,0) },
    { position: new THREE.Vector3(6.2,3.8,6.2), target: new THREE.Vector3(0,1.4,0) },
    { position: new THREE.Vector3(7.5,3.6,7.8), target: new THREE.Vector3(0,0.9,0) }
  ];

  const sceneLabel = document.getElementById('sceneLabel');
  function updateSceneLabel() {
    sceneLabel.textContent = `Scene ${currentIndex+1} / 5 — ${scenes[currentIndex].name}`;
  }
  updateSceneLabel();

  // enter first scene
  scenes[currentIndex].enter(sceneCameraTargets[currentIndex]);

  // ------------------------------------------------------------
  // Utilities to set/get group opacity safely for transition (STEP 6)
  // ------------------------------------------------------------
  function setGroupOpacity(group, value) {
    group.traverse((c) => {
      if (c.isMesh && c.material) {
        if (!('__origTransparent' in c.material)) {
          c.material.__origTransparent = c.material.transparent;
          c.material.__origOpacity = c.material.opacity !== undefined ? c.material.opacity : 1.0;
        }
        c.material.transparent = true;
        c.material.opacity = value;
        c.material.needsUpdate = true;
      }
    });
  }
  function restoreGroupMaterialStates(group) {
    group.traverse((c) => {
      if (c.isMesh && c.material && ('__origTransparent' in c.material)) {
        c.material.transparent = c.material.__origTransparent;
        c.material.opacity = c.material.__origOpacity;
        delete c.material.__origTransparent;
        delete c.material.__origOpacity;
        c.material.needsUpdate = true;
      }
    });
  }

  // ------------------------------------------------------------
  // Scene switching with GSAP timeline (STEP 6 — smoother transitions)
  // ------------------------------------------------------------
  let transitioning = false;
  function gotoScene(index, direction = 1) {
    if (transitioning || index === currentIndex || index < 0 || index >= scenes.length) return;
    transitioning = true;
    const from = scenes[currentIndex];
    const to = scenes[index];

    // Add new scene group to scene graph for crossfade
    scene.add(to.group);

    // prepare materials for opacity crossfade
    setGroupOpacity(from.group, 1.0);
    setGroupOpacity(to.group, 0.0);

    // disable controls during transition (STEP 6)
    controls.enabled = false;

    // build timeline
    const tl = gsap.timeline({
      onComplete: () => {
        // cleanup: remove old group and restore materials
        scene.remove(from.group);
        restoreGroupMaterialStates(to.group);
        restoreGroupMaterialStates(from.group);
        currentIndex = index;
        updateSceneLabel();
        transitioning = false;
        controls.enabled = true;
      }
    });

    // start camera flight: small arc/zoom + change target
    tl.to(camera.position, { x: sceneCameraTargets[index].position.x * 0.7 + camera.position.x*0.3, y: sceneCameraTargets[index].position.y*0.7 + camera.position.y*0.3, z: sceneCameraTargets[index].position.z*0.7 + camera.position.z*0.3, duration: 0.6, ease: "power2.inOut" });
    tl.to(controls.target, { x: sceneCameraTargets[index].target.x, y: sceneCameraTargets[index].target.y, z: sceneCameraTargets[index].target.z, duration: 1.05, ease:"expo.inOut", onUpdate: () => controls.update() }, "<0.15");

    // crossfade: fade out old, fade in new
    tl.to(from.group.children, { duration: 0.9, onStart: () => from.exit() }, "<0.05");
    tl.to({}, { duration: 0.05 }); // small spacer
    tl.to(from.group.children, { onUpdate: () => {}, duration: 0.9 }, "<");
    // animate opacities directly
    tl.to({}, { duration: 0.01 }); // spacer to ensure sequencing
    tl.to({ t: 1 }, {
      t: 0,
      duration: 0.95,
      ease: "power2.inOut",
      onUpdate: function() {
        const val = this.targets()[0].t;
        setGroupOpacity(from.group, val);
      }
    }, "<0.05");
    tl.to({ t: 0 }, {
      t: 1,
      duration: 1.05,
      ease: "power2.inOut",
      onUpdate: function() {
        const val = this.targets()[0].t;
        setGroupOpacity(to.group, val);
      }
    }, "<0.1");

    // finalize with explicit enter() call for new scene (lighting, bloom adjustments)
    to.enter(sceneCameraTargets[index]);
  }

  // keyboard navigation
  window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowRight') gotoScene((currentIndex+1)%scenes.length, 1);
    if (e.code === 'ArrowLeft') gotoScene((currentIndex-1+scenes.length)%scenes.length, -1);
    if (e.code === 'Space') {
      scenes[currentIndex].toggleMotion(!scenes[currentIndex].motionEnabled);
    }
  });

  // ------------------------------------------------------------
  // Pointer, scroll, click interactions
  // ------------------------------------------------------------
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2(-10, -10);
  let pointerActive = false;
  let lastInteractionTime = performance.now();

  function onPointerMove(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = - ((e.clientY - rect.top) / rect.height) * 2 + 1;
    pointerActive = true;
    lastInteractionTime = performance.now();
  }
  window.addEventListener('mousemove', onPointerMove, { passive: true });
  window.addEventListener('pointerdown', (e) => {
    onPointerMove(e);
    const pos = computeCursorWorld();
    spawnPulse(pos, 0xfff0d8, 80);
  }, { passive: true });
  window.addEventListener('pointerup', () => { pointerActive = false; lastInteractionTime = performance.now(); }, { passive: true });

  // smooth scroll to zoom — we will lerp camera distance
  let scrollTarget = camera.position.distanceTo(controls.target);
  window.addEventListener('wheel', (e) => {
    const delta = e.deltaY * 0.003;
    scrollTarget += delta * 6.0;
    scrollTarget = THREE.MathUtils.clamp(scrollTarget, 2.2, 40);
  }, { passive: true });

  function computeCursorWorld() {
    raycaster.setFromCamera(mouse, camera);
    const curScene = scenes[currentIndex];
    if (curScene && curScene.porcelain) {
      const meshes = []; curScene.porcelain.traverse((m)=>{ if (m.isMesh) meshes.push(m); });
      const ints = raycaster.intersectObjects(meshes, true);
      if (ints.length>0) return ints[0].point.clone();
    }
    const ints2 = raycaster.intersectObject(interactPlane);
    if (ints2.length>0) return ints2[0].point.clone();
    return new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);
  }

  // ------------------------------------------------------------
  // Resize (STEP 7 — ensure correct bokeh aspect update)
  // ------------------------------------------------------------
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
    // Bokeh pass aspect adjustment per requirement
    try {
      if (bokehPass && bokehPass.materialBokeh && bokehPass.materialBokeh.uniforms && bokehPass.materialBokeh.uniforms.aspect) {
        bokehPass.materialBokeh.uniforms.aspect.value = camera.aspect;
      }
      // some implementations use different uniform names; attempt safer fallback too
      if (bokehPass && bokehPass.uniforms && bokehPass.uniforms['width']) {
        bokehPass.uniforms['width'].value = window.innerWidth;
        bokehPass.uniforms['height'].value = window.innerHeight;
      }
    } catch (err) {
      // ignore if pass doesn't expose that API
    }
  });

  // ------------------------------------------------------------
  // UI toggles wiring
  // ------------------------------------------------------------
  const toggleBloom = document.getElementById('toggleBloom');
  const toggleDOF = document.getElementById('toggleDOF');
  const toggleParticles = document.getElementById('toggleParticles');

  toggleBloom.addEventListener('change', () => bloomPass.enabled = toggleBloom.checked);
  toggleDOF.addEventListener('change', () => bokehPass.enabled = toggleDOF.checked);
  toggleParticles.addEventListener('change', () => {
    scenes.forEach(s => { if (s.particles) s.particles.visible = toggleParticles.checked; });
  });

  // ------------------------------------------------------------
  // Animate loop (core interactivity)
  // ------------------------------------------------------------
  const clock = new THREE.Clock();

  function animate() {
    const dt = Math.min(0.05, clock.getDelta());
    const elapsed = clock.getElapsedTime();

    // smooth scroll zoom towards scrollTarget -> adjust camera along its forward vector
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    const desiredDistance = THREE.MathUtils.lerp(camera.position.distanceTo(controls.target), scrollTarget, 0.06);
    const newCamPos = new THREE.Vector3().copy(camDir).multiplyScalar(-desiredDistance).add(controls.target);
    camera.position.lerp(newCamPos, 0.08);

    // compute cursor world and intensity
    let cursorWorld = null;
    let cursorIntensity = 0;
    if (mouse.x > -9) {
      cursorWorld = computeCursorWorld();
      const worldCenter = new THREE.Vector3();
      scenes[currentIndex].group.getWorldPosition(worldCenter);
      const dist = cursorWorld.distanceTo(worldCenter);
      cursorIntensity = THREE.MathUtils.clamp(1.0 - (dist / 10.0), 0.0, 1.0);
    }

    // update cursor light & visuals
    if (cursorWorld) {
      cursorLight.position.lerp(cursorWorld, 0.18);
      cursorBall.position.lerp(cursorWorld, 0.17);
      glow.position.lerp(new THREE.Vector3().copy(cursorWorld).add(new THREE.Vector3().subVectors(camera.position, cursorWorld).setLength(0.06)), 0.18);

      // STEP 1 — reduce multiplier, clamp intensity and lerp (smooth interpolation)
      const intendedRaw = 0.04 + cursorIntensity * 1.6; // reduced multiplier
      const intended = THREE.MathUtils.clamp(intendedRaw, 0.04, 1.8); // clamp
      cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, intended, 0.12);

      // glow scale and opacity
      glow.material.opacity = THREE.MathUtils.lerp(glow.material.opacity, 0.65 * (cursorIntensity*0.85 + 0.15), 0.12);
      const gS = THREE.MathUtils.lerp(glow.scale.x, 0.3 + cursorIntensity*1.8, 0.12);
      glow.scale.setScalar(gS);
    } else {
      cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, 0.0, 0.06);
      glow.material.opacity = THREE.MathUtils.lerp(glow.material.opacity, 0.0, 0.05);
    }

    // update pulses
    for (let i = pulseGroup.children.length - 1; i >= 0; i--) {
      const p = pulseGroup.children[i];
      p.userData.life -= dt * 0.8;
      const posAttr = p.geometry.attributes.position;
      const velAttr = p.geometry.attributes.vel;
      for (let v=0; v<posAttr.count; v++){
        posAttr.array[v*3] += velAttr.array[v*3] * dt;
        posAttr.array[v*3+1] += velAttr.array[v*3+1] * dt;
        posAttr.array[v*3+2] += velAttr.array[v*3+2] * dt;
        velAttr.array[v*3+1] -= dt * 0.9;
      }
      posAttr.needsUpdate = true;
      velAttr.needsUpdate = true;
      p.material.opacity = Math.max(0, p.userData.life);
      if (p.userData.life <= 0) {
        pulseGroup.remove(p);
        p.geometry.dispose();
        p.material.dispose();
      }
    }

    // scene updates for current scene
    scenes[currentIndex].update(dt, elapsed, cursorWorld, cursorIntensity);

    controls.update();
    composer.render();

    requestAnimationFrame(animate);
  }

  requestAnimationFrame(animate);
  </script>
</body>
</html>
