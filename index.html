<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Porcelain Transcendence — Enhanced Engine</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body, #container { height: 100%; width: 100%; }
    body {
      background: #000;
      color: #fff;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      overflow: hidden;
    }
    #container { position: fixed; inset: 0; }
    canvas { display: block; touch-action: none; }
    .ui { position: absolute; z-index: 60; inset: 0; pointer-events: none; }
    .panel {
      pointer-events: auto;
      position: absolute;
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,0.05);
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.4;
    }
    .top-left { left: 16px; top: 16px; }
    .top-right { right: 16px; top: 16px; text-align: right; }
    .bottom-left { left: 16px; bottom: 16px; }
    .scene-indicator { font-weight: 600; opacity: 0.95; }
    .small { font-size: 12px; opacity: 0.8; }
    .loading { 
      position: fixed; 
      inset: 0; 
      background: #000; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      z-index: 1000; 
      font-size: 18px; 
    }
    .loading-progress {
      width: 200px;
      height: 3px;
      background: rgba(255,255,255,0.1);
      margin-top: 10px;
      border-radius: 2px;
      overflow: hidden;
    }
    .loading-bar {
      height: 100%;
      background: #fff;
      width: 0%;
      transition: width 0.3s ease;
    }
  </style>
</head>
<body>
  <div id="container" role="application" aria-label="Porcelain Transcendence canvas"></div>
  <div class="loading" id="loading">
    <div>Initializing Enhanced Engine...</div>
    <div class="loading-progress">
      <div class="loading-bar" id="loadingBar"></div>
    </div>
  </div>

  <div class="ui" aria-hidden="false">
    <div class="panel top-left" role="region" aria-label="Scene information">
      <div id="sceneLabel" class="scene-indicator" role="status" aria-live="polite">Scene 1 / 5 — Dawn Vessel</div>
      <div class="small">← → : Change Scene • SPACE : Toggle Motion • Click : Reactive Pulse</div>
    </div>

    <div class="panel top-right" role="region" aria-label="Effects toggles">
      <label><input id="toggleBloom" type="checkbox" checked> Bloom</label><br>
      <label><input id="toggleDOF" type="checkbox"> DOF</label><br>
      <label><input id="toggleParticles" type="checkbox" checked> Particles</label><br>
      <label><input id="toggleScanner" type="checkbox"> Material Scanner</label><br>
      <label><input id="toggleTemporal" type="checkbox"> Day/Night Cycle</label>
    </div>

    <div class="panel bottom-left" role="region" aria-label="Controls">
      <div class="small">DRAG: Orbit • PINCH: Zoom • SCROLL: Stage Chapters</div>
      <div class="small" id="timeDisplay">Time: 12:00 PM</div>
    </div>
  </div>

  <!-- Fallback script loading -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  
  <script>
    // Enhanced initialization with fallbacks
    class PorcelainEngine {
      constructor() {
        this.isInitialized = false;
        this.loadingProgress = 0;
        this.init();
      }

      async init() {
        try {
          await this.updateLoading('Checking dependencies...', 10);
          
          // Check if Three.js is available
          if (typeof THREE === 'undefined') {
            throw new Error('Three.js not loaded');
          }

          await this.updateLoading('Initializing core engine...', 30);
          await this.initializeEngine();
          
          await this.updateLoading('Creating scenes...', 60);
          await this.createScenes();
          
          await this.updateLoading('Setting up effects...', 80);
          await this.setupEffects();
          
          await this.updateLoading('Starting render loop...', 95);
          await this.startRenderLoop();
          
          await this.updateLoading('Ready!', 100);
          
          setTimeout(() => {
            document.getElementById('loading').style.opacity = '0';
            setTimeout(() => {
              document.getElementById('loading').style.display = 'none';
            }, 500);
          }, 1000);
          
        } catch (error) {
          console.error('Initialization failed:', error);
          this.updateLoading('Error: ' + error.message, 0);
        }
      }

      updateLoading(text, progress) {
        return new Promise(resolve => {
          const loadingElement = document.getElementById('loading');
          const progressBar = document.getElementById('loadingBar');
          
          if (loadingElement && loadingElement.children[0]) {
            loadingElement.children[0].textContent = text;
          }
          if (progressBar) {
            progressBar.style.width = progress + '%';
          }
          
          this.loadingProgress = progress;
          setTimeout(resolve, 50);
        });
      }

      async initializeEngine() {
        // Core Three.js setup
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000010);
        
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(8, 4.5, 9);
        
        this.renderer = new THREE.WebGLRenderer({ 
          antialias: true, 
          powerPreference: "high-performance" 
        });
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.outputEncoding = THREE.sRGBEncoding;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 0.9;
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        document.getElementById('container').appendChild(this.renderer.domElement);
        
        // Simple controls
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.minDistance = 3;
        this.controls.maxDistance = 50;
        
        // Basic lighting
        const ambientLight = new THREE.AmbientLight(0x404060, 0.4);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xfff0e0, 1.0);
        directionalLight.position.set(10, 15, 10);
        directionalLight.castShadow = true;
        this.scene.add(directionalLight);
      }

      async createScenes() {
        this.scenes = [];
        const sceneConfigs = [
          { name: "Dawn Vessel", color: 0xffeebb, scale: 1.2 },
          { name: "Calm Plate", color: 0xbbeeff, scale: 1.0 },
          { name: "Whim Sculpture", color: 0xffbbee, scale: 0.8 },
          { name: "Echo Column", color: 0xeeffbb, scale: 1.5 },
          { name: "Night Bloom", color: 0xbbffee, scale: 1.1 }
        ];

        for (let i = 0; i < sceneConfigs.length; i++) {
          const config = sceneConfigs[i];
          const sceneGroup = new THREE.Group();
          
          // Create different geometries for each scene
          let geometry;
          switch(i) {
            case 0: // Vessel
              geometry = this.createVesselGeometry();
              break;
            case 1: // Plate
              geometry = this.createPlateGeometry();
              break;
            case 2: // Sculpture
              geometry = this.createSculptureGeometry();
              break;
            case 3: // Column
              geometry = this.createColumnGeometry();
              break;
            case 4: // Bowl
              geometry = this.createBowlGeometry();
              break;
          }
          
          const material = new THREE.MeshPhysicalMaterial({
            color: config.color,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 1.0,
            clearcoatRoughness: 0.05,
            transparent: true,
            opacity: 0.9
          });
          
          const mesh = new THREE.Mesh(geometry, material);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          mesh.scale.setScalar(config.scale);
          
          sceneGroup.add(mesh);
          
          // Add particle system
          this.addParticleSystem(sceneGroup, i);
          
          this.scenes.push({
            group: sceneGroup,
            mesh: mesh,
            config: config,
            particles: sceneGroup.children.find(child => child.isPoints),
            animation: {
              rotationSpeed: 0.3 + Math.random() * 0.4,
              floatHeight: 0.1 + Math.random() * 0.2,
              floatSpeed: 0.5 + Math.random() * 1.0
            }
          });
        }
        
        // Add first scene
        this.currentSceneIndex = 0;
        this.scene.add(this.scenes[0].group);
        this.updateSceneLabel(0);
      }

      createVesselGeometry() {
        const points = [];
        for (let i = 0; i <= 20; i++) {
          const t = i / 20;
          const x = Math.sin(t * Math.PI) * 1.5;
          const y = (t - 0.5) * 3;
          points.push(new THREE.Vector2(x, y));
        }
        return new THREE.LatheGeometry(points, 32);
      }

      createPlateGeometry() {
        return new THREE.CylinderGeometry(2, 2, 0.2, 64);
      }

      createSculptureGeometry() {
        return new THREE.TorusKnotGeometry(1, 0.3, 64, 16);
      }

      createColumnGeometry() {
        return new THREE.CylinderGeometry(0.8, 1, 3, 32);
      }

      createBowlGeometry() {
        return new THREE.SphereGeometry(1.5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
      }

      addParticleSystem(sceneGroup, sceneIndex) {
        const particleCount = 100;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        const colorPalette = [
          new THREE.Color(0xff6b6b),
          new THREE.Color(0x4ecdc4),
          new THREE.Color(0x45b7d1),
          new THREE.Color(0x96ceb4),
          new THREE.Color(0xffeaa7)
        ];
        
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          const radius = 2 + Math.random() * 3;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          
          positions[i3] = Math.sin(phi) * Math.cos(theta) * radius;
          positions[i3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
          positions[i3 + 2] = Math.cos(phi) * radius;
          
          const color = colorPalette[sceneIndex % colorPalette.length].clone();
          color.multiplyScalar(0.7 + Math.random() * 0.3);
          colors[i3] = color.r;
          colors[i3 + 1] = color.g;
          colors[i3 + 2] = color.b;
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const particleMaterial = new THREE.PointsMaterial({
          size: 0.05,
          vertexColors: true,
          transparent: true,
          opacity: 0.6,
          sizeAttenuation: true
        });
        
        const particleSystem = new THREE.Points(particles, particleMaterial);
        sceneGroup.add(particleSystem);
      }

      async setupEffects() {
        // Setup event listeners
        this.setupEventListeners();
        
        // Initialize UI controls
        this.setupUIControls();
        
        // Setup clock for animations
        this.clock = new THREE.Clock();
      }

      setupEventListeners() {
        window.addEventListener('resize', () => this.onWindowResize());
        window.addEventListener('keydown', (e) => this.onKeyDown(e));
        
        // Mouse controls
        this.mouse = new THREE.Vector2(-10, -10);
        this.renderer.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.renderer.domElement.addEventListener('click', (e) => this.onClick(e));
      }

      setupUIControls() {
        document.getElementById('toggleBloom').addEventListener('change', (e) => {
          // Bloom effect toggle would go here
        });
        
        document.getElementById('toggleParticles').addEventListener('change', (e) => {
          this.scenes.forEach(s => { 
            if (s.particles) s.particles.visible = e.target.checked; 
          });
        });
      }

      onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
      }

      onKeyDown(event) {
        if (event.code === 'ArrowRight') {
          this.switchScene((this.currentSceneIndex + 1) % this.scenes.length);
        } else if (event.code === 'ArrowLeft') {
          this.switchScene((this.currentSceneIndex - 1 + this.scenes.length) % this.scenes.length);
        } else if (event.code === 'Space') {
          event.preventDefault();
          this.toggleAnimation();
        }
      }

      onMouseMove(event) {
        const rect = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      }

      onClick(event) {
        // Simple pulse effect on click
        if (typeof gsap !== 'undefined') {
          const currentScene = this.scenes[this.currentSceneIndex];
          gsap.to(currentScene.mesh.scale, {
            x: 1.1, y: 1.1, z: 1.1,
            duration: 0.1,
            yoyo: true,
            repeat: 1
          });
        }
      }

      switchScene(index) {
        if (index === this.currentSceneIndex || index < 0 || index >= this.scenes.length) return;
        
        // Remove current scene
        this.scene.remove(this.scenes[this.currentSceneIndex].group);
        
        // Add new scene
        this.scene.add(this.scenes[index].group);
        this.currentSceneIndex = index;
        
        this.updateSceneLabel(index);
      }

      updateSceneLabel(index) {
        const sceneLabel = document.getElementById('sceneLabel');
        if (sceneLabel) {
          sceneLabel.textContent = `Scene ${index + 1} / 5 — ${this.scenes[index].config.name}`;
        }
      }

      toggleAnimation() {
        this.controls.autoRotate = !this.controls.autoRotate;
      }

      async startRenderLoop() {
        const animate = () => {
          requestAnimationFrame(animate);
          
          const delta = this.clock.getDelta();
          const elapsed = this.clock.getElapsedTime();
          
          // Update controls
          this.controls.update();
          
          // Update current scene animation
          const currentScene = this.scenes[this.currentSceneIndex];
          if (currentScene) {
            // Floating animation
            currentScene.group.position.y = Math.sin(elapsed * currentScene.animation.floatSpeed) * currentScene.animation.floatHeight;
            
            // Gentle rotation
            currentScene.group.rotation.y += delta * currentScene.animation.rotationSpeed * 0.5;
            
            // Particle animation
            if (currentScene.particles) {
              currentScene.particles.rotation.y += delta * 0.1;
            }
          }
          
          // Render
          this.renderer.render(this.scene, this.camera);
        };
        
        animate();
        this.isInitialized = true;
      }
    }

    // Start the engine when the page loads
    window.addEventListener('DOMContentLoaded', () => {
      new PorcelainEngine();
    });

    // Fallback for older browsers
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        new PorcelainEngine();
      });
    } else {
      new PorcelainEngine();
    }

    // Global access for debugging
    window.PorcelainEngine = PorcelainEngine;
  </script>
</body>
</html>
