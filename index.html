<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Porcelain 3D</title>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"></script>
    <style>
      :root {
        color-scheme: dark;
      }

      html, body {
        height: 100%;
        margin: 0;
        background: #0c0d14;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        color: #f5f6f9;
        overflow: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background:
          radial-gradient(60% 80% at 50% 20%, rgba(68, 83, 255, 0.25), transparent),
          radial-gradient(50% 60% at 20% 80%, rgba(255, 134, 74, 0.18), transparent),
          radial-gradient(55% 65% at 80% 75%, rgba(255, 214, 143, 0.12), transparent);
        pointer-events: none;
        z-index: 0;
        filter: blur(40px);
        opacity: 0.65;
        transition: opacity 0.6s ease;
      }

      canvas {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        display: block;
        z-index: 1;
      }

      .hud {
        position: fixed;
        top: 18px;
        left: 20px;
        color: rgba(236, 238, 255, 0.8);
        font: 12px/1.2 "Inter", system-ui, sans-serif;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        backdrop-filter: blur(6px);
        padding: 8px 12px;
        border-radius: 999px;
        background: rgba(14, 17, 28, 0.55);
        border: 1px solid rgba(255, 255, 255, 0.08);
        z-index: 7;
      }

      .viewer-pocket {
        position: fixed;
        top: 20px;
        right: 20px;
        width: min(320px, 28vw);
        aspect-ratio: 1;
        border-radius: 18px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 18px 45px rgba(8, 10, 18, 0.55);
        background: radial-gradient(circle at top, rgba(37, 40, 58, 0.92), rgba(8, 9, 18, 0.92));
        z-index: 6;
        backdrop-filter: blur(16px);
      }

      .viewer-pocket::after {
        content: "model-viewer demo";
        position: absolute;
        left: 16px;
        bottom: 16px;
        font: 11px/1 "Inter", system-ui, sans-serif;
        letter-spacing: 0.16em;
        text-transform: uppercase;
        color: rgba(222, 229, 255, 0.65);
      }

      model-viewer {
        width: 100%;
        height: 100%;
        --poster-color: rgba(12, 14, 25, 0.85);
      }

      @media (max-width: 1024px) {
        .viewer-pocket {
          width: min(260px, 34vw);
        }
      }

      @media (max-width: 768px) {
        .hud {
          top: 14px;
          left: 14px;
          font-size: 10px;
          padding: 6px 10px;
        }

        .viewer-pocket {
          width: min(220px, 55vw);
          top: 14px;
          right: 14px;
        }
      }
    </style>
  </head>
  <body>
    <div class="hud" id="hud">Loading...</div>
    <canvas id="c"></canvas>

    <!-- Optional: Uncomment if you want the astronaut preview -->
    <!--
    <div class="viewer-pocket">
      <model-viewer
        alt="Neil Armstrong's Spacesuit"
        src="https://modelviewer.dev/shared-assets/models/Astronaut.glb"
        ar
        environment-image="https://modelviewer.dev/shared-assets/environments/moon_1k.hdr"
        poster="https://modelviewer.dev/shared-assets/models/Astronaut.webp"
        shadow-intensity="1"
        camera-controls
        touch-action="pan-y"
      ></model-viewer>
    </div>
    -->

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js";
      import { GLTFLoader } from "https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js";

      const hud = document.getElementById("hud");
      const canvas = document.getElementById("c");
      
      // Initialize renderer
      const renderer = new THREE.WebGLRenderer({ 
        canvas, 
        antialias: true, 
        alpha: false 
      });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.1;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Scene setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x080811);
      scene.fog = new THREE.Fog(0x090a15, 10, 35);

      // Camera
      const camera = new THREE.PerspectiveCamera(
        50, 
        window.innerWidth / window.innerHeight, 
        0.01, 
        150
      );
      camera.position.set(1.6, 1.1, 1.6);

      // Controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.065;
      controls.minDistance = 0.2;
      controls.maxDistance = 12;

      // Lighting
      const hemi = new THREE.HemisphereLight(0xd7e0ff, 0x1a1b1f, 0.55);
      scene.add(hemi);

      const key = new THREE.DirectionalLight(0xffffff, 1.6);
      key.position.set(2, 3, 1);
      key.castShadow = true;
      key.shadow.mapSize.set(2048, 2048);
      scene.add(key);

      const rim = new THREE.DirectionalLight(0x92b7ff, 0.75);
      rim.position.set(-2.5, 1.8, -1.4);
      scene.add(rim);

      // Ground
      const ground = new THREE.Mesh(
        new THREE.CylinderGeometry(3.5, 3.5, 0.02, 48),
        new THREE.MeshStandardMaterial({
          color: 0x121222,
          roughness: 0.8,
          metalness: 0.08,
          emissive: 0x040408,
          emissiveIntensity: 0.15
        })
      );
      ground.receiveShadow = true;
      ground.position.y = -0.01;
      scene.add(ground);

      // Grid helper
      const grid = new THREE.GridHelper(4, 40, 0x3a3c3f, 0x222427);
      grid.position.y = 0;
      grid.material.opacity = 0.15;
      grid.material.transparent = true;
      scene.add(grid);

      // Model group
      const modelGroup = new THREE.Group();
      scene.add(modelGroup);

      // Sparkles
      const sparkleCount = 450;
      const sparkleGeometry = new THREE.BufferGeometry();
      const sparklePositions = new Float32Array(sparkleCount * 3);
      for (let i = 0; i < sparkleCount; i++) {
        const radius = 2 + Math.random() * 5.5;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        sparklePositions[i * 3 + 0] = radius * Math.sin(phi) * Math.cos(theta);
        sparklePositions[i * 3 + 1] = radius * Math.cos(phi) * 0.45;
        sparklePositions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
      }
      sparkleGeometry.setAttribute("position", new THREE.BufferAttribute(sparklePositions, 3));

      const sparkleMaterial = new THREE.PointsMaterial({
        color: new THREE.Color(0x84c2ff),
        size: 0.08,
        transparent: true,
        opacity: 0.85,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });

      const sparkles = new THREE.Points(sparkleGeometry, sparkleMaterial);
      sparkles.position.y = 0.35;
      sparkles.visible = false;
      scene.add(sparkles);

      // Environment map
      const envCanvas = document.createElement("canvas");
      envCanvas.width = 512;
      envCanvas.height = 256;
      const envCtx = envCanvas.getContext("2d");
      const gradient = envCtx.createLinearGradient(0, 0, 0, envCanvas.height);
      gradient.addColorStop(0, "#1e1a3e");
      gradient.addColorStop(0.35, "#3e1a6b");
      gradient.addColorStop(0.7, "#0b2048");
      gradient.addColorStop(1, "#06121f");
      envCtx.fillStyle = gradient;
      envCtx.fillRect(0, 0, envCanvas.width, envCanvas.height);
      const envTexture = new THREE.CanvasTexture(envCanvas);
      envTexture.mapping = THREE.EquirectangularReflectionMapping;
      envTexture.colorSpace = THREE.SRGBColorSpace;
      envTexture.anisotropy = 4;
      scene.environment = envTexture;

      // Model loading
      const loader = new GLTFLoader();
      const frameBox = new THREE.Box3();
      const frameVec = new THREE.Vector3();

      // Try loading the model
      const glbUrl = "./porcelain.glb";
      
      loader.load(
        glbUrl,
        (gltf) => {
          console.log("Model loaded successfully");
          hud.textContent = "Model loaded â€” drag to orbit, scroll to zoom";
          
          const model = gltf.scene;

          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              if (child.material) {
                if (Array.isArray(child.material)) {
                  child.material.forEach((mat) => {
                    mat.toneMapped = true;
                  });
                } else {
                  child.material.toneMapped = true;
                }
              }
            }
          });

          modelGroup.clear();
          modelGroup.add(model);

          // Center and frame the model
          frameBox.setFromObject(model);
          const center = frameBox.getCenter(frameVec);
          model.position.sub(center);
          
          frameBox.setFromObject(model);
          const floorOffset = frameBox.min.y;
          model.position.y -= floorOffset;

          // Position camera to frame the model
          frameBox.setFromObject(model);
          const size = frameBox.getSize(frameVec);
          const radius = size.length() * 0.5;
          const fov = THREE.MathUtils.degToRad(camera.fov);
          const distance = radius / Math.tan(fov * 0.5);

          const framedCenter = frameBox.getCenter(frameVec);
          controls.target.copy(framedCenter);
          camera.position.set(distance * 0.9, distance * 0.6 + size.y * 0.15, distance * 0.9);
          camera.near = Math.max(0.01, radius * 0.02);
          camera.far = radius * 20;
          camera.updateProjectionMatrix();

          sparkles.visible = true;
        },
        (xhr) => {
          // Progress callback
          if (xhr && xhr.loaded && xhr.total) {
            const pct = Math.round((xhr.loaded / xhr.total) * 100);
            hud.textContent = `Loading model: ${pct}%`;
          }
        },
        (error) => {
          console.error("Failed to load model:", error);
          hud.textContent = "Error loading model. Check console for details.";
          hud.style.color = "#ff6b6b";
        }
      );

      // Animation loop
      const clock = new THREE.Clock();
      let spinSpeed = 0.25;

      function animate() {
        const delta = clock.getDelta();
        const elapsed = clock.elapsedTime;

        modelGroup.rotation.y += spinSpeed * delta;
        sparkles.rotation.y += delta * 0.1;
        sparkles.rotation.x = Math.sin(elapsed * 0.08) * 0.1;

        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      animate();

      // Window resize handler
      window.addEventListener("resize", () => {
        const width = window.innerWidth;
        const height = window.innerHeight;

        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      });

      // Double-click to focus
      renderer.domElement.addEventListener("dblclick", (e) => {
        const rect = renderer.domElement.getBoundingClientRect();
        const mouse = new THREE.Vector2(
          ((e.clientX - rect.left) / rect.width) * 2 - 1,
          -((e.clientY - rect.top) / rect.height) * 2 + 1
        );

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(modelGroup.children, true);
        
        if (intersects.length > 0) {
          controls.target.copy(intersects[0].point);
        }
      });

      // Spacebar to toggle rotation
      document.addEventListener("keydown", (event) => {
        if (event.code === "Space") {
          spinSpeed = spinSpeed > 0 ? 0 : 0.25;
        }
      });
    </script>
  </body>
</html>
