<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Porcelain Transcendence — Stable Cinematic Build</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body,#container{height:100%;width:100%}
  body{background:#000;color:#fff;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;overflow:hidden}
  #container{position:fixed;inset:0}
  canvas{display:block;touch-action:none}
  .ui{position:absolute;inset:0;pointer-events:none;z-index:10}
  .panel{position:absolute;pointer-events:auto;background:rgba(0,0,0,.45);backdrop-filter:blur(6px);
         border:1px solid rgba(255,255,255,.08);padding:8px 10px;border-radius:10px;font-size:13px;line-height:1.35}
  .top-left{left:12px;top:12px}
  .top-right{right:12px;top:12px;text-align:right}
  .bottom-left{left:12px;bottom:12px}
  .debug{right:12px;bottom:12px;min-width:260px}
  .small{font-size:12px;opacity:.8}
  .row{display:flex;align-items:center;gap:6px;margin:4px 0}
  .row label{width:120px;opacity:.9}
  .row input[type="range"]{flex:1}
</style>
</head>
<body>
<div id="container" role="application" aria-label="Porcelain canvas"></div>

<div class="ui">
  <div class="panel top-left">
    <div id="sceneLabel" style="font-weight:600">Scene 1 / 5 — Dawn Vessel</div>
    <div class="small">← → change scene • SCROLL chapters (0–3) • SPACE pause</div>
  </div>
  <div class="panel top-right">
    <label><input id="toggleBloom" type="checkbox" checked> Bloom</label><br/>
    <label><input id="toggleDOF" type="checkbox"> DOF</label><br/>
    <label><input id="toggleParticles" type="checkbox" checked> Particles</label>
  </div>

  <!-- Live debug: tune exposure/spec/bloom safely -->
  <div class="panel debug">
    <div class="row"><label>Exposure</label><input id="exposure" type="range" min="0.3" max="1.2" step="0.01" value="0.65"><span id="exposureV" class="small">0.65</span></div>
    <div class="row"><label>Env Intensity</label><input id="envI" type="range" min="0.2" max="1.5" step="0.01" value="0.55"><span id="envIV" class="small">0.55</span></div>
    <div class="row"><label>Roughness</label><input id="rough" type="range" min="0.1" max="0.6" step="0.01" value="0.28"><span id="roughV" class="small">0.28</span></div>
    <div class="row"><label>Clearcoat</label><input id="ccoat" type="range" min="0.0" max="1.0" step="0.01" value="0.45"><span id="ccoatV" class="small">0.45</span></div>
    <div class="row"><label>Clearcoat Rough</label><input id="ccr" type="range" min="0.05" max="0.6" step="0.01" value="0.32"><span id="ccrV" class="small">0.32</span></div>
    <hr style="border:none;border-top:1px solid rgba(255,255,255,.08);margin:6px 0">
    <div class="row"><label>Bloom Strength</label><input id="bStr" type="range" min="0.0" max="0.6" step="0.01" value="0.22"><span id="bStrV" class="small">0.22</span></div>
    <div class="row"><label>Bloom Threshold</label><input id="bTh" type="range" min="0.6" max="1.5" step="0.01" value="1.08"><span id="bThV" class="small">1.08</span></div>
    <div class="row"><label>Bloom Radius</label><input id="bRad" type="range" min="0.1" max="1.2" step="0.01" value="0.35"><span id="bRadV" class="small">0.35</span></div>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
  }
}
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

/* ----------------------- CONFIG ----------------------- */
const DPR = Math.min(window.devicePixelRatio||1, 2);
let PARTICLE_COUNT = 2400;      // will downshift if FPS is low
const CHAPTERS = 4;
const USE_ADDITIVE = false;     // never defaults to additive — safer visuals

/* ----------------------- CORE ------------------------- */
const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x040509);
scene.fog = new THREE.FogExp2(0x00000f, 0.024);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.05, 2000);
camera.position.set(8,4.5,9);

const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
renderer.setPixelRatio(DPR);
renderer.setSize(innerWidth, innerHeight);
/* Critical: softer shoulder, less “neon white” */
renderer.toneMapping = THREE.ReinhardToneMapping;
renderer.toneMappingExposure = 0.65;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.outputColorSpace = THREE.SRGBColorSpace;
container.appendChild(renderer.domElement);

/* PMREM with neutral indoor env to avoid mirror-like reflections */
const pmrem = new THREE.PMREMGenerator(renderer);
const envTex = pmrem.fromScene(new RoomEnvironment(renderer), 0.6).texture;
scene.environment = envTex;

/* Controls */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.enableZoom = false;
controls.maxPolarAngle = Math.PI * 0.495;
controls.minDistance = 1.6; controls.maxDistance = 40;

/* Post FX — Bloom set for highlight restraint */
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.22, 0.35, 1.08);
composer.addPass(bloomPass);
const bokehPass = new BokehPass(scene, camera, { focus: 19, aperture: 0.0008, maxblur: 0.008, width: innerWidth, height: innerHeight });
bokehPass.enabled = false; composer.addPass(bokehPass);
const smaaPass = new SMAAPass(innerWidth, innerHeight); composer.addPass(smaaPass);

/* Stage */
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(400,400),
  new THREE.MeshStandardMaterial({ color:0x07080a, roughness:0.92 })
);
ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

const disc = new THREE.Mesh(
  new THREE.CircleGeometry(10,64),
  new THREE.MeshStandardMaterial({ color:0x101216, roughness:0.5, metalness:0.04, transparent:true, opacity:1 })
);
disc.rotation.x = -Math.PI/2; disc.position.y = 0.001; disc.receiveShadow = true; scene.add(disc);

/* Cursor glow and safe light */
function makeGlowTex(size=256){ const c=document.createElement('canvas'); c.width=c.height=size; const x=c.getContext('2d');
  const g=x.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
  g.addColorStop(0,'rgba(255,243,217,1)'); g.addColorStop(.6,'rgba(255,243,217,.28)'); g.addColorStop(1,'rgba(255,243,217,0)');
  x.fillStyle=g; x.fillRect(0,0,size,size); const t=new THREE.CanvasTexture(c); t.minFilter=t.magFilter=THREE.LinearFilter; return t; }
const cursorLight = new THREE.PointLight(0xfff7ea, 0.0, 18, 2.0); scene.add(cursorLight);
const cursorBall = new THREE.Mesh(new THREE.SphereGeometry(0.06,16,16), new THREE.MeshBasicMaterial({ color:0xfff3d9 })); scene.add(cursorBall);
const glow = new THREE.Sprite(new THREE.SpriteMaterial({ map:makeGlowTex(512), transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, opacity:0.32 }));
glow.scale.setScalar(0.6); scene.add(glow);

/* Particle material (stable) */
const sprite = (()=>{ const c=document.createElement('canvas'); c.width=c.height=128; const x=c.getContext('2d');
  const g=x.createRadialGradient(64,64,0,64,64,64);
  g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(.6,'rgba(255,255,255,.24)'); g.addColorStop(1,'rgba(255,255,255,0)');
  x.fillStyle=g; x.fillRect(0,0,128,128); const t=new THREE.CanvasTexture(c); t.minFilter=t.magFilter=THREE.LinearFilter; return t; })();

const particleVert = `
attribute vec3 startPos; attribute vec3 targetPos; attribute float seed;
uniform float uTime; uniform float uAssemble; uniform float uSize;
varying float vMix;
void main(){
  float t = smoothstep(0.0, 1.0, uAssemble);
  vec3 wob = vec3(
    sin(uTime*0.8 + seed*6.283)*0.18,
    cos(uTime*1.07 + seed*5.123)*0.18,
    sin(uTime*1.03 + seed*3.777)*0.18
  ) * (1.0 - t);
  vec3 p = mix(startPos + wob, targetPos, t);
  vec4 mv = modelViewMatrix * vec4(p, 1.0);
  float dist = -mv.z;
  float size = uSize * mix(1.35, 0.95, t);
  gl_PointSize = size * (300.0 / max(10.0, dist));
  gl_Position = projectionMatrix * mv;
  vMix = t;
}`;
const particleFrag = `
uniform sampler2D map; uniform vec3 uGrade; uniform float uOpacity; varying float vMix;
void main(){
  vec4 tex = texture2D(map, gl_PointCoord);
  float a = tex.a * uOpacity * mix(0.75, 1.0, vMix); if (a < 0.02) discard;
  vec3 col = tex.rgb * mix(vec3(1.0), uGrade, 0.45);
  gl_FragColor = vec4(col, a);
}`;
function makeParticleMaterial(grade){
  return new THREE.ShaderMaterial({
    transparent:true, depthTest:true, depthWrite:false,
    blending: USE_ADDITIVE ? THREE.AdditiveBlending : THREE.NormalBlending,
    uniforms:{ map:{value:sprite}, uGrade:{value:grade.clone()}, uOpacity:{value: USE_ADDITIVE?0.45:0.8}, uAssemble:{value:0.0}, uTime:{value:0.0}, uSize:{value:7.0} },
    vertexShader: particleVert, fragmentShader: particleFrag
  });
}

/* Forms */
function makeForms(){
  const a=(()=>{const pts=[];for(let i=0;i<22;i++){const t=i/21;pts.push(new THREE.Vector2(0.6+Math.sin(t*Math.PI)*0.8*(0.5+0.5*t), -1+t*2.2));}
    const geo=new THREE.LatheGeometry(pts,256); return new THREE.Mesh(geo);})();
  const b=(()=>{const bowl=new THREE.SphereGeometry(2.2,128,128,0,Math.PI*2,0,Math.PI/2); bowl.scale(1,0.38,1); return new THREE.Mesh(bowl);})();
  const c=(()=>{const geo=new THREE.TorusKnotGeometry(1.0,0.25,512,64,2,3); geo.rotateX(Math.PI*0.1); return new THREE.Mesh(geo);})();
  const d=(()=>{const geo=new THREE.CylinderGeometry(0.8,0.8,3.6,128,1,true); return new THREE.Mesh(geo);})();
  const e=(()=>{const geo=new THREE.SphereGeometry(1.8,128,128,0,Math.PI*2,0,Math.PI/1.7); geo.scale(1,0.7,1); return new THREE.Mesh(geo);})();
  return [a,b,c,d,e];
}

/* Helpers */
function sampleTarget(mesh, n, scaleTo=4.4){
  const box = new THREE.Box3().setFromObject(mesh);
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  const s = scaleTo / Math.max(size.x,size.y,size.z,1e-6);
  const temp = new THREE.Mesh(mesh.geometry.clone(), new THREE.MeshBasicMaterial());
  const sampler = new MeshSurfaceSampler(temp).build();
  const pos = new Float32Array(n*3), p=new THREE.Vector3();
  for (let i=0;i<n;i++){ sampler.sample(p);
    pos[i*3]   = (p.x - center.x) * s;
    pos[i*3+1] = (p.y - center.y) * s;
    pos[i*3+2] = (p.z - center.z) * s;
  }
  return { pos, scale:s };
}
function randomCloud(n, r=6){
  const pos = new Float32Array(n*3);
  for (let i=0;i<n;i++){
    const u=Math.random(), v=Math.random(); const th=2*Math.PI*u, ph=Math.acos(2*v-1);
    const R=r*(.35+.65*Math.random());
    pos[i*3]   = R*Math.sin(ph)*Math.cos(th);
    pos[i*3+1] = R*Math.cos(ph)*0.6;
    pos[i*3+2] = R*Math.sin(ph)*Math.sin(th);
  } return pos;
}

/* Hybrid node */
class HybridPorcelain {
  constructor(def){
    this.id = def.id; this.name = def.name;
    this.bg = new THREE.Color(def.bg); this.keyColor = def.key;
    this.grade = def.grade; this.rail = def.rail;
    this.group = new THREE.Group();

    // Softer, non-flashy lights
    this.hemi = new THREE.HemisphereLight(0xddddff,0x0a0a0d,0.38); this.group.add(this.hemi);
    this.key  = new THREE.DirectionalLight(this.keyColor, 1.2); this.key.position.set(6,10,6);
    this.key.castShadow=true; this.key.shadow.mapSize.set(1024,1024); this.key.shadow.bias=-0.0005; this.group.add(this.key);
    this.fill = new THREE.DirectionalLight(0x8fb3ff,0.36); this.fill.position.set(-6,5,-6); this.group.add(this.fill);
    this.rim  = new THREE.DirectionalLight(0xffe6d0,0.42); this.rim.position.set(0,6,-8); this.group.add(this.rim);

    // Physical porcelain with restrained specular
    this.mat = new THREE.MeshPhysicalMaterial({
      color: 0xf4f6fb,
      roughness: 0.28,
      metalness: 0.0,
      clearcoat: 0.45,
      clearcoatRoughness: 0.32,
      envMap: scene.environment,
      envMapIntensity: 0.55
    });
    const s = sampleTarget(def.form, PARTICLE_COUNT);
    this.mesh = new THREE.Mesh(def.form.geometry.clone(), this.mat);
    this.mesh.scale.setScalar(s.scale); this.mesh.castShadow=this.mesh.receiveShadow=true;
    this.group.add(this.mesh);

    // Particle skin
    const geo = new THREE.BufferGeometry();
    const seeds = new Float32Array(PARTICLE_COUNT); for(let i=0;i<PARTICLE_COUNT;i++) seeds[i]=Math.random();
    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(PARTICLE_COUNT*3),3));
    geo.setAttribute('startPos', new THREE.BufferAttribute(randomCloud(PARTICLE_COUNT,6),3));
    geo.setAttribute('targetPos', new THREE.BufferAttribute(s.pos,3));
    geo.setAttribute('seed', new THREE.BufferAttribute(seeds,1));
    this.points = new THREE.Points(geo, makeParticleMaterial(this.grade));
    this.points.frustumCulled = false; this.group.add(this.points);

    this.chapter=0; this.motion=true;
  }

  enter(){
    gsap.to(scene.background, { r:this.bg.r, g:this.bg.g, b:this.bg.b, duration:0.8, ease:'sine.out' });
    [this.key,this.fill,this.rim].forEach(L => gsap.fromTo(L, { intensity:0.0 }, { intensity:L.intensity, duration:0.8, ease:'sine.out' }));

    this.mesh.material.transparent=true; this.mesh.material.opacity=0.0;
    gsap.to(this.mesh.material, { opacity:0.95, duration:0.9, ease:'power2.out' });
    gsap.fromTo(this.points.material.uniforms.uAssemble, { value:0.0 }, { value:1.0, duration:1.0, ease:'power2.out' });
    gsap.fromTo(this.points.material.uniforms.uOpacity, { value:0.0 }, { value: USE_ADDITIVE?0.45:0.8, duration:0.7 });

    // Camera rail
    if (this.rail){
      gsap.to(camera.position, { x:this.rail.position.x, y:this.rail.position.y, z:this.rail.position.z, duration:1.0, ease:'expo.inOut', onUpdate:()=>controls.update() });
      gsap.to(controls.target, { x:this.rail.target.x, y:this.rail.target.y, z:this.rail.target.z, duration:1.0, ease:'expo.inOut', onUpdate:()=>controls.update() });
    }
    // Bloom limiter during enter
    gsap.to(bloomPass, { strength: 0.22, threshold: 1.08, radius: 0.35, duration:0.6 });
  }

  exit(){
    gsap.to(this.points.material.uniforms.uOpacity, { value:0.0, duration:0.45 });
    gsap.to(this.mesh.material, { opacity:0.0, duration:0.45 });
  }

  setChapter(k){
    this.chapter = THREE.MathUtils.clamp(k, 0, CHAPTERS-1);
    const assemble = (this.chapter<=2) ? (this.chapter/2) : 1.0 - 0.15*(this.chapter-2);
    gsap.to(this.points.material.uniforms.uAssemble, { value: assemble, duration:0.5, ease:'sine.out' });
    gsap.to(this.mesh.material, { opacity: THREE.MathUtils.clamp(0.25 + 0.75*assemble, 0, 0.95), duration:0.5 });
    gsap.to(bloomPass, { strength: 0.18 + 0.18*assemble, duration:0.5 }); // gentle only
    gsap.to(disc.material, { roughness: 0.48 - 0.1*assemble, duration:0.5 });
  }

  update(dt, t){
    this.points.material.uniforms.uTime.value = t;
    if (this.motion) this.group.rotation.y += dt * 0.1;
  }
  toggleMotion(f){ this.motion=f; }
}

/* Scenes */
const forms = makeForms();
const defs = [
  { id:0, name:'Dawn Vessel',  bg:0x05050a, key:0xfff8e8, grade:new THREE.Vector3(1.05,0.95,0.90), rail:{ position:new THREE.Vector3(6,3.5,6),   target:new THREE.Vector3(0,1.1,0) }, form:forms[0] },
  { id:1, name:'Calm Mirror',  bg:0x071022, key:0xdfefff, grade:new THREE.Vector3(0.95,1.02,1.05), rail:{ position:new THREE.Vector3(5.5,2.8,5.8), target:new THREE.Vector3(0,0.85,0)}, form:forms[1] },
  { id:2, name:'Whim',         bg:0x10040a, key:0xffefe9, grade:new THREE.Vector3(1.06,0.96,1.05), rail:{ position:new THREE.Vector3(7,3.4,7),   target:new THREE.Vector3(0,0.8,0) }, form:forms[2] },
  { id:3, name:'Echo Column',  bg:0x071011, key:0xfffff6, grade:new THREE.Vector3(1.00,0.98,1.05), rail:{ position:new THREE.Vector3(6.2,3.8,6.2),target:new THREE.Vector3(0,1.4,0) }, form:forms[3] },
  { id:4, name:'Night Bloom',  bg:0x040618, key:0xe6f0ff, grade:new THREE.Vector3(0.92,0.98,1.08), rail:{ position:new THREE.Vector3(7.5,3.6,7.8),target:new THREE.Vector3(0,0.9,0) }, form:forms[4] },
];
const nodes = defs.map(d => new HybridPorcelain(d));

let sceneIndex=0, chapterIndex=0;
scene.add(nodes[0].group);
nodes[0].enter();
document.getElementById('sceneLabel').textContent = `Scene 1 / 5 — ${nodes[0].name}`;

/* Transition */
let transitioning=false;
function gotoScene(i){
  if (transitioning || i===sceneIndex || i<0 || i>=nodes.length) return;
  transitioning=true;
  const from=nodes[sceneIndex], to=nodes[i];
  if (!to.group.parent) scene.add(to.group);

  controls.enabled=false;
  gsap.to(disc.material, { opacity:0.7, duration:0.25 });

  const tl = gsap.timeline({ onComplete:()=>{
    scene.remove(from.group);
    sceneIndex=i; chapterIndex=0; to.setChapter(0);
    document.getElementById('sceneLabel').textContent = `Scene ${i+1} / 5 — ${to.name}`;
    transitioning=false; controls.enabled=true;
    gsap.to(disc.material, { opacity:1.0, duration:0.25 });
  }});
  tl.add(()=>from.exit(), 0);
  tl.add(()=>to.enter(),  0.02);
  tl.to(bloomPass, { strength: Math.min(0.24, bloomPass.strength), threshold: Math.max(1.0, bloomPass.threshold), duration:0.4 }, 0);
}

/* Input & UI */
function setChapter(delta){ chapterIndex = THREE.MathUtils.clamp(chapterIndex+delta,0,CHAPTERS-1); nodes[sceneIndex].setChapter(chapterIndex); }

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2(-10,-10);
const plane = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000), new THREE.MeshBasicMaterial({ visible:false }));
plane.rotation.x = -Math.PI/2; plane.position.y = 0; scene.add(plane);
function planeHit(){ raycaster.setFromCamera(mouse, camera); const i=raycaster.intersectObject(plane); return i.length?i[0].point.clone():null; }

renderer.domElement.addEventListener('mousemove', (e)=>{
  const r=renderer.domElement.getBoundingClientRect();
  mouse.x=((e.clientX-r.left)/r.width)*2-1; mouse.y=-((e.clientY-r.top)/r.height)*2+1;
}, { passive:true });

/* Smooth zoom with chapter staging */
let scrollTarget = camera.position.distanceTo(controls.target);
let accum = 0;
renderer.domElement.addEventListener('wheel', (e)=>{
  e.preventDefault();
  scrollTarget += e.deltaY * 0.003 * 6;
  scrollTarget = THREE.MathUtils.clamp(scrollTarget, controls.minDistance, controls.maxDistance);
  accum += e.deltaY;
  if (Math.abs(accum) > 120){ setChapter(accum>0 ? +1 : -1); accum=0; }
}, { passive:false });

window.addEventListener('keydown', (e)=>{
  const typing = document.activeElement && (['INPUT','TEXTAREA'].includes(document.activeElement.tagName) || document.activeElement.isContentEditable);
  if (typing) return;
  if (e.code==='ArrowRight'){ e.preventDefault(); gotoScene((sceneIndex+1)%nodes.length); }
  if (e.code==='ArrowLeft'){  e.preventDefault(); gotoScene((sceneIndex-1+nodes.length)%nodes.length); }
  if (e.code==='Space'){      e.preventDefault(); nodes.forEach(n=>n.toggleMotion(!n.motion)); }
}, { passive:false });

/* Checkboxes */
document.getElementById('toggleBloom').addEventListener('change', e=>{ bloomPass.enabled = e.target.checked; });
document.getElementById('toggleDOF').addEventListener('change', e=>{ bokehPass.enabled = e.target.checked; });
document.getElementById('toggleParticles').addEventListener('change', e=>{ nodes.forEach(n=> n.points.visible = e.target.checked ); });

/* Live debug bindings */
function bind(id, cb){ const el=document.getElementById(id), v=document.getElementById(id+'V'); const f=()=>{ cb(+el.value); if(v) v.textContent=el.value; }; el.addEventListener('input', f); f(); }
bind('exposure', v=> renderer.toneMappingExposure = v );
bind('envI', v=> nodes.forEach(n=>{ n.mat.envMapIntensity=v; }) );
bind('rough', v=> nodes.forEach(n=>{ n.mat.roughness=v; }) );
bind('ccoat', v=> nodes.forEach(n=>{ n.mat.clearcoat=v; }) );
bind('ccr',   v=> nodes.forEach(n=>{ n.mat.clearcoatRoughness=v; }) );
bind('bStr',  v=> bloomPass.strength=v );
bind('bTh',   v=> bloomPass.threshold=v );
bind('bRad',  v=> bloomPass.radius=v );

/* Loop */
const clock = new THREE.Clock();
function animate(){
  const dt=Math.min(0.05, clock.getDelta()), t=clock.getElapsedTime();

  // Smooth zoom
  const dir=new THREE.Vector3(); camera.getWorldDirection(dir);
  const desired=THREE.MathUtils.lerp(camera.position.distanceTo(controls.target), scrollTarget, 0.06);
  const clamped=THREE.MathUtils.clamp(desired, controls.minDistance, controls.maxDistance);
  const to=new THREE.Vector3().copy(dir).multiplyScalar(-clamped).add(controls.target);
  camera.position.lerp(to, 0.08);

  // Cursor glow (capped)
  const p=planeHit();
  if (p){
    const d=camera.position.distanceTo(p);
    const f=THREE.MathUtils.clamp(6.0/Math.max(0.001,d), 0.0, 1.0);
    const inten=0.14*f;
    cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, inten, 0.12);
    cursorLight.position.lerp(p, 0.18);
    cursorBall.position.lerp(p, 0.18);
    glow.position.lerp(new THREE.Vector3().copy(p).add(new THREE.Vector3().subVectors(camera.position,p).setLength(0.06)), 0.18);
    glow.material.opacity = THREE.MathUtils.lerp(glow.material.opacity, 0.3*f, 0.12);
    const s=THREE.MathUtils.lerp(glow.scale.x, 0.26 + 0.9*f, 0.12); glow.scale.setScalar(s);
  }else{
    cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, 0.0, 0.06);
    glow.material.opacity = THREE.MathUtils.lerp(glow.material.opacity, 0.0, 0.05);
  }

  nodes[sceneIndex].update(dt, t);
  controls.update();
  composer.render();
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* Resize */
function resize(){
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight);
  try { if (bokehPass.materialBokeh?.uniforms?.aspect) bokehPass.materialBokeh.uniforms.aspect.value=camera.aspect; smaaPass.setSize(innerWidth, innerHeight);} catch{}
}
addEventListener('resize', resize);

/* FPS guard: if <45 fps after 3s, cut particle count by ~30% and rebuild skins */
setTimeout(()=>{
  const measureStart=performance.now(); let frames=0;
  function measure(){
    frames++; if (performance.now()-measureStart<1000) requestAnimationFrame(measure);
    else {
      const fps = frames/((performance.now()-measureStart)/1000);
      if (fps<45 && PARTICLE_COUNT>1500){
        PARTICLE_COUNT = Math.floor(PARTICLE_COUNT*0.7);
        nodes.forEach((n,idx)=>{
          scene.remove(n.group);
        });
        // rebuild nodes with lower count
        nodes.length = 0;
        defs.forEach(d=> nodes.push(new HybridPorcelain(d)));
        scene.add(nodes[sceneIndex].group);
        nodes[sceneIndex].enter();
      }
    }
  }
  requestAnimationFrame(measure);
}, 3000);

/* Expose */
window.__porcelain = { nodes, gotoScene, setChapter:(k)=>nodes[sceneIndex].setChapter(k), scene, renderer, composer, bloomPass };
</script>
</body>
</html>
