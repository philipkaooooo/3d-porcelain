<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Porcelain Transcendence — Cinematic Five Scenes v2</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body,#container{height:100%;width:100%}
    body{background:#000;color:#fff;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;overflow:hidden}
    #container{position:fixed;inset:0}
    canvas{display:block;touch-action:none}
    .ui{position:absolute;inset:0;pointer-events:none;z-index:10}
    .panel{position:absolute;pointer-events:auto;background:rgba(0,0,0,.45);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.08);padding:8px 10px;border-radius:10px;font-size:13px;line-height:1.35}
    .top-left{left:12px;top:12px}
    .top-right{right:12px;top:12px;text-align:right}
    .bottom-left{left:12px;bottom:12px}
    .scene-ind{font-weight:600}
    .small{font-size:12px;opacity:.82}
  </style>
</head>
<body>
<div id="container" role="application" aria-label="Porcelain canvas"></div>
<div class="ui">
  <div class="panel top-left">
    <div id="sceneLabel" class="scene-ind">Scene 1 / 5 — Dawn Vessel</div>
    <div class="small">← → change scene • SCROLL chapters (0–3) • SPACE pause</div>
  </div>
  <div class="panel top-right">
    <label><input id="toggleBloom" type="checkbox" checked> Bloom</label><br/>
    <label><input id="toggleDOF" type="checkbox"> DOF</label><br/>
    <label><input id="toggleParticles" type="checkbox" checked> Particles</label>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
  }
}
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

/* ------------------------------------------------------
   VISUAL INTENT
   - Brighter, readable center with gentle mystery
   - Smooth, layered transitions (camera, light, post, particles)
   - Each scene adds moving compositional helpers (orbs, halo, dust)
   ------------------------------------------------------ */

/* ----------------------- CORE ------------------------- */
const DPR = Math.min(window.devicePixelRatio||1, 2);
let PARTICLE_COUNT = 2600; // guarded later if slow
const CHAPTERS = 4;

const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x06070b);
scene.fog = new THREE.FogExp2(0x0a0c12, 0.02);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.05, 2000);
camera.position.set(7.8,4.2,8.6);

const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
renderer.setPixelRatio(DPR);
renderer.setSize(innerWidth, innerHeight);
renderer.toneMapping = THREE.ReinhardToneMapping;
renderer.toneMappingExposure = 0.78; // brighter but controlled
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.outputColorSpace = THREE.SRGBColorSpace;
container.appendChild(renderer.domElement);

// Neutral indoor env to avoid chrome-like reflections
const pmrem = new THREE.PMREMGenerator(renderer);
const envTex = pmrem.fromScene(new RoomEnvironment(renderer), 0.6).texture;
scene.environment = envTex;

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.enableZoom = false; controls.maxPolarAngle = Math.PI*0.495;
controls.minDistance = 1.6; controls.maxDistance = 40;

/* ----------------------- STAGE ------------------------ */
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(420,420),
  new THREE.MeshStandardMaterial({ color:0x0b0d14, roughness:0.94 })
);
ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

const disc = new THREE.Mesh(
  new THREE.CircleGeometry(11, 64),
  new THREE.MeshStandardMaterial({ color:0x161a24, roughness:0.52, metalness:0.05, transparent:true, opacity:1 })
);
disc.rotation.x = -Math.PI/2; disc.position.y = 0.001; disc.receiveShadow = true; scene.add(disc);

// Center halo — subtle radial plane (composition aid)
function makeHaloTex(size=512){
  const c=document.createElement('canvas'); c.width=c.height=size; const x=c.getContext('2d');
  const g=x.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
  g.addColorStop(0,'rgba(255,255,255,0.12)');
  g.addColorStop(0.6,'rgba(220,235,255,0.06)');
  g.addColorStop(1,'rgba(255,255,255,0)'); x.fillStyle=g; x.fillRect(0,0,size,size);
  const t=new THREE.CanvasTexture(c); t.minFilter=t.magFilter=THREE.LinearFilter; return t;
}
const halo = new THREE.Mesh(new THREE.PlaneGeometry(18,18), new THREE.MeshBasicMaterial({map:makeHaloTex(1024), transparent:true, depthWrite:false}));
halo.rotation.x = -Math.PI/2; halo.position.y = 0.002; scene.add(halo);

/* --------------------- POST FX ------------------------ */
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

// Bloom — highlight restraint but present
const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.26, 0.42, 1.06);
composer.addPass(bloomPass);

// Gentle vignette to hold edges and frame the center
const VignetteShader = {
  uniforms: { tDiffuse:{value:null}, boost:{value:0.12}, reduction:{value:0.85} },
  vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);} `,
  fragmentShader:`varying vec2 vUv; uniform sampler2D tDiffuse; uniform float boost; uniform float reduction; void main(){ vec4 c=texture2D(tDiffuse,vUv); float d=distance(vUv, vec2(0.5)); float v=smoothstep(reduction,1.2,d); c.rgb *= (1.0 - v*boost); gl_FragColor=c; }`
};
const vignette = new ShaderPass(VignetteShader); composer.addPass(vignette);

const bokehPass = new BokehPass(scene, camera, { focus: 18.5, aperture: 0.0008, maxblur: 0.0075, width: innerWidth, height: innerHeight });
bokehPass.enabled = false; composer.addPass(bokehPass);

const smaaPass = new SMAAPass(innerWidth, innerHeight); composer.addPass(smaaPass);

/* ---------------- COMPOSITION HELPERS ----------------- */
// Cursor glow (soft, capped)
function makeGlowTex(size=256){ const c=document.createElement('canvas'); c.width=c.height=size; const x=c.getContext('2d');
  const g=x.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
  g.addColorStop(0,'rgba(255,243,217,1)'); g.addColorStop(.6,'rgba(255,243,217,.28)'); g.addColorStop(1,'rgba(255,243,217,0)');
  x.fillStyle=g; x.fillRect(0,0,size,size); const t=new THREE.CanvasTexture(c); t.minFilter=t.magFilter=THREE.LinearFilter; return t; }
const cursorLight = new THREE.PointLight(0xfff7ea, 0.0, 18, 2.0); scene.add(cursorLight);
const cursorBall = new THREE.Mesh(new THREE.SphereGeometry(0.06,16,16), new THREE.MeshBasicMaterial({ color:0xfff3d9 })); scene.add(cursorBall);
const glow = new THREE.Sprite(new THREE.SpriteMaterial({ map:makeGlowTex(512), transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, opacity:0.26 }));
glow.scale.setScalar(0.55); scene.add(glow);

// Light orbs (subtle movers around the focal object)
function makeLightOrbs(){
  const g=new THREE.SphereGeometry(0.05,12,12);
  const m=new THREE.MeshBasicMaterial({ color:0xffffff });
  const group=new THREE.Group();
  for(let i=0;i<6;i++){ const s=new THREE.Mesh(g,m.clone()); s.material.transparent=true; s.material.opacity=0.55; group.add(s); }
  group.userData={t:0};
  group.tick=(dt)=>{
    group.userData.t+=dt; const t=group.userData.t;
    group.children.forEach((s,idx)=>{
      const ph=t*0.6 + idx*1.047; // offset
      const r=2.6 + 0.35*Math.sin(t*0.7+idx);
      s.position.set(Math.cos(ph)*r, 0.8+0.35*Math.sin(t*1.3+idx*0.7), Math.sin(ph)*r);
    });
  };
  return group;
}
const orbs = makeLightOrbs(); scene.add(orbs);

/* ---------------- PARTICLE SKIN ----------------------- */
const USE_ADDITIVE = false; // safer by default
const spriteTex = (()=>{ const c=document.createElement('canvas'); c.width=c.height=128; const x=c.getContext('2d');
  const g=x.createRadialGradient(64,64,0,64,64,64);
  g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(.6,'rgba(255,255,255,.25)'); g.addColorStop(1,'rgba(255,255,255,0)');
  x.fillStyle=g; x.fillRect(0,0,128,128); const t=new THREE.CanvasTexture(c); t.minFilter=t.magFilter=THREE.LinearFilter; return t; })();

const particleVert = `
attribute vec3 startPos; attribute vec3 targetPos; attribute float seed;
uniform float uTime; uniform float uAssemble; uniform float uSize;
varying float vMix; varying float vSeed;
void main(){
  float t = smoothstep(0.0, 1.0, uAssemble);
  vec3 wob = vec3(
    sin(uTime*0.8 + seed*6.283)*0.18,
    cos(uTime*1.07 + seed*5.123)*0.18,
    sin(uTime*1.03 + seed*3.777)*0.18
  ) * (1.0 - t);
  vec3 p = mix(startPos + wob, targetPos, t);
  vec4 mv = modelViewMatrix * vec4(p, 1.0);
  float dist = -mv.z;
  float size = uSize * mix(1.35, 0.95, t);
  gl_PointSize = size * (300.0 / max(10.0, dist));
  gl_Position = projectionMatrix * mv;
  vMix = t; vSeed = seed;
}`;
const particleFrag = `
uniform sampler2D map; uniform vec3 uGrade; uniform float uOpacity; varying float vMix; varying float vSeed;
void main(){
  vec4 tex = texture2D(map, gl_PointCoord);
  float a = tex.a * uOpacity * mix(0.7, 1.0, vMix);
  if (a < 0.02) discard;
  vec3 col = tex.rgb * mix(vec3(1.0), uGrade, 0.42);
  gl_FragColor = vec4(col, a);
}`;
function makeParticleMaterial(grade){
  return new THREE.ShaderMaterial({
    transparent:true, depthTest:true, depthWrite:false,
    blending: USE_ADDITIVE ? THREE.AdditiveBlending : THREE.NormalBlending,
    uniforms:{ map:{value:spriteTex}, uGrade:{value:grade.clone()}, uOpacity:{value: USE_ADDITIVE?0.42:0.85}, uAssemble:{value:0.0}, uTime:{value:0.0}, uSize:{value:7.0} },
    vertexShader: particleVert, fragmentShader: particleFrag
  });
}

function randomCloud(n, r=6){ const pos=new Float32Array(n*3); for(let i=0;i<n;i++){ const u=Math.random(), v=Math.random(); const th=2*Math.PI*u, ph=Math.acos(2*v-1); const R=r*(.35+.65*Math.random()); pos[i*3]=R*Math.sin(ph)*Math.cos(th); pos[i*3+1]=R*Math.cos(ph)*0.6; pos[i*3+2]=R*Math.sin(ph)*Math.sin(th);} return pos; }

function sampleTarget(mesh, n, scaleTo=4.6){
  const box = new THREE.Box3().setFromObject(mesh); const center=box.getCenter(new THREE.Vector3()); const size=box.getSize(new THREE.Vector3());
  const s = scaleTo / Math.max(size.x,size.y,size.z,1e-6);
  const temp = new THREE.Mesh(mesh.geometry.clone(), new THREE.MeshBasicMaterial());
  const sampler = new MeshSurfaceSampler(temp).build();
  const pos = new Float32Array(n*3), p=new THREE.Vector3();
  for (let i=0;i<n;i++){ sampler.sample(p); pos[i*3]=(p.x-center.x)*s; pos[i*3+1]=(p.y-center.y)*s; pos[i*3+2]=(p.z-center.z)*s; }
  return { pos, scale:s };
}

/* -------------------- FORMS --------------------------- */
function makeForms(){
  const A=(()=>{const pts=[];for(let i=0;i<22;i++){const t=i/21;pts.push(new THREE.Vector2(0.6+Math.sin(t*Math.PI)*0.8*(0.5+0.5*t), -1+t*2.2));} const geo=new THREE.LatheGeometry(pts,256); return new THREE.Mesh(geo);})();
  const B=(()=>{const bowl=new THREE.SphereGeometry(2.2,128,128,0,Math.PI*2,0,Math.PI/2); bowl.scale(1,0.38,1); return new THREE.Mesh(bowl);})();
  const C=(()=>{const geo=new THREE.TorusKnotGeometry(1.0,0.25,512,64,2,3); geo.rotateX(Math.PI*0.1); return new THREE.Mesh(geo);})();
  const D=(()=>{const geo=new THREE.CylinderGeometry(0.8,0.8,3.6,128,1,true); return new THREE.Mesh(geo);})();
  const E=(()=>{const geo=new THREE.SphereGeometry(1.8,128,128,0,Math.PI*2,0,Math.PI/1.7); geo.scale(1,0.7,1); return new THREE.Mesh(geo);})();
  return [A,B,C,D,E];
}
const forms = makeForms();

/* ------------------ HYBRID NODE ----------------------- */
class HybridNode {
  constructor(def){
    this.id=def.id; this.name=def.name; this.bg=new THREE.Color(def.bg); this.keyColor=def.key; this.grade=def.grade; this.rail=def.rail;
    this.group=new THREE.Group();

    // Lights — restrained yet bright at center
    this.hemi = new THREE.HemisphereLight(0xE6EEFF, 0x0a0b0e, 0.38); this.group.add(this.hemi);
    this.key  = new THREE.DirectionalLight(this.keyColor, 1.25); this.key.position.set(6,9.5,6); this.key.castShadow=true; this.key.shadow.mapSize.set(1024,1024); this.key.shadow.bias=-0.0005; this.group.add(this.key);
    this.fill = new THREE.DirectionalLight(0x9fb9ff, 0.38); this.fill.position.set(-6,5,-6); this.group.add(this.fill);
    this.rim  = new THREE.DirectionalLight(0xffecd8, 0.44); this.rim.position.set(0,6.2,-8); this.group.add(this.rim);

    // Center spotlight to lift clarity (soft penumbra)
    this.spot = new THREE.SpotLight(0xffffff, 0.55, 0, Math.PI/5, 0.6, 1.2);
    this.spot.position.set(0, 7.5, 0); this.spot.target.position.set(0,1.0,0); this.spot.castShadow=true;
    this.group.add(this.spot); this.group.add(this.spot.target);

    // Physical porcelain
    this.mat = new THREE.MeshPhysicalMaterial({
      color: 0xf4f7fb, roughness: 0.22, metalness: 0.0,
      clearcoat: 0.5, clearcoatRoughness: 0.28,
      envMap: scene.environment, envMapIntensity: 0.68
    });

    const s = sampleTarget(def.form, PARTICLE_COUNT);
    this.mesh = new THREE.Mesh(def.form.geometry.clone(), this.mat);
    this.mesh.scale.setScalar(s.scale); this.mesh.castShadow=this.mesh.receiveShadow=true; this.group.add(this.mesh);

    // Particle skin
    const geo=new THREE.BufferGeometry();
    const seeds=new Float32Array(PARTICLE_COUNT); for(let i=0;i<PARTICLE_COUNT;i++) seeds[i]=Math.random();
    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(PARTICLE_COUNT*3),3));
    geo.setAttribute('startPos', new THREE.BufferAttribute(randomCloud(PARTICLE_COUNT,6),3));
    geo.setAttribute('targetPos', new THREE.BufferAttribute(s.pos,3));
    geo.setAttribute('seed', new THREE.BufferAttribute(seeds,1));
    this.points=new THREE.Points(geo, makeParticleMaterial(this.grade)); this.points.frustumCulled=false; this.group.add(this.points);

    // Dust field (thin shell) — supports composition movement
    const dust = new THREE.Points(
      new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(randomCloud(1200,11),3)),
      new THREE.PointsMaterial({ size:0.03, color:0xffffff, transparent:true, opacity:0.14, depthWrite:false })
    );
    this.group.add(dust); this.dust=dust;

    this.chapter=0; this.motion=true; this.t=0;
  }

  enter(){
    gsap.to(scene.background, { r:this.bg.r, g:this.bg.g, b:this.bg.b, duration:0.9, ease:'sine.out' });
    [this.key,this.fill,this.rim,this.spot].forEach(L=> gsap.fromTo(L,{ intensity:0.0 },{ intensity:L.intensity, duration:0.9, ease:'power2.out' }));

    this.mesh.material.transparent=true; this.mesh.material.opacity=0.0;
    gsap.to(this.mesh.material, { opacity:0.98, duration:1.0, ease:'power2.out' });
    gsap.fromTo(this.points.material.uniforms.uAssemble, { value:0.0 }, { value:1.0, duration:1.1, ease:'power2.out' });
    gsap.fromTo(this.points.material.uniforms.uOpacity, { value:0.0 }, { value:0.85, duration:0.8 });

    // Camera rail
    if (this.rail){
      gsap.to(camera.position, { x:this.rail.position.x, y:this.rail.position.y, z:this.rail.position.z, duration:1.2, ease:'expo.inOut', onUpdate:()=>controls.update() });
      gsap.to(controls.target, { x:this.rail.target.x, y:this.rail.target.y, z:this.rail.target.z, duration:1.2, ease:'expo.inOut', onUpdate:()=>controls.update() });
    }
    // Bloom ramp for clarity, not glare
    gsap.to(bloomPass, { strength:0.28, threshold:1.06, radius:0.42, duration:0.7 });
  }

  exit(){
    gsap.to(this.points.material.uniforms.uOpacity, { value:0.0, duration:0.45 });
    gsap.to(this.mesh.material, { opacity:0.0, duration:0.45 });
  }

  setChapter(k){
    this.chapter = THREE.MathUtils.clamp(k, 0, CHAPTERS-1);
    const assemble = (this.chapter<=2) ? (this.chapter/2) : 1.0 - 0.18*(this.chapter-2);
    gsap.to(this.points.material.uniforms.uAssemble, { value: assemble, duration:0.55, ease:'sine.out' });
    gsap.to(this.mesh.material, { opacity: THREE.MathUtils.clamp(0.3 + 0.7*assemble, 0, 1.0), duration:0.55 });
    gsap.to(bloomPass, { strength: 0.2 + 0.18*assemble, duration:0.55 });
    gsap.to(disc.material, { opacity: 0.9 - 0.2*assemble, duration:0.55 });
  }

  update(dt, t){
    this.t += dt;
    this.points.material.uniforms.uTime.value = t;
    if (this.motion) this.group.rotation.y += dt * 0.1;
    // Move rim light slowly around object to add living highlights
    const ang = t*0.25; this.rim.position.set(Math.sin(ang)*6, 5.8, Math.cos(ang)*-7.5);
    // Breathe halo
    const hl = 0.52 + 0.06*Math.sin(t*0.7 + this.id);
    halo.material.opacity = hl;
  }
  toggleMotion(f){ this.motion=f; }
}

/* ------------------- SCENES --------------------------- */
const defs = [
  { id:0, name:'Dawn Vessel', bg:0x0a0c12, key:0xfff8e8, grade:new THREE.Vector3(1.05,0.95,0.90), rail:{ position:new THREE.Vector3(6,3.5,6),   target:new THREE.Vector3(0,1.1,0) }, form:forms[0] },
  { id:1, name:'Calm Mirror', bg:0x0b1426, key:0xdfefff, grade:new THREE.Vector3(0.95,1.02,1.05), rail:{ position:new THREE.Vector3(5.5,2.8,5.8), target:new THREE.Vector3(0,0.85,0)}, form:forms[1] },
  { id:2, name:'Whim',        bg:0x14060c, key:0xffefe9, grade:new THREE.Vector3(1.06,0.96,1.05), rail:{ position:new THREE.Vector3(7,3.4,7),   target:new THREE.Vector3(0,0.8,0) }, form:forms[2] },
  { id:3, name:'Echo Column', bg:0x0a1214, key:0xfffff6, grade:new THREE.Vector3(1.00,0.98,1.05), rail:{ position:new THREE.Vector3(6.2,3.8,6.2),target:new THREE.Vector3(0,1.4,0) }, form:forms[3] },
  { id:4, name:'Night Bloom', bg:0x070a1a, key:0xe6f0ff, grade:new THREE.Vector3(0.92,0.98,1.08), rail:{ position:new THREE.Vector3(7.5,3.6,7.8),target:new THREE.Vector3(0,0.9,0) }, form:forms[4] }
];
const nodes = defs.map(d=> new HybridNode(d));
let sceneIndex=0, chapterIndex=0;
scene.add(nodes[0].group); nodes[0].enter();
const sceneLabel = document.getElementById('sceneLabel');
sceneLabel.textContent = `Scene 1 / 5 — ${nodes[0].name}`;

/* ------------------- TRANSITIONS ---------------------- */
let transitioning=false;
function gotoScene(i){
  if (transitioning||i===sceneIndex||i<0||i>=nodes.length) return;
  transitioning = true;
  const from=nodes[sceneIndex], to=nodes[i];
  if (!to.group.parent) scene.add(to.group);

  controls.enabled=false; gsap.to(disc.material, { opacity:0.7, duration:0.25 });

  // Dolly path: mid anchor between current/next for graceful arc
  const a = camera.position.clone();
  const b = to.rail.position.clone();
  const mid = a.clone().lerp(b, 0.5).add(new THREE.Vector3(0, 0.6, 0));

  const tl = gsap.timeline({ onComplete:()=>{
    scene.remove(from.group);
    sceneIndex=i; chapterIndex=0; to.setChapter(0);
    sceneLabel.textContent = `Scene ${i+1} / 5 — ${to.name}`;
    transitioning=false; controls.enabled=true; gsap.to(disc.material, { opacity:1.0, duration:0.25 });
  }});

  tl.add(()=>from.exit(), 0);
  tl.add(()=>to.enter(),  0.02);

  // Camera along quadratic Bezier (a->mid->b)
  tl.to({t:0}, { t:1, duration:1.25, ease:'expo.inOut', onUpdate:function(){
    const t=this.targets()[0].t; // Bezier interpolation
    const p1=a.clone().multiplyScalar((1-t)*(1-t));
    const p2=mid.clone().multiplyScalar(2*(1-t)*t);
    const p3=b.clone().multiplyScalar(t*t);
    const p=p1.add(p2).add(p3);
    camera.position.copy(p);
    controls.update();
  }}, 0);
  tl.to(controls.target, { x:to.rail.target.x, y:to.rail.target.y, z:to.rail.target.z, duration:1.25, ease:'expo.inOut', onUpdate:()=>controls.update() }, 0);

  // Post stack morph
  tl.to(bloomPass, { strength: Math.min(0.3,bloomPass.strength), threshold: Math.max(1.02,bloomPass.threshold), radius: 0.42, duration:0.6 }, 0);
}

/* ------------------- INPUT & UI ----------------------- */
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2(-10,-10);
const plane=new THREE.Mesh(new THREE.PlaneGeometry(1000,1000), new THREE.MeshBasicMaterial({visible:false}));
plane.rotation.x=-Math.PI/2; plane.position.y=0; scene.add(plane);
function planeHit(){ raycaster.setFromCamera(mouse, camera); const i=raycaster.intersectObject(plane); return i.length?i[0].point.clone():null; }

renderer.domElement.addEventListener('mousemove', (e)=>{
  const r=renderer.domElement.getBoundingClientRect();
  mouse.x=((e.clientX-r.left)/r.width)*2-1; mouse.y=-((e.clientY-r.top)/r.height)*2+1;
}, { passive:true });

let scrollTarget = camera.position.distanceTo(controls.target); let accum=0;
renderer.domElement.addEventListener('wheel', (e)=>{
  e.preventDefault();
  scrollTarget += e.deltaY * 0.003 * 6; scrollTarget = THREE.MathUtils.clamp(scrollTarget, controls.minDistance, controls.maxDistance);
  accum += e.deltaY; if (Math.abs(accum)>120){ chapterIndex = THREE.MathUtils.clamp(chapterIndex + (accum>0?1:-1), 0, CHAPTERS-1); nodes[sceneIndex].setChapter(chapterIndex); accum=0; }
}, { passive:false });

window.addEventListener('keydown', (e)=>{
  const typing=document.activeElement && (['INPUT','TEXTAREA'].includes(document.activeElement.tagName) || document.activeElement.isContentEditable);
  if (typing) return;
  if (e.code==='ArrowRight'){ e.preventDefault(); gotoScene((sceneIndex+1)%nodes.length); }
  if (e.code==='ArrowLeft'){  e.preventDefault(); gotoScene((sceneIndex-1+nodes.length)%nodes.length); }
  if (e.code==='Space'){      e.preventDefault(); nodes.forEach(n=>n.toggleMotion(!n.motion)); }
}, { passive:false });

// UI toggles
document.getElementById('toggleBloom').addEventListener('change', e=> bloomPass.enabled = e.target.checked );
document.getElementById('toggleDOF').addEventListener('change',  e=> bokehPass.enabled = e.target.checked );
document.getElementById('toggleParticles').addEventListener('change', e=> nodes.forEach(n=> n.points.visible = e.target.checked ) );

/* ------------------- LOOP ----------------------------- */
const clock=new THREE.Clock();
function animate(){
  const dt=Math.min(0.05, clock.getDelta()), t=clock.getElapsedTime();

  // Smooth zoom
  const dir=new THREE.Vector3(); camera.getWorldDirection(dir);
  const desired=THREE.MathUtils.lerp(camera.position.distanceTo(controls.target), scrollTarget, 0.06);
  const clamped=THREE.MathUtils.clamp(desired, controls.minDistance, controls.maxDistance);
  const to=new THREE.Vector3().copy(dir).multiplyScalar(-clamped).add(controls.target);
  camera.position.lerp(to, 0.08);

  // Cursor glow
  const p=planeHit();
  if (p){
    const d=camera.position.distanceTo(p); const f=THREE.MathUtils.clamp(6.0/Math.max(0.001,d), 0.0, 1.0);
    cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, 0.16*f, 0.12);
    cursorLight.position.lerp(p, 0.18); cursorBall.position.lerp(p, 0.18);
    glow.position.lerp(new THREE.Vector3().copy(p).add(new THREE.Vector3().subVectors(camera.position,p).setLength(0.06)), 0.18);
    glow.material.opacity = THREE.MathUtils.lerp(glow.material.opacity, 0.26*f, 0.12);
    const s=THREE.MathUtils.lerp(glow.scale.x, 0.24 + 0.9*f, 0.12); glow.scale.setScalar(s);
  } else {
    cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, 0.0, 0.06);
    glow.material.opacity = THREE.MathUtils.lerp(glow.material.opacity, 0.0, 0.05);
  }

  // Compositional movers
  orbs.tick(dt);

  nodes[sceneIndex].update(dt, t);
  controls.update();
  composer.render();
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* ------------------- RESIZE & PERF -------------------- */
function resize(){
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight);
  try { if (bokehPass.materialBokeh?.uniforms?.aspect) bokehPass.materialBokeh.uniforms.aspect.value=camera.aspect; smaaPass.setSize(innerWidth, innerHeight);} catch{}
}
addEventListener('resize', resize);

// FPS guard: if <45 fps after 3s, reduce particles and rebuild quickly
setTimeout(()=>{
  const start=performance.now(); let frames=0; function measure(){ frames++; if (performance.now()-start<1000) requestAnimationFrame(measure); else{
    const fps = frames/((performance.now()-start)/1000);
    if (fps<45 && PARTICLE_COUNT>1600){
      PARTICLE_COUNT = Math.floor(PARTICLE_COUNT*0.7);
      // Rebuild nodes with lower count
      const current = sceneIndex; nodes.forEach(n=> scene.remove(n.group));
      for (let i=0;i<nodes.length;i++){ nodes[i]=new HybridNode(defs[i]); }
      scene.add(nodes[current].group); nodes[current].enter(); sceneIndex=current; chapterIndex=0;
    }
  }} requestAnimationFrame(measure);
}, 3000);

// Expose helpers
window.__porcelain = { nodes, gotoScene, setChapter:(k)=>nodes[sceneIndex].setChapter(k), scene, renderer, composer, bloomPass };
</script>
</body>
</html>
