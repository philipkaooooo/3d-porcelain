<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Porcelain Transcendence — Five Scenes Engine (v9)</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body, #container { height: 100%; width: 100%; }
    body { background: #000; color: #fff; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; overflow: hidden; }
    #container { position: fixed; inset: 0; }
    canvas { display: block; touch-action: none; }
    .ui { position: absolute; z-index: 60; inset: 0; pointer-events: none; }
    .panel { pointer-events: auto; position: absolute; background: rgba(0,0,0,0.45); backdrop-filter: blur(6px); border: 1px solid rgba(255,255,255,0.05); padding: 10px 12px; border-radius: 10px; font-size: 13px; line-height: 1.4; }
    .top-left { left: 16px; top: 16px; }
    .top-right { right: 16px; top: 16px; text-align: right; }
    .bottom-left { left: 16px; bottom: 16px; }
    .scene-indicator { font-weight: 600; opacity: 0.95; }
    .small { font-size: 12px; opacity: 0.8; }
    .btn { cursor: pointer; }
  </style>
</head>
<body>
  <div id="container" role="application" aria-label="Porcelain Transcendence canvas"></div>

  <div class="ui" aria-hidden="false">
    <div class="panel top-left" role="region" aria-label="Scene information">
      <div id="sceneLabel" class="scene-indicator" role="status" aria-live="polite">Scene 1 / 5 — Dawn Vessel</div>
      <div class="small">← → : Change Scene • SPACE : Toggle Motion • Click : Reactive Pulse</div>
    </div>

    <div class="panel top-right" role="region" aria-label="Effects toggles">
      <label><input id="toggleBloom" type="checkbox" checked> Bloom</label><br>
      <label><input id="toggleDOF" type="checkbox"> DOF</label><br>
      <label><input id="toggleParticles" type="checkbox" checked> Particles</label><br>
      <label><input id="toggleAudio" type="checkbox"> Audio Reactive</label><br>
      <button id="fsBtn" class="btn">Fullscreen</button>
    </div>

    <div class="panel bottom-left" role="region" aria-label="Controls">
      <div class="small">DRAG: Orbit • PINCH: Zoom • SCROLL: Stage Chapters</div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
    }
  }
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <script type="module">
  // v9: Keeps distinctive features; adds cinematic scene build-ups where particles assemble into porcelain via surface sampling.
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
  import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
  import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

  // ---------- Constants & helpers ----------
  const container = document.getElementById('container');
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  const WIDTH = () => window.innerWidth;
  const HEIGHT = () => window.innerHeight;

  // ---------- Scene / Camera / Renderer ----------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  scene.fog = new THREE.FogExp2(0x000010, 0.035);

  const camera = new THREE.PerspectiveCamera(45, WIDTH()/HEIGHT(), 0.05, 2000);
  camera.position.set(8, 4.5, 9);

  const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
  renderer.setPixelRatio(DPR);
  renderer.setSize(WIDTH(), HEIGHT());
  if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace; else renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 0.9;
  renderer.physicallyCorrectLights = true;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  // Controls
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.08;
  controls.maxPolarAngle = Math.PI * 0.495;
  controls.enableZoom = false; // custom smooth zoom
  controls.minDistance = 1.6; controls.maxDistance = 40;

  // ---------- Post FX ----------
  const composer = new EffectComposer(renderer);
  composer.setSize(WIDTH(), HEIGHT());
  composer.setPixelRatio(DPR);
  composer.addPass(new RenderPass(scene, camera));
  const bloomPass = new UnrealBloomPass(new THREE.Vector2(WIDTH(), HEIGHT()), 0.55, 0.6, 0.85);
  composer.addPass(bloomPass);
  const bokehPass = new BokehPass(scene, camera, { focus: 20.0, aperture: 0.0009, maxblur: 0.01, width: WIDTH(), height: HEIGHT() });
  bokehPass.enabled = false; composer.addPass(bokehPass);
  const smaaPass = new SMAAPass(WIDTH(), HEIGHT()); composer.addPass(smaaPass);

  // ---------- Environment (PMREM) ----------
  let pmrem = new THREE.PMREMGenerator(renderer); pmrem.compileEquirectangularShader();
  let currentEnv = null;
  function assignEnvironment(envTex){ if (currentEnv && currentEnv.dispose) { try{ currentEnv.dispose(); }catch(e){} } currentEnv = envTex; scene.environment = currentEnv; }
  // Quick placeholder env
  (function bakePlaceholder(){ const urls = new Array(6).fill('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==');
    const tmp = new THREE.CubeTextureLoader().load(urls, ()=>{ const envRT = pmrem.fromCubemap(tmp).texture; try{ tmp.dispose(); }catch(e){} assignEnvironment(envRT); }); })();
  // Optional HDR
  new RGBELoader().setDataType(THREE.UnsignedByteType).load('textures/studio_small_04_1k.hdr', (hdr)=>{
    hdr.mapping = THREE.EquirectangularReflectionMapping; const envRT = pmrem.fromEquirectangular(hdr).texture; try{ hdr.dispose && hdr.dispose(); }catch(e){}
    assignEnvironment(envRT); try{ pmrem.dispose(); }catch(e){} pmrem = new THREE.PMREMGenerator(renderer);
  }, undefined, ()=>{});

  // ---------- Ground & Disc ----------
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(400,400), new THREE.MeshStandardMaterial({ color: 0x040405, roughness: 0.85 }));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
  const disc = new THREE.Mesh(new THREE.CircleGeometry(10, 64), new THREE.MeshStandardMaterial({ color:0x0e0e10, roughness:0.45, metalness:0.04, transparent:true, opacity:1 }));
  disc.rotation.x = -Math.PI/2; disc.position.y = 0.001; disc.receiveShadow = true; scene.add(disc);

  // ---------- Cursor glow & light ----------
  function generateGlowTexture(size=512,color='#fff3d9'){ const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
    const cx=size/2, cy=size/2; const g=ctx.createRadialGradient(cx,cy,0,cx,cy,size/2);
    g.addColorStop(0,color); g.addColorStop(0.25,color); g.addColorStop(0.6,'rgba(255,243,217,0.45)'); g.addColorStop(1,'rgba(255,243,217,0)');
    ctx.fillStyle=g; ctx.fillRect(0,0,size,size); const tx=new THREE.CanvasTexture(c); tx.minFilter=THREE.LinearFilter; tx.magFilter=THREE.LinearFilter; tx.needsUpdate=true; return tx; }
  const cursorLight = new THREE.PointLight(0xfff7ea, 0.0, 28, 2.2); cursorLight.castShadow=false; scene.add(cursorLight);
  const cursorBall = new THREE.Mesh(new THREE.SphereGeometry(0.06,12,12), new THREE.MeshBasicMaterial({ color:0xfff3d9 })); cursorBall.frustumCulled=false; scene.add(cursorBall);
  const glow = new THREE.Sprite(new THREE.SpriteMaterial({ map: generateGlowTexture(512,'#fff3d9'), blending:THREE.AdditiveBlending, transparent:true, opacity:0.65, depthWrite:false })); glow.scale.setScalar(0.8); scene.add(glow);

  // ---------- Pulse pooling (click bursts) ----------
  const pulsePool=[]; const activePulses=[];
  function createPulse(count=80){ const geom=new THREE.BufferGeometry(); const pos=new Float32Array(count*3); const vel=new Float32Array(count*3);
    geom.setAttribute('position', new THREE.BufferAttribute(pos,3)); geom.setAttribute('vel', new THREE.BufferAttribute(vel,3));
    const mat=new THREE.PointsMaterial({ size:0.05, color:0xfff0d8, transparent:true, opacity:1, depthWrite:false }); const pts=new THREE.Points(geom,mat); pts.userData={life:0,count}; return pts; }
  function getPulse(count=80){ return pulsePool.length ? pulsePool.pop() : createPulse(count); }
  function recyclePulse(p){ p.visible=false; p.userData.life=0; pulsePool.push(p); }
  function spawnPulse(pos3, color=0xfff0d8, count=80){ const pts=getPulse(count); const posAttr=pts.geometry.attributes.position; const velAttr=pts.geometry.attributes.vel;
    for(let i=0;i<pts.userData.count;i++){ const phi=Math.acos(2*Math.random()-1); const theta=Math.random()*Math.PI*2; const r=0.02+Math.random()*0.08;
      posAttr.array[i*3]   = pos3.x + r*Math.sin(phi)*Math.cos(theta);
      posAttr.array[i*3+1] = pos3.y + r*Math.cos(phi);
      posAttr.array[i*3+2] = pos3.z + r*Math.sin(phi)*Math.sin(theta);
      velAttr.array[i*3]   = (Math.random()-0.5)*0.9;
      velAttr.array[i*3+1] = Math.random()*1.2+0.2;
      velAttr.array[i*3+2] = (Math.random()-0.5)*0.9;
    }
    posAttr.needsUpdate=true; velAttr.needsUpdate=true; pts.material.color.setHex(color); pts.userData.life=1; pts.visible=true; if(!pts.parent) scene.add(pts); activePulses.push(pts); }

  // ---------- Instanced particle system with morph-to-surface ----------
  // Quad + instance attributes, plus per-instance target on the porcelain surface.
  function createInstancedParticles(maxInstances=1500, texture){
    const base = new THREE.PlaneGeometry(1,1);
    const inst = new THREE.InstancedBufferGeometry();
    inst.index = base.index; inst.attributes.position = base.attributes.position; inst.attributes.uv = base.attributes.uv;
    const offsets = new Float32Array(maxInstances*3);
    const sizes   = new Float32Array(maxInstances);
    const hues    = new Float32Array(maxInstances);
    const phases  = new Float32Array(maxInstances);
    const drag    = new Float32Array(maxInstances);
    const target  = new Float32Array(maxInstances*3); // to be filled per scene via sampler
    for(let i=0;i<maxInstances;i++){
      offsets[i*3]   = (Math.random()-0.5)*20;
      offsets[i*3+1] = Math.random()*10;
      offsets[i*3+2] = (Math.random()-0.5)*20;
      sizes[i]  = Math.random()*0.6 + 0.1;
      hues[i]   = Math.random();
      phases[i] = Math.random()*Math.PI*2;
      drag[i]   = Math.random()*0.12 + 0.02;
      target[i*3] = target[i*3+1] = target[i*3+2] = 0; // init
    }
    inst.setAttribute('offset', new THREE.InstancedBufferAttribute(offsets,3));
    inst.setAttribute('sizeAttr', new THREE.InstancedBufferAttribute(sizes,1));
    inst.setAttribute('hue', new THREE.InstancedBufferAttribute(hues,1));
    inst.setAttribute('phase', new THREE.InstancedBufferAttribute(phases,1));
    inst.setAttribute('drag', new THREE.InstancedBufferAttribute(drag,1));
    inst.setAttribute('target', new THREE.InstancedBufferAttribute(target,3));

    const material = new THREE.ShaderMaterial({
      transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
      uniforms: {
        uTime:{value:0}, uOpacity:{value:0.7}, uColorGrade:{value:new THREE.Vector3(1,1,1)}, map:{value:texture},
        uAssemble:{value:0}, // 0 = dispersed, 1 = fully on surface
        uFlowPhase:{value:0}, // scene chapter modulation
        uPerformance:{value:1}
      },
      vertexShader: `
        attribute vec3 offset; attribute float sizeAttr; attribute float hue; attribute float phase; attribute float drag; attribute vec3 target;
        uniform float uTime; uniform float uAssemble; uniform float uFlowPhase; uniform float uPerformance;
        varying vec2 vUv; varying float vHue; varying float vMix;
        // light curl for dispersed motion
        vec3 curl(vec3 p){ return vec3(
          sin(p.y + uTime*0.13 + phase),
          cos(p.x + uTime*0.11 + phase*0.5),
          sin(p.z + uTime*0.09 + phase*0.7)
        ) * (0.35 + 0.15*sin(uFlowPhase)); }
        void main(){
          vUv = uv; vHue = hue;
          float t = uTime * (0.3 + drag);
          // dispersed base position with gentle drift
          vec3 p = offset + curl(offset*0.18 + vec3(phase));
          // assemble path: approach surface target with eased curve (easeInOutCubic)
          float a = clamp(uAssemble, 0.0, 1.0);
          float ae = a*a*(3.0-2.0*a);
          vec3 P = mix(p, target, ae);
          // add micro wobble while assembling
          P += 0.02 * vec3(sin(t+phase), cos(t*1.1+phase*0.5), sin(t*0.9+phase*0.7))*(1.0-ae);
          float finalSize = sizeAttr * (0.6 + 0.8*uPerformance) * (0.9 + 0.2*ae);
          vMix = ae;
          // billboard quad in view space
          vec4 mv = modelViewMatrix * vec4(P,1.0);
          vec3 right = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
          vec3 up    = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);
          vec3 pos   = mv.xyz + (right * position.x + up * position.y) * finalSize;
          gl_Position = projectionMatrix * vec4(pos,1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D map; uniform vec3 uColorGrade; uniform float uOpacity; varying vec2 vUv; varying float vHue; varying float vMix;
        void main(){
          vec4 c = texture2D(map, vUv);
          vec3 color = c.rgb * mix(vec3(1.0), uColorGrade, 0.6);
          // soft emphasis when assembled (slightly brighter)
          float assembleBoost = mix(0.9, 1.25, vMix);
          gl_FragColor = vec4(color*assembleBoost, c.a * uOpacity);
          if (gl_FragColor.a < 0.01) discard;
        }
      `
    });

    const mesh = new THREE.Mesh(inst, material); mesh.frustumCulled=false; return mesh;
  }

  // Utility: tiny white sprite as particle texture
  const particleSprite = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAIUlEQVQoU2NkYGD4z0AEMPGfQAwGQ0YwGoYGw2EwDA0GAAc0CE7sE9mFAAAAAElFTkSuQmCC');

  // ---------- Scene abstraction ----------
  class PorcelainScene {
    constructor({ id, name, palette, make, rail, chapters=4 }){
      this.id=id; this.name=name; this.palette=palette; this.make=make; this.rail=rail; this.chapters=chapters;
      this.group=new THREE.Group(); this.meshCache=[]; this.motionEnabled=true;
      this.instancedParticles = createInstancedParticles(1400, particleSprite);
      this.hemi=new THREE.HemisphereLight(0xddddff,0x0a0a0d,0.45);
      this.key=new THREE.DirectionalLight(palette.key||0xffffff,1.8); this.key.castShadow=true; this.key.shadow.mapSize.set(1024,1024); this.key.shadow.bias=-0.0005; this.key.position.set(6,10,6);
      this.fill=new THREE.DirectionalLight(0x8fb3ff,0.45); this.fill.castShadow=false; this.fill.position.set(-6,5,-6);
      this.rim=new THREE.DirectionalLight(0xffe6d0,0.6); this.rim.castShadow=false; this.rim.position.set(0,6,-8);
      this.group.add(this.hemi,this.key,this.fill,this.rim);
      const p = this.make(); this.porcelain = p; p.traverse(c=>{ if(c.isMesh){ c.castShadow=true; c.receiveShadow=true; this.meshCache.push(c);
        if(!(c.material && c.material.isMeshPhysicalMaterial)){
          const base=(c.material&&c.material.color)?c.material.color.clone():new THREE.Color(0xffffff);
          c.material=new THREE.MeshPhysicalMaterial({ color:base, roughness:0.06, metalness:0.0, clearcoat:1.0, clearcoatRoughness:0.04, envMap:scene.environment, envMapIntensity:1.2 });
        }
        if(!c.material.userData) c.material.userData={};
        c.material.userData.baseRoughness = c.material.roughness;
        c.material.userData.baseEnv = c.material.envMapIntensity || 1.2;
        c.material.userData.baseClearcoat = c.material.clearcoat || 1.0;
      }});
      this.group.add(p);
      // normalize position/scale
      const box = new THREE.Box3().setFromObject(this.group); const size = box.getSize(new THREE.Vector3()); const center = box.getCenter(new THREE.Vector3());
      this.group.position.sub(center); const maxDim = Math.max(size.x,size.y,size.z); const s = maxDim>0 ? (4.6/maxDim) : 1; this.group.scale.setScalar(s);
      this.group.updateWorldMatrix(true,true); const box2=new THREE.Box3().setFromObject(this.group); const minY=box2.min.y; this.group.position.y -= minY;
      // tighten shadow frustum
      try{ const bounds=new THREE.Box3().setFromObject(this.group); const gsize=bounds.getSize(new THREE.Vector3()); const pad=Math.max(0.5, Math.min(gsize.length()*0.25,2.0));
        this.key.shadow.camera.left=-gsize.x/2 - pad; this.key.shadow.camera.right=gsize.x/2 + pad; this.key.shadow.camera.top=gsize.y/2 + pad; this.key.shadow.camera.bottom=-gsize.y/2 - pad; this.key.shadow.camera.updateProjectionMatrix(); }catch(e){}

      // particles grading tint
      this.instancedParticles.material.uniforms.uColorGrade.value = this.palette.grade || new THREE.Vector3(1,1,1);
      this.instancedParticles.material.uniforms.uOpacity.value = 0.0; // fade in on enter
      this.group.add(this.instancedParticles);
    }

    // Fill instanced target positions from porcelain mesh surface
    bakeTargets(){
      const sampler = new MeshSurfaceSampler(this.porcelain).setWeightAttribute(null).build();
      const inst = this.instancedParticles.geometry; const tgt = inst.getAttribute('target');
      const tempPos = new THREE.Vector3(); const tempNorm = new THREE.Vector3();
      for(let i=0;i<tgt.count;i++){
        sampler.sample(tempPos, tempNorm);
        tgt.setXYZ(i, tempPos.x, tempPos.y, tempPos.z);
      }
      tgt.needsUpdate = true;
    }

    enter(){
      // background & lights
      gsap.to(scene.background, { r:((this.palette.bg>>16)&255)/255, g:((this.palette.bg>>8)&255)/255, b:(this.palette.bg&255)/255, duration:1.2, ease:'power2.out' });
      gsap.fromTo(this.key,  { intensity:0.0 }, { intensity:1.8, duration:1.0, ease:'power2.out' });
      gsap.fromTo(this.fill, { intensity:0.0 }, { intensity:0.45, duration:1.0, delay:0.05 });
      gsap.fromTo(this.rim,  { intensity:0.0 }, { intensity:0.6,  duration:1.0, delay:0.1 });
      // envMap ensure
      if(scene.environment){ this.meshCache.forEach(m=>{ m.material.envMap=scene.environment; m.material.needsUpdate=true; }); }

      // particles: assemble timeline ("watching grass grow fast")
      this.bakeTargets();
      const u = this.instancedParticles.material.uniforms;
      gsap.to(u.uOpacity,  { value:0.0, duration:0.01 });
      gsap.to(u.uAssemble, { value:0.0, duration:0.01 });
      // cinematic: misty disperse -> hint swirl -> converge -> settle
      const tl = gsap.timeline();
      tl.to(u.uOpacity,   { value:0.35, duration:0.6, ease:'sine.out' }, 0.0)
        .to(u.uFlowPhase, { value:Math.PI*2, duration:0.9, ease:'sine.inOut' }, 0.0)
        .to(u.uAssemble,  { value:0.55, duration:1.2, ease:'power2.inOut' }, 0.3)
        .to(u.uOpacity,   { value:0.65, duration:0.6, ease:'sine.out' }, 0.9)
        .to(u.uAssemble,  { value:1.0, duration:1.4, ease:'expo.out' }, 1.1);
      // bloom breathe
      gsap.fromTo(bloomPass, { strength:0.25 }, { strength:0.55, duration:1.2, ease:'power2.out' });
    }

    exit(){
      const u = this.instancedParticles.material.uniforms;
      gsap.to(this.key, { intensity:0.0, duration:0.9, ease:'power2.in' });
      gsap.to(this.fill,{ intensity:0.0, duration:0.9 });
      gsap.to(this.rim, { intensity:0.0, duration:0.9 });
      gsap.to(u.uOpacity, { value:0.0, duration:0.6 });
      gsap.to(u.uAssemble,{ value:0.0, duration:0.6, ease:'sine.in' });
    }

    update(dt, elapsed, cursorWorld, cursorIntensity){
      const u = this.instancedParticles.material.uniforms; u.uTime.value = elapsed;
      if(this.motionEnabled) this.porcelain.rotation.y += dt * (0.09 + this.id*0.02);
      // subtle material response near cursor
      if(cursorWorld && cursorIntensity>0.02){ for(const m of this.meshCache){ const w=new THREE.Vector3(); m.getWorldPosition(w); const d=Math.min(1.0, cursorWorld.distanceTo(w)/4.5); const effect=1.0-d; const base=m.material.userData; const targetR=THREE.MathUtils.clamp((base.baseRoughness||0.06)*(0.25+(1-effect)*1.0),0.02,1.0); const targetEnv=THREE.MathUtils.lerp((base.baseEnv||1.2),(base.baseEnv||1.2)+2.0*effect*cursorIntensity,0.9); m.material.roughness=THREE.MathUtils.lerp(m.material.roughness, targetR, 0.18); m.material.envMapIntensity=THREE.MathUtils.lerp(m.material.envMapIntensity||base.baseEnv, targetEnv, 0.18); m.material.clearcoat=THREE.MathUtils.lerp(m.material.clearcoat||1.0, Math.min(1.0,(base.baseClearcoat||1.0)+0.4*effect), 0.18); } }
      else { for(const m of this.meshCache){ const base=m.material.userData||{}; m.material.roughness=THREE.MathUtils.lerp(m.material.roughness, base.baseRoughness||0.06, 0.04); m.material.envMapIntensity=THREE.MathUtils.lerp(m.material.envMapIntensity|| (base.baseEnv||1.2), base.baseEnv||1.2, 0.03); m.material.clearcoat=THREE.MathUtils.lerp(m.material.clearcoat|| (base.baseClearcoat||1.0), base.baseClearcoat||1.0, 0.03); } }
    }

    toggleMotion(flag){ this.motionEnabled = flag; }
  }

  // ---------- Procedural porcelain makers ----------
  function makeVesselA(){ const pts=[]; for(let i=0;i<20;i++){ const t=i/19; pts.push(new THREE.Vector2(0.6+Math.sin(t*Math.PI)*0.8*(0.5+0.5*t), -1+t*2.2)); } const geo=new THREE.LatheGeometry(pts,128); const mat=new THREE.MeshPhysicalMaterial({ color:0xf7f8fb, roughness:0.06, clearcoat:1.0, envMap:scene.environment }); const m=new THREE.Mesh(geo,mat); m.castShadow=m.receiveShadow=true; return m; }
  function makePlateB(){ const ring=new THREE.RingGeometry(0.5,2.0,128); const bowl=new THREE.SphereGeometry(2.2,128,128,0,Math.PI*2,0,Math.PI/2); bowl.scale(1,0.38,1); const mat=new THREE.MeshPhysicalMaterial({ color:0xeaf6ff, roughness:0.03, clearcoat:1.0, envMap:scene.environment }); const g=new THREE.Group(); const rim=new THREE.Mesh(ring,mat.clone()); rim.rotation.x=-Math.PI/2; rim.position.y=0.01; const center=new THREE.Mesh(bowl,mat.clone()); center.position.y=0.02; center.castShadow=true; rim.receiveShadow=true; g.add(center,rim); return g; }
  function makeMiniSculptC(){ const geo=new THREE.TorusKnotGeometry(0.9,0.25,256,32,2,3); geo.rotateX(Math.PI*0.1); const m=new THREE.Mesh(geo,new THREE.MeshPhysicalMaterial({ color:0xffefef, roughness:0.08, clearcoat:1.0, envMap:scene.environment })); m.castShadow=m.receiveShadow=true; return m; }
  function makeTallCylinderD(){ const geo=new THREE.CylinderGeometry(0.8,0.8,3.6,64,1,true); const m=new THREE.Mesh(geo,new THREE.MeshPhysicalMaterial({ color:0xfffffb, roughness:0.06, clearcoat:1.0, envMap:scene.environment })); m.castShadow=m.receiveShadow=true; return m; }
  function makeBowlE(){ const geo=new THREE.SphereGeometry(1.8,128,128,0,Math.PI*2,0,Math.PI/1.7); geo.scale(1,0.7,1); const m=new THREE.Mesh(geo,new THREE.MeshPhysicalMaterial({ color:0xe8f2ff, roughness:0.02, clearcoat:0.9, envMap:scene.environment })); m.castShadow=m.receiveShadow=true; return m; }

  // ---------- Scenes & palettes ----------
  const scenes = [
    new PorcelainScene({ id:0, name:'Dawn Vessel',  palette:{ bg:0x05050A, key:0xfff8e8, grade: new THREE.Vector3(1.05, 0.95, 0.9) }, make: makeVesselA,      rail: { position: new THREE.Vector3(6,3.5,6),   target: new THREE.Vector3(0,1.1,0) } }),
    new PorcelainScene({ id:1, name:'Calm Mirror',  palette:{ bg:0x071022, key:0xdfefff, grade: new THREE.Vector3(0.95, 1.02, 1.05) }, make: makePlateB,       rail: { position: new THREE.Vector3(5.5,2.8,5.8), target: new THREE.Vector3(0,0.85,0) } }),
    new PorcelainScene({ id:2, name:'Whim',         palette:{ bg:0x10040a, key:0xffefe9, grade: new THREE.Vector3(1.06, 0.96, 1.05) }, make: makeMiniSculptC, rail: { position: new THREE.Vector3(7,3.4,7),   target: new THREE.Vector3(0,0.8,0) } }),
    new PorcelainScene({ id:3, name:'Echo Column',  palette:{ bg:0x071011, key:0xfffff6, grade: new THREE.Vector3(1.0, 0.98, 1.05) }, make: makeTallCylinderD, rail: { position: new THREE.Vector3(6.2,3.8,6.2), target: new THREE.Vector3(0,1.4,0) } }),
    new PorcelainScene({ id:4, name:'Night Bloom',  palette:{ bg:0x040618, key:0xe6f0ff, grade: new THREE.Vector3(0.92, 0.98, 1.08) }, make: makeBowlE,       rail: { position: new THREE.Vector3(7.5,3.6,7.8), target: new THREE.Vector3(0,0.9,0) } })
  ];

  let currentIndex = 0; scene.add(scenes[0].group); scenes[0].enter();

  // ---------- HUD ----------
  const sceneLabel = document.getElementById('sceneLabel');
  function updateSceneLabel(i){ sceneLabel.textContent = `Scene ${i+1} / ${scenes.length} — ${scenes[i].name}`; }
  updateSceneLabel(0);

  // ---------- Transitions (crossfade + assemble/disperse + camera rails) ----------
  let transitioning = false;
  function prepareFade(group){ group.traverse(c=>{ if(c.isMesh && c.material && !c.material.__prep){ c.material.__prep=true; c.material.__origTransparent=c.material.transparent; c.material.__origOpacity=(c.material.opacity!==undefined?c.material.opacity:1.0); c.material.transparent=true; } }); }
  function fadeGroup(group, to, d=0.9){ group.traverse(c=>{ if(c.isMesh && c.material && c.material.__prep) gsap.to(c.material, { opacity: to, duration:d, ease:'power2.inOut' }); }); }
  function restoreGroup(group){ group.traverse(c=>{ if(c.isMesh && c.material && c.material.__prep){ gsap.to(c.material, { opacity:c.material.__origOpacity||1.0, duration:0.02, onComplete:()=>{ c.material.transparent=c.material.__origTransparent; delete c.material.__origTransparent; delete c.material.__origOpacity; delete c.material.__prep; } }); } }); }
  function freezeGround(flag){ gsap.to(disc.material, { opacity: flag?0.6:1.0, duration:0.5 }); }

  function gotoScene(index){ if(transitioning || index===currentIndex || index<0 || index>=scenes.length) return; transitioning=true;
    const from=scenes[currentIndex], to=scenes[index]; if(!to.group.parent) scene.add(to.group);
    // ensure target points baked for destination (so they assemble immediately during enter)
    try{ to.bakeTargets(); }catch(e){}
    prepareFade(from.group); prepareFade(to.group); to.group.traverse(c=>{ if(c.isMesh && c.material) c.material.opacity=0.0; });
    controls.enabled=false; freezeGround(true);
    const tl=gsap.timeline({ onComplete:()=>{ scene.remove(from.group); restoreGroup(from.group); restoreGroup(to.group); currentIndex=index; updateSceneLabel(index); transitioning=false; controls.enabled=true; freezeGround(false); } });
    // Camera tween to new rail
    tl.to(camera.position, { x:to.rail.position.x, y:to.rail.position.y, z:to.rail.position.z, duration:1.15, ease:'expo.inOut', onUpdate:()=>controls.update() }, 0)
      .to(controls.target, { x:to.rail.target.x,   y:to.rail.target.y,   z:to.rail.target.z,   duration:1.15, ease:'expo.inOut', onUpdate:()=>controls.update() }, 0)
      // Scene hooks
      .add(()=>from.exit(), 0.02)
      .add(()=>to.enter(),  0.02)
      // Crossfade
      .add(()=>fadeGroup(from.group, 0.0, 0.9), 0.04)
      .add(()=>fadeGroup(to.group,   1.0, 1.0), 0.06);
  }

  // ---------- Chapters (scroll stages) ----------
  // Map chapters to evolving looks: 0 disperse, 1 assembling, 2 settled breathing, 3 petal release
  function applyChapter(sceneObj, chapter){ const u=sceneObj.instancedParticles.material.uniforms; switch(chapter){
      case 0: gsap.to(u.uAssemble,{ value:0.0, duration:0.8, ease:'power1.inOut' }); gsap.to(u.uOpacity,{ value:0.35, duration:0.6 }); gsap.to(bloomPass,{ strength:0.3, duration:0.6 }); break;
      case 1: gsap.to(u.uAssemble,{ value:0.6, duration:0.9, ease:'power2.inOut' }); gsap.to(u.uOpacity,{ value:0.55, duration:0.6 }); gsap.to(bloomPass,{ strength:0.45, duration:0.6 }); break;
      case 2: gsap.to(u.uAssemble,{ value:1.0, duration:1.0, ease:'expo.out' }); gsap.to(u.uOpacity,{ value:0.7, duration:0.6 }); gsap.to(bloomPass,{ strength:0.55, duration:0.8 }); break;
      case 3: gsap.to(u.uAssemble,{ value:0.85, duration:0.6, ease:'sine.inOut' }); gsap.fromTo(u.uFlowPhase,{ value:0 }, { value:Math.PI*4, duration:1.2, ease:'sine.inOut' }); gsap.to(u.uOpacity,{ value:0.6, duration:0.6 }); gsap.to(bloomPass,{ strength:0.5, duration:0.6 }); break;
    } }

  let chapterIndex = 2; // start assembled
  applyChapter(scenes[0], chapterIndex);

  // ---------- Input handling ----------
  function isOverUI(e){ const el = document.elementFromPoint(e.clientX, e.clientY); return el && el.closest && el.closest('.panel'); }
  const raycaster = new THREE.Raycaster(); const mouse=new THREE.Vector2(-10,-10); let lastInteraction=performance.now();
  const interactPlane = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000), new THREE.MeshBasicMaterial({ visible:false })); interactPlane.rotation.x=-Math.PI/2; interactPlane.position.y=0; scene.add(interactPlane);

  function computeCursorWorld(){ raycaster.setFromCamera(mouse, camera); const cur=scenes[currentIndex]; if(cur && cur.meshCache.length){ const ints=raycaster.intersectObjects(cur.meshCache,true); if(ints.length) return ints[0]; }
    const ints2=raycaster.intersectObject(interactPlane); if(ints2.length) return ints2[0]; return null; }

  renderer.domElement.addEventListener('mousemove',(e)=>{ if(isOverUI(e)) return; const r=renderer.domElement.getBoundingClientRect(); mouse.x=((e.clientX-r.left)/r.width)*2-1; mouse.y=-((e.clientY-r.top)/r.height)*2+1; lastInteraction=performance.now(); }, { passive:true });
  renderer.domElement.addEventListener('pointerdown',(e)=>{ if(isOverUI(e)) return; const hit=computeCursorWorld(); const p = hit && hit.point ? hit.point : new THREE.Vector3(); spawnPulse(p, 0xfff0d8, 90); }, { passive:true });

  // Wheel: zoom and chapter stepping
  let scrollTarget = camera.position.distanceTo(controls.target); let scrollAccumulator=0;
  renderer.domElement.addEventListener('wheel',(e)=>{ if(isOverUI(e)) return; e.preventDefault(); scrollTarget += e.deltaY * 0.003 * 6; scrollTarget = THREE.MathUtils.clamp(scrollTarget, controls.minDistance, controls.maxDistance);
    scrollAccumulator += e.deltaY; if(Math.abs(scrollAccumulator) > 140){ const step = scrollAccumulator>0 ? 1 : -1; scrollAccumulator=0; chapterIndex = THREE.MathUtils.clamp(chapterIndex + step, 0, 3); applyChapter(scenes[currentIndex], chapterIndex); }
  }, { passive:false });

  // Touch pinch zoom
  let pinchStart=null; renderer.domElement.addEventListener('touchstart',(e)=>{ if(e.touches && e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX; const dy=e.touches[0].clientY-e.touches[1].clientY; pinchStart=Math.hypot(dx,dy); } },{ passive:true });
  renderer.domElement.addEventListener('touchmove',(e)=>{ if(e.touches && e.touches.length===2 && pinchStart){ const dx=e.touches[0].clientX-e.touches[1].clientX; const dy=e.touches[0].clientY-e.touches[1].clientY; const nowD=Math.hypot(dx,dy); const diff=(pinchStart-nowD)*0.0025; scrollTarget += diff * 8.0; scrollTarget = THREE.MathUtils.clamp(scrollTarget, controls.minDistance, controls.maxDistance); pinchStart=nowD; } },{ passive:true });
  renderer.domElement.addEventListener('touchend',()=>{ pinchStart=null; }, { passive:true });

  // Keyboard
  window.addEventListener('keydown',(e)=>{ const active=document.activeElement; const typing=active && (active.tagName==='INPUT'||active.tagName==='TEXTAREA'||active.isContentEditable); if(!typing){ if(e.code==='ArrowRight'){ e.preventDefault(); gotoScene((currentIndex+1)%scenes.length); chapterIndex=2; }
      if(e.code==='ArrowLeft'){ e.preventDefault(); gotoScene((currentIndex-1+scenes.length)%scenes.length); chapterIndex=2; }
      if(e.code==='Space'){ e.preventDefault(); toggleMotion(); }
    } }, { passive:false });

  // UI toggles
  document.getElementById('toggleBloom').addEventListener('change',(e)=>{ bloomPass.enabled = e.target.checked; });
  document.getElementById('toggleDOF').addEventListener('change',(e)=>{ bokehPass.enabled = e.target.checked; });
  document.getElementById('toggleParticles').addEventListener('change',(e)=>{ scenes.forEach(s=>{ if(s.instancedParticles) s.instancedParticles.visible = e.target.checked; }); });
  let audioReactive=false; document.getElementById('toggleAudio').addEventListener('change',(e)=>{ audioReactive = e.target.checked; });
  document.getElementById('fsBtn').addEventListener('click', async ()=>{ if(!document.fullscreenElement){ await container.requestFullscreen().catch(()=>{}); resize(); } else { await document.exitFullscreen().catch(()=>{}); resize(); } });

  // Motion
  let globalMotion=true; function toggleMotion(){ globalMotion=!globalMotion; scenes.forEach(s=>s.toggleMotion(globalMotion)); }

  // ---------- Resize ----------
  function resize(){ const w=WIDTH(), h=HEIGHT(); camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h); composer.setSize(w,h);
    try{ if(bokehPass && bokehPass.materialBokeh && bokehPass.materialBokeh.uniforms && ('aspect' in bokehPass.materialBokeh.uniforms)) bokehPass.materialBokeh.uniforms.aspect.value=camera.aspect; else if(bokehPass && bokehPass.uniforms){ bokehPass.uniforms['width'].value=w; bokehPass.uniforms['height'].value=h; } if(smaaPass) smaaPass.setSize(w,h); }catch(e){}
  }
  window.addEventListener('resize', resize);

  // ---------- Animation loop ----------
  const clock=new THREE.Clock();
  function animate(){ const dt=Math.min(0.05, clock.getDelta()); const elapsed=clock.getElapsedTime();
    // smooth zoom along view ray
    const camDir=new THREE.Vector3(); camera.getWorldDirection(camDir); const desiredDistance=THREE.MathUtils.lerp(camera.position.distanceTo(controls.target), scrollTarget, 0.06); const clamped=THREE.MathUtils.clamp(desiredDistance, controls.minDistance, controls.maxDistance); const newPos=new THREE.Vector3().copy(camDir).multiplyScalar(-clamped).add(controls.target); camera.position.lerp(newPos, 0.08);
    // cursor/hit logic
    const hit=computeCursorWorld(); let cursorWorld=null, cursorIntensity=0; if(hit){ const worldPoint=hit.point.clone(); cursorWorld=worldPoint; const N = hit.face && hit.object ? hit.face.normal.clone().transformDirection(hit.object.matrixWorld) : new THREE.Vector3(0,1,0); const V=camera.position.clone().sub(worldPoint).normalize(); const d=hit.distance; const Iraw=(1-Math.min(10,d)/10)*Math.max(0, N.dot(V)); const I=THREE.MathUtils.clamp(Iraw, 0.04, 1.2); const camFactor=THREE.MathUtils.clamp(8.0/Math.max(0.001,d), 0.0, 1.0); const intensity=THREE.MathUtils.lerp(cursorLight.intensity, I*camFactor, 0.12); cursorLight.intensity=intensity; cursorLight.position.lerp(worldPoint,0.18); cursorBall.position.lerp(worldPoint,0.18); glow.position.lerp(worldPoint.clone().add(new THREE.Vector3().subVectors(camera.position, worldPoint).setLength(0.06)),0.18); glow.material.opacity = THREE.MathUtils.lerp(glow.material.opacity, 0.65*Math.max(0.15,I), 0.12); glow.scale.setScalar(THREE.MathUtils.lerp(glow.scale.x, 0.3 + I*1.6*camFactor, 0.12)); cursorIntensity=I; } else { cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, 0.0, 0.06); glow.material.opacity = THREE.MathUtils.lerp(glow.material.opacity, 0.0, 0.05); }
    // audio reactive placeholder: breathe bloom subtly when enabled
    if(audioReactive){ bloomPass.strength = 0.45 + 0.1 * (0.5 + 0.5*Math.sin(elapsed*1.5)); }
    // pulses update
    for(let i=activePulses.length-1;i>=0;i--){ const p=activePulses[i]; p.userData.life -= dt*0.8; const posAttr=p.geometry.attributes.position, velAttr=p.geometry.attributes.vel; for(let v=0; v<posAttr.count; v++){ posAttr.array[v*3] += velAttr.array[v*3]*dt; posAttr.array[v*3+1] += velAttr.array[v*3+1]*dt; posAttr.array[v*3+2] += velAttr.array[v*3+2]*dt; velAttr.array[v*3+1] -= dt*0.9; } posAttr.needsUpdate=true; velAttr.needsUpdate=true; p.material.opacity=Math.max(0, p.userData.life); if(p.userData.life<=0){ const idx=activePulses.indexOf(p); if(idx!==-1) activePulses.splice(idx,1); if(p.parent) p.parent.remove(p); recyclePulse(p); } }
    // update scene
    scenes[currentIndex].update(dt, elapsed, hit ? hit.point.clone() : null, cursorIntensity);
    controls.update(); composer.render(); requestAnimationFrame(animate); }
  requestAnimationFrame(animate);

  // ---------- Expose helpers ----------
  window.__porcelain = { scenes, gotoScene, resize };

  </script>
</body>
</html>
