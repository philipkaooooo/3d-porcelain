<!doctype html>
<html lang="en">
  <head>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>Porcelain 3D</title>
      <style>
        html, body {
          height: 100%;
          margin: 0;
          background: #101113;
        }
        canvas {
          width: 100vw;
          height: 100vh;
          display: block;
        }
        .hud {
          position: fixed;
          top: 10px;
          left: 10px;
          color: #cfcfcf;
          font: 14px system-ui;
          opacity: 0.9;
          z-index: 5;
        }
      </style>
  </head>
  <body>
    <div class="hud">drag = orbit • wheel = zoom • dbl-click = focus</div>
    <canvas id="c"></canvas>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js";
      import { GLTFLoader } from "https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js";
      import { EffectComposer } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/EffectComposer.js";
      import { RenderPass } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/UnrealBloomPass.js";
      import { FilmPass } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/FilmPass.js";
      import { ShaderPass } from "https://unpkg.com/three@0.165.0/examples/jsm/postprocessing/ShaderPass.js";

      const canvas = document.getElementById("c");
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.1;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x080811);
      scene.fog = new THREE.Fog(0x090a15, 10, 35);

      const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 150);
      camera.position.set(1.6, 1.1, 1.6);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.065;
      controls.minDistance = 0.2;
      controls.maxDistance = 12;

      const hemi = new THREE.HemisphereLight(0xd7e0ff, 0x1a1b1f, 0.55);
      scene.add(hemi);

      const key = new THREE.DirectionalLight(0xffffff, 1.6);
      key.position.set(2, 3, 1);
      key.castShadow = true;
      key.shadow.mapSize.set(2048, 2048);
      scene.add(key);

      const rim = new THREE.DirectionalLight(0x92b7ff, 0.75);
      rim.position.set(-2.5, 1.8, -1.4);
      scene.add(rim);

      const ground = new THREE.Mesh(
        new THREE.CylinderGeometry(3.5, 3.5, 0.02, 48),
        new THREE.MeshStandardMaterial({
          color: 0x121222,
          roughness: 0.8,
          metalness: 0.08,
          emissive: 0x040408,
          emissiveIntensity: 0.15
        })
      );
      ground.receiveShadow = true;
      ground.position.y = -0.01;
      scene.add(ground);

      const grid = new THREE.GridHelper(4, 40, 0x3a3c3f, 0x222427);
      grid.position.y = 0;
      grid.material.opacity = 0.15;
      grid.material.transparent = true;
      scene.add(grid);

      const modelGroup = new THREE.Group();
      scene.add(modelGroup);

      // Sparkle and environment setup (unchanged)
      const sparkleCount = 450;
      const sparkleGeometry = new THREE.BufferGeometry();
      const sparklePositions = new Float32Array(sparkleCount * 3);
      for (let i = 0; i < sparkleCount; i++) {
        const radius = 2 + Math.random() * 5.5;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        sparklePositions[i * 3 + 0] = radius * Math.sin(phi) * Math.cos(theta);
        sparklePositions[i * 3 + 1] = radius * Math.cos(phi) * 0.45;
        sparklePositions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
      }
      sparkleGeometry.setAttribute("position", new THREE.BufferAttribute(sparklePositions, 3));
      const sparkleMaterial = new THREE.PointsMaterial({
        color: new THREE.Color(0x84c2ff),
        size: 0.08,
        transparent: true,
        opacity: 0.85,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });
      const sparkles = new THREE.Points(sparkleGeometry, sparkleMaterial);
      sparkles.position.y = 0.35;
      sparkles.visible = false;
      scene.add(sparkles);

      const envCanvas = document.createElement("canvas");
      envCanvas.width = 512;
      envCanvas.height = 256;
      const envCtx = envCanvas.getContext("2d");
      const gradient = envCtx.createLinearGradient(0, 0, 0, envCanvas.height);
      gradient.addColorStop(0, "#1e1a3e");
      gradient.addColorStop(0.35, "#3e1a6b");
      gradient.addColorStop(0.7, "#0b2048");
      gradient.addColorStop(1, "#06121f");
      envCtx.fillStyle = gradient;
      envCtx.fillRect(0, 0, envCanvas.width, envCanvas.height);
      const envTexture = new THREE.CanvasTexture(envCanvas);
      envTexture.mapping = THREE.EquirectangularReflectionMapping;
      envTexture.colorSpace = THREE.SRGBColorSpace;
      envTexture.anisotropy = 4;
      scene.environment = envTexture;

      // Postprocessing
      const composer = new EffectComposer(renderer);
      composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      composer.setSize(window.innerWidth, window.innerHeight);

      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight), 0.7, 0.45, 0.85
      );
      composer.addPass(bloomPass);

      const filmPass = new FilmPass(0.32, 0.55, 1024, false);
      composer.addPass(filmPass);

      // Aurora shader
      const AuroraShader = {/* ... (unchanged, same as above) ... */};
      const auroraPass = new ShaderPass(AuroraShader);
      composer.addPass(auroraPass);

      // Try to load YOUR porcelain.glb
      const loader = new GLTFLoader();
      const glbUrl = "./porcelain.glb"; // or "./assets/porcelain.glb" if your model is in assets/

      const frameBox = new THREE.Box3();
      const frameVec = new THREE.Vector3();

      loader.load(
        glbUrl,
        (gltf) => {
          const model = gltf.scene;
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              if (child.material && Array.isArray(child.material)) {
                child.material.forEach((mat) => (mat.toneMapped = true));
              } else if (child.material) {
                child.material.toneMapped = true;
              }
            }
          });
          modelGroup.clear();
          modelGroup.add(model);

          // Center and floor the model
          frameBox.setFromObject(model);
          const center = frameBox.getCenter(frameVec);
          model.position.sub(center);
          frameBox.setFromObject(model);
          const floorOffset = frameBox.min.y;
          model.position.y -= floorOffset;
          frameBox.setFromObject(model);
          const size = frameBox.getSize(frameVec);
          const radius = size.length() * 0.5;
          const fov = THREE.MathUtils.degToRad(camera.fov);
          const distance = radius / Math.tan(fov * 0.5);

          const framedCenter = frameBox.getCenter(frameVec);
          controls.target.copy(framedCenter);
          camera.position.set(distance * 0.9, distance * 0.6 + size.y * 0.15, distance * 0.9);
          camera.near = Math.max(0.01, radius * 0.02);
          camera.far = radius * 20;
          camera.updateProjectionMatrix();

          const hud = document.querySelector(".hud");
          if (hud) {
            hud.textContent = "drag = orbit • wheel = zoom • dbl-click = focus";
            hud.style.color = "#cfcfcf";
          }

          sparkles.visible = true;
        },
        undefined,
        (error) => {
          console.error("Failed to load porcelain.glb", error);
          const hud = document.querySelector(".hud");
          if (hud) {
            hud.textContent = "Could not load porcelain.glb – check the file path.";
            hud.style.color = "#ff8a8a";
          }
          sparkles.visible = false;
        }
      );

      const clock = new THREE.Clock();
      let spinSpeed = 0.25;

      function animate() {
        const delta = clock.getDelta();
        const elapsed = clock.elapsedTime;

        modelGroup.rotation.y += spinSpeed * delta;
        sparkles.rotation.y += delta * 0.1;
        sparkles.rotation.x = Math.sin(elapsed * 0.08) * 0.1;

        bloomPass.strength = 0.65 + Math.sin(elapsed * 0.45) * 0.18;
        bloomPass.radius = 0.6 + Math.cos(elapsed * 0.35) * 0.05;
        filmPass.uniforms.nIntensity.value = 0.35 + Math.sin(elapsed * 0.7) * 0.06;
        filmPass.uniforms.sIntensity.value = 0.45 + Math.cos(elapsed * 0.4) * 0.08;
        auroraPass.uniforms.time.value = elapsed;

        controls.update();
        composer.render();
        requestAnimationFrame(animate);
      }
      animate();

      addEventListener("resize", () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        composer.setSize(width, height);
        bloomPass.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        auroraPass.uniforms.resolution.value.set(width, height);
      });

      // double-click to focus
      renderer.domElement.addEventListener("dblclick", (e) => {
        const r = renderer.domElement.getBoundingClientRect();
        const ndc = new THREE.Vector2(
          ((e.clientX - r.left) / r.width) * 2 - 1,
          -((e.clientY - r.top) / r.height) * 2 + 1
        );
        const ray = new THREE.Raycaster();
        ray.setFromCamera(ndc, camera);
        const hit = ray.intersectObjects(modelGroup.children, true)[0];
        if (hit) {
          controls.target.copy(hit.point);
        }
      });

      document.addEventListener("keydown", (event) => {
        if (event.code === "Space") {
          spinSpeed = spinSpeed > 0 ? 0 : 0.25;
        }
      });
    </script>
  </body>
</html>
