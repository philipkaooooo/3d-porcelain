<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Porcelain Transcendence - Developer Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            height: 100vh;
            color: #00ff88;
        }

        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
        }

        /* Developer UI */
        .dev-ui {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
        }

        .panel {
            background: rgba(0, 20, 10, 0.85);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 15px;
            margin: 10px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .stats-panel {
            top: 10px;
            right: 10px;
            min-width: 200px;
        }

        .controls-panel {
            bottom: 10px;
            left: 10px;
            min-width: 300px;
        }

        .scene-panel {
            top: 10px;
            left: 10px;
            min-width: 250px;
        }

        .debug-panel {
            bottom: 10px;
            right: 10px;
            min-width: 280px;
        }

        h3 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }

        .stat-label {
            color: #88ffcc;
        }

        .stat-value {
            color: #00ff88;
            font-weight: bold;
        }

        .control-group {
            margin: 10px 0;
        }

        .control-row {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        label {
            font-size: 12px;
            color: #88ffcc;
            margin-right: 10px;
            min-width: 120px;
        }

        input[type="range"] {
            flex: 1;
            background: #003322;
            height: 4px;
            border-radius: 2px;
            outline: none;
        }

        input[type="checkbox"] {
            margin-right: 8px;
        }

        button {
            background: #002211;
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin: 2px;
            transition: all 0.3s;
        }

        button:hover {
            background: #00ff88;
            color: #002211;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 8px;
        }

        .scene-button {
            flex: 1;
            min-width: 80px;
        }

        .log-entry {
            font-size: 11px;
            margin: 2px 0;
            color: #88ffaa;
            opacity: 0.8;
        }

        .performance-graph {
            height: 40px;
            background: #001a0d;
            border: 1px solid #004422;
            border-radius: 2px;
            margin-top: 5px;
            overflow: hidden;
        }

        .graph-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #88ffcc);
            transition: width 0.3s;
        }

        /* Loading screen */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: #00ff88;
        }

        .loading-bar {
            width: 300px;
            height: 4px;
            background: #003322;
            border-radius: 2px;
            margin-top: 20px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: #00ff88;
            width: 0%;
            transition: width 0.3s;
        }

        .hotkey {
            display: inline-block;
            background: #002211;
            border: 1px solid #00ff88;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin: 0 2px;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <!-- Loading Screen -->
    <div class="loading" id="loading">
        <h2>PORCELAIN TRANSCENDENCE</h2>
        <p>Developer Edition v2.1.4</p>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
        <p id="loadingText">Initializing core systems...</p>
    </div>

    <!-- Developer UI -->
    <div class="dev-ui">
        <!-- Stats Panel -->
        <div class="panel stats-panel">
            <h3>Performance Metrics</h3>
            <div class="stat">
                <span class="stat-label">FPS:</span>
                <span class="stat-value" id="fpsCounter">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Frame Time:</span>
                <span class="stat-value" id="frameTime">0ms</span>
            </div>
            <div class="stat">
                <span class="stat-label">Triangles:</span>
                <span class="stat-value" id="triangleCount">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Draw Calls:</span>
                <span class="stat-value" id="drawCallCount">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Memory:</span>
                <span class="stat-value" id="memoryUsage">0 MB</span>
            </div>
            <div class="performance-graph">
                <div class="graph-bar" id="performanceGraph"></div>
            </div>
        </div>

        <!-- Controls Panel -->
        <div class="panel controls-panel">
            <h3>Scene Controls</h3>
            <div class="control-group">
                <div class="control-row">
                    <label>Auto Rotate:</label>
                    <input type="checkbox" id="autoRotate" checked>
                </div>
                <div class="control-row">
                    <label>Rotation Speed:</label>
                    <input type="range" id="rotationSpeed" min="0" max="2" step="0.1" value="1">
                </div>
                <div class="control-row">
                    <label>Bloom Intensity:</label>
                    <input type="range" id="bloomIntensity" min="0" max="2" step="0.1" value="0.8">
                </div>
                <div class="control-row">
                    <label>Exposure:</label>
                    <input type="range" id="exposure" min="0.1" max="2" step="0.1" value="1.0">
                </div>
            </div>
            <div class="button-group">
                <button onclick="toggleWireframe()">Wireframe</button>
                <button onclick="toggleNormals()">Show Normals</button>
                <button onclick="toggleBounds()">Show Bounds</button>
                <button onclick="exportScene()">Export Scene</button>
            </div>
        </div>

        <!-- Scene Panel -->
        <div class="panel scene-panel">
            <h3>Scene Management</h3>
            <div class="control-row">
                <label>Current Scene:</label>
                <span class="stat-value" id="currentScene">1/5</span>
            </div>
            <div class="button-group">
                <button class="scene-button" onclick="switchScene(0)">Vessel</button>
                <button class="scene-button" onclick="switchScene(1)">Plate</button>
                <button class="scene-button" onclick="switchScene(2)">Sculpture</button>
                <button class="scene-button" onclick="switchScene(3)">Column</button>
                <button class="scene-button" onclick="switchScene(4)">Bowl</button>
            </div>
            <div class="control-row">
                <label>Animation:</label>
                <input type="checkbox" id="animationToggle" checked>
            </div>
        </div>

        <!-- Debug Panel -->
        <div class="panel debug-panel">
            <h3>Debug Console</h3>
            <div id="debugLog">
                <div class="log-entry">System initialized</div>
                <div class="log-entry">WebGL context created</div>
                <div class="log-entry">Shader compilation complete</div>
            </div>
            <div class="button-group">
                <button onclick="clearLog()">Clear Log</button>
                <button onclick="takeScreenshot()">Screenshot</button>
                <button onclick="toggleUI()">Hide UI</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/controls/OrbitControls.js';
        import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/postprocessing/OutputPass.js';

        // Global state
        const APP = {
            scene: null,
            camera: null,
            renderer: null,
            composer: null,
            controls: null,
            currentScene: 0,
            scenes: [],
            clock: new THREE.Clock(),
            stats: {
                fps: 0,
                frameTime: 0,
                triangles: 0,
                drawCalls: 0
            },
            settings: {
                autoRotate: true,
                rotationSpeed: 1.0,
                bloomIntensity: 0.8,
                exposure: 1.0,
                wireframe: false,
                showNormals: false,
                showBounds: false
            }
        };

        // Initialize the application
        async function init() {
            updateLoading('Creating renderer...', 20);
            await createRenderer();
            
            updateLoading('Setting up scene...', 40);
            await setupScene();
            
            updateLoading('Creating effects...', 60);
            await setupPostProcessing();
            
            updateLoading('Loading assets...', 80);
            await createScenes();
            
            updateLoading('Finalizing...', 95);
            await finalizeSetup();
            
            updateLoading('Ready!', 100);
            
            // Hide loading screen after a brief delay
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                addLogEntry('Application ready');
            }, 500);
            
            // Start animation loop
            animate();
        }

        function updateLoading(text, progress) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingProgress').style.width = `${progress}%`;
            addLogEntry(text);
        }

        function addLogEntry(message) {
            const log = document.getElementById('debugLog');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function clearLog() {
            document.getElementById('debugLog').innerHTML = '';
            addLogEntry('Log cleared');
        }

        async function createRenderer() {
            // Create WebGL renderer with advanced settings
            APP.renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: "high-performance",
                alpha: true
            });
            
            APP.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            APP.renderer.setSize(window.innerWidth, window.innerHeight);
            APP.renderer.outputColorSpace = THREE.SRGBColorSpace;
            APP.renderer.toneMapping = THREE.ACESFilmicToneMapping;
            APP.renderer.toneMappingExposure = APP.settings.exposure;
            APP.renderer.shadowMap.enabled = true;
            APP.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            document.getElementById('container').appendChild(APP.renderer.domElement);
            
            addLogEntry('Renderer created with advanced settings');
        }

        async function setupScene() {
            // Create main scene
            APP.scene = new THREE.Scene();
            APP.scene.background = new THREE.Color(0x000511);
            APP.scene.fog = new THREE.Fog(0x000511, 10, 50);

            // Create camera
            APP.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            APP.camera.position.set(8, 5, 12);

            // Create controls
            APP.controls = new OrbitControls(APP.camera, APP.renderer.domElement);
            APP.controls.enableDamping = true;
            APP.controls.dampingFactor = 0.05;
            APP.controls.minDistance = 3;
            APP.controls.maxDistance = 50;
            APP.controls.autoRotate = APP.settings.autoRotate;
            APP.controls.autoRotateSpeed = APP.settings.rotationSpeed;

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x404060, 0.4);
            APP.scene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xfff0e0, 1.2);
            directionalLight.position.set(10, 15, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            APP.scene.add(directionalLight);

            // Add hemisphere light for natural lighting
            const hemisphereLight = new THREE.HemisphereLight(0x4488ff, 0x224433, 0.3);
            APP.scene.add(hemisphereLight);

            addLogEntry('Scene setup complete');
        }

        async function setupPostProcessing() {
            // Create effect composer
            APP.composer = new EffectComposer(APP.renderer);
            
            // Add render pass
            const renderPass = new RenderPass(APP.scene, APP.camera);
            APP.composer.addPass(renderPass);
            
            // Add bloom pass
            APP.bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                APP.settings.bloomIntensity,
                0.4,
                0.85
            );
            APP.composer.addPass(APP.bloomPass);
            
            // Add output pass
            const outputPass = new OutputPass();
            APP.composer.addPass(outputPass);
            
            addLogEntry('Post-processing pipeline established');
        }

        async function createScenes() {
            // Create 5 different porcelain scenes
            const sceneConfigs = [
                { name: "Dawn Vessel", color: 0xffeebb, scale: 1.2 },
                { name: "Calm Plate", color: 0xbbeeff, scale: 1.0 },
                { name: "Whim Sculpture", color: 0xffbbee, scale: 0.8 },
                { name: "Echo Column", color: 0xeeffbb, scale: 1.5 },
                { name: "Night Bloom", color: 0xbbffee, scale: 1.1 }
            ];

            for (let i = 0; i < sceneConfigs.length; i++) {
                const config = sceneConfigs[i];
                const sceneGroup = new THREE.Group();
                
                // Create porcelain geometry based on scene type
                let geometry;
                switch(i) {
                    case 0: // Vessel
                        geometry = createVesselGeometry();
                        break;
                    case 1: // Plate
                        geometry = createPlateGeometry();
                        break;
                    case 2: // Sculpture
                        geometry = createSculptureGeometry();
                        break;
                    case 3: // Column
                        geometry = createColumnGeometry();
                        break;
                    case 4: // Bowl
                        geometry = createBowlGeometry();
                        break;
                }
                
                // Create advanced porcelain material
                const material = new THREE.MeshPhysicalMaterial({
                    color: config.color,
                    roughness: 0.1,
                    metalness: 0.0,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.05,
                    transmission: 0.2,
                    thickness: 0.5,
                    envMapIntensity: 1.2
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.scale.setScalar(config.scale);
                
                sceneGroup.add(mesh);
                
                // Add decorative elements
                addDecorativeElements(sceneGroup, i);
                
                // Store scene data
                APP.scenes.push({
                    group: sceneGroup,
                    mesh: mesh,
                    config: config,
                    animation: {
                        rotationSpeed: 0.5 + Math.random() * 1.0,
                        floatHeight: 0.1 + Math.random() * 0.3,
                        floatSpeed: 1 + Math.random() * 2
                    }
                });
                
                addLogEntry(`Created scene: ${config.name}`);
            }
            
            // Add first scene to render
            APP.scene.add(APP.scenes[0].group);
        }

        function createVesselGeometry() {
            const points = [];
            for (let i = 0; i <= 20; i++) {
                const t = i / 20;
                const x = Math.sin(t * Math.PI) * 2;
                const y = (t - 0.5) * 4;
                points.push(new THREE.Vector2(x, y));
            }
            return new THREE.LatheGeometry(points, 32);
        }

        function createPlateGeometry() {
            const geometry = new THREE.CylinderGeometry(3, 3, 0.3, 64);
            geometry.rotateX(Math.PI / 2);
            return geometry;
        }

        function createSculptureGeometry() {
            const geometry = new THREE.TorusKnotGeometry(1, 0.3, 128, 32);
            return geometry;
        }

        function createColumnGeometry() {
            const geometry = new THREE.CylinderGeometry(1, 1.2, 4, 32);
            return geometry;
        }

        function createBowlGeometry() {
            const geometry = new THREE.SphereGeometry(2, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            return geometry;
        }

        function addDecorativeElements(sceneGroup, sceneIndex) {
            // Add particle system
            const particleCount = 200 + sceneIndex * 50;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                // Position particles in a sphere around the object
                const radius = 3 + Math.random() * 2;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i3] = Math.sin(phi) * Math.cos(theta) * radius;
                positions[i3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
                positions[i3 + 2] = Math.cos(phi) * radius;
                
                // Color based on scene index
                const hue = (sceneIndex * 72) / 360;
                const color = new THREE.Color().setHSL(hue, 0.7, 0.6);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.6
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            sceneGroup.add(particleSystem);
        }

        async function finalizeSetup() {
            // Add window resize handler
            window.addEventListener('resize', onWindowResize);
            
            // Add keyboard controls
            window.addEventListener('keydown', onKeyDown);
            
            // Initialize UI controls
            initializeUIControls();
            
            addLogEntry('All systems initialized');
        }

        function onWindowResize() {
            APP.camera.aspect = window.innerWidth / window.innerHeight;
            APP.camera.updateProjectionMatrix();
            APP.renderer.setSize(window.innerWidth, window.innerHeight);
            APP.composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            switch(event.key) {
                case 'ArrowRight':
                    switchScene((APP.currentScene + 1) % APP.scenes.length);
                    break;
                case 'ArrowLeft':
                    switchScene((APP.currentScene - 1 + APP.scenes.length) % APP.scenes.length);
                    break;
                case ' ':
                    toggleAnimation();
                    break;
                case 'r':
                    resetCamera();
                    break;
                case '1': case '2': case '3': case '4': case '5':
                    switchScene(parseInt(event.key) - 1);
                    break;
            }
        }

        function switchScene(index) {
            if (index === APP.currentScene || index < 0 || index >= APP.scenes.length) return;
            
            // Remove current scene
            APP.scene.remove(APP.scenes[APP.currentScene].group);
            
            // Add new scene
            APP.scene.add(APP.scenes[index].group);
            APP.currentScene = index;
            
            // Update UI
            document.getElementById('currentScene').textContent = `${index + 1}/${APP.scenes.length}`;
            
            addLogEntry(`Switched to scene: ${APP.scenes[index].config.name}`);
        }

        function toggleAnimation() {
            APP.settings.autoRotate = !APP.settings.autoRotate;
            APP.controls.autoRotate = APP.settings.autoRotate;
            document.getElementById('animationToggle').checked = APP.settings.autoRotate;
            addLogEntry(`Animation ${APP.settings.autoRotate ? 'enabled' : 'disabled'}`);
        }

        function resetCamera() {
            APP.controls.reset();
            addLogEntry('Camera reset');
        }

        function initializeUIControls() {
            // Auto rotate
            document.getElementById('autoRotate').addEventListener('change', (e) => {
                APP.settings.autoRotate = e.target.checked;
                APP.controls.autoRotate = APP.settings.autoRotate;
            });
            
            // Rotation speed
            document.getElementById('rotationSpeed').addEventListener('input', (e) => {
                APP.settings.rotationSpeed = parseFloat(e.target.value);
                APP.controls.autoRotateSpeed = APP.settings.rotationSpeed;
            });
            
            // Bloom intensity
            document.getElementById('bloomIntensity').addEventListener('input', (e) => {
                APP.settings.bloomIntensity = parseFloat(e.target.value);
                APP.bloomPass.strength = APP.settings.bloomIntensity;
            });
            
            // Exposure
            document.getElementById('exposure').addEventListener('input', (e) => {
                APP.settings.exposure = parseFloat(e.target.value);
                APP.renderer.toneMappingExposure = APP.settings.exposure;
            });
            
            // Animation toggle
            document.getElementById('animationToggle').addEventListener('change', (e) => {
                toggleAnimation();
            });
        }

        // Utility functions
        function toggleWireframe() {
            APP.settings.wireframe = !APP.settings.wireframe;
            APP.scenes.forEach(scene => {
                scene.mesh.material.wireframe = APP.settings.wireframe;
            });
            addLogEntry(`Wireframe ${APP.settings.wireframe ? 'enabled' : 'disabled'}`);
        }

        function toggleNormals() {
            APP.settings.showNormals = !APP.settings.showNormals;
            // Implementation for normal visualization would go here
            addLogEntry(`Normals visualization ${APP.settings.showNormals ? 'enabled' : 'disabled'}`);
        }

        function toggleBounds() {
            APP.settings.showBounds = !APP.settings.showBounds;
            // Implementation for bounds visualization would go here
            addLogEntry(`Bounds visualization ${APP.settings.showBounds ? 'enabled' : 'disabled'}`);
        }

        function exportScene() {
            // Implementation for scene export would go here
            addLogEntry('Scene export initiated');
        }

        function takeScreenshot() {
            APP.renderer.domElement.toBlob(function(blob) {
                const a = document.createElement('a');
                const url = URL.createObjectURL(blob);
                a.href = url;
                a.download = `porcelain-scene-${new Date().getTime()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
            addLogEntry('Screenshot saved');
        }

        function toggleUI() {
            const ui = document.querySelector('.dev-ui');
            ui.style.display = ui.style.display === 'none' ? 'block' : 'none';
            addLogEntry(`UI ${ui.style.display === 'none' ? 'hidden' : 'shown'}`);
        }

        // Animation and rendering
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = APP.clock.getDelta();
            const elapsed = APP.clock.getElapsedTime();
            
            // Update controls
            APP.controls.update();
            
            // Update current scene animation
            const currentScene = APP.scenes[APP.currentScene];
            if (currentScene) {
                // Float animation
                currentScene.group.position.y = Math.sin(elapsed * currentScene.animation.floatSpeed) * currentScene.animation.floatHeight;
                
                // Gentle rotation
                if (!APP.controls.autoRotate) {
                    currentScene.group.rotation.y += delta * currentScene.animation.rotationSpeed * 0.1;
                }
                
                // Particle animation
                const particles = currentScene.group.children.find(child => child.isPoints);
                if (particles) {
                    particles.rotation.y += delta * 0.2;
                }
            }
            
            // Update stats
            updateStats();
            
            // Render
            APP.composer.render();
        }

        function updateStats() {
            const now = performance.now();
            
            // Calculate FPS
            if (!APP.stats.lastTime) APP.stats.lastTime = now;
            const deltaTime = now - APP.stats.lastTime;
            if (deltaTime > 1000) {
                APP.stats.fps = Math.round(1000 / APP.stats.frameTime);
                APP.stats.lastTime = now;
            }
            APP.stats.frameTime = deltaTime;
            
            // Update triangle count (simplified)
            APP.stats.triangles = APP.renderer.info.render.triangles;
            APP.stats.drawCalls = APP.renderer.info.render.calls;
            
            // Update UI
            document.getElementById('fpsCounter').textContent = APP.stats.fps;
            document.getElementById('frameTime').textContent = `${APP.stats.frameTime.toFixed(1)}ms`;
            document.getElementById('triangleCount').textContent = APP.stats.triangles.toLocaleString();
            document.getElementById('drawCallCount').textContent = APP.stats.drawCalls;
            document.getElementById('memoryUsage').textContent = (performance.memory ? (performance.memory.usedJSHeapSize / 1048576).toFixed(1) : 'N/A') + ' MB';
            
            // Update performance graph
            const performancePercent = Math.min(100, (APP.stats.frameTime / 16.67) * 100);
            document.getElementById('performanceGraph').style.width = `${performancePercent}%`;
        }

        // Start the application
        init().catch(console.error);

        // Make functions globally available for UI
        window.toggleWireframe = toggleWireframe;
        window.toggleNormals = toggleNormals;
        window.toggleBounds = toggleBounds;
        window.exportScene = exportScene;
        window.switchScene = switchScene;
        window.takeScreenshot = takeScreenshot;
        window.toggleUI = toggleUI;
        window.clearLog = clearLog;
    </script>
</body>
</html>
