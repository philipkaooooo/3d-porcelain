<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Porcelain Transcendence — Five Scenes Engine (VFX Reintegration)</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body, #container { height: 100%; width: 100%; }
    body { background: #000; color: #fff; font-family: Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial; overflow: hidden; }
    #container { position: fixed; inset: 0; }
    canvas { display: block; touch-action: none; }
    .ui { position: absolute; z-index: 60; inset: 0; pointer-events: none; }
    .panel { pointer-events: auto; position: absolute; background: rgba(0,0,0,0.45); backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,0.06); padding: 10px 12px; border-radius: 10px; font-size: 13px; line-height: 1.4; }
    .top-left { left: 16px; top: 16px; } .top-right { right: 16px; top: 16px; text-align: right; }
    .bottom-left { left: 16px; bottom: 16px; }
    .scene-indicator { font-weight: 600; opacity: .95; }
    .small { font-size: 12px; opacity: .82; }
  </style>
</head>
<body>
  <div id="container" role="application" aria-label="Porcelain Transcendence canvas"></div>

  <div class="ui" aria-hidden="false">
    <div class="panel top-left" role="region" aria-label="Scene information">
      <div id="sceneLabel" class="scene-indicator" role="status" aria-live="polite">Scene 1 / 5 — Dawn Vessel</div>
      <div class="small">← → : Change Scene • SCROLL : Chapters • SPACE : Toggle Motion • Click : Reactive Pulse</div>
    </div>
    <div class="panel top-right" role="region" aria-label="Effects toggles">
      <label><input id="toggleBloom" type="checkbox" checked> Bloom</label><br>
      <label><input id="toggleDOF" type="checkbox"> DOF</label><br>
      <label><input id="toggleParticles" type="checkbox" checked> Particles</label><br>
      <label><input id="toggleAudio" type="checkbox"> Audio Reactive</label>
    </div>
    <div class="panel bottom-left" role="region" aria-label="Controls">
      <div class="small">DRAG: Orbit • PINCH: Zoom • SCROLL: Stage Chapters (0: disperse, 1: assemble, 2: settle, 3: release)</div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
    }
  }
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
  import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
  import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

  // ---------- Engine constants ----------
  const container = document.getElementById('container');
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  const WIDTH = () => window.innerWidth; const HEIGHT = () => window.innerHeight;

  // ---------- Scene / Camera / Renderer ----------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  scene.fog = new THREE.FogExp2(0x000010, 0.035);

  const camera = new THREE.PerspectiveCamera(45, WIDTH()/HEIGHT(), 0.05, 2000);
  camera.position.set(8, 4.5, 9);

  const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
  renderer.setPixelRatio(DPR); renderer.setSize(WIDTH(), HEIGHT());
  if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace; else renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 0.9;
  renderer.physicallyCorrectLights = true; renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  // ---------- Controls ----------
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.08; controls.enableZoom = false;
  controls.maxPolarAngle = Math.PI * 0.495; controls.minDistance = 1.6; controls.maxDistance = 40;

  // ---------- Post ----------
  const composer = new EffectComposer(renderer); composer.setSize(WIDTH(), HEIGHT()); composer.setPixelRatio(DPR);
  composer.addPass(new RenderPass(scene, camera));
  const bloomPass = new UnrealBloomPass(new THREE.Vector2(WIDTH(), HEIGHT()), 0.55, 0.6, 0.85); composer.addPass(bloomPass);
  const bokehPass = new BokehPass(scene, camera, { focus:20.0, aperture:0.0009, maxblur:0.01, width:WIDTH(), height:HEIGHT() });
  bokehPass.enabled = false; composer.addPass(bokehPass);
  const smaaPass = new SMAAPass(WIDTH(), HEIGHT()); composer.addPass(smaaPass);

  // ---------- Environment ----------
  let pmrem = new THREE.PMREMGenerator(renderer); pmrem.compileEquirectangularShader();
  let currentEnv = null; function setEnv(tex){ if(currentEnv && currentEnv.dispose){ try{ currentEnv.dispose(); }catch(e){} } currentEnv = tex; scene.environment = tex; }
  // quick placeholder env
  (function bakePlaceholder(){ const urls = new Array(6).fill('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==');
    const cube = new THREE.CubeTextureLoader().load(urls, ()=>{ const env = pmrem.fromCubemap(cube).texture; try{ cube.dispose(); }catch(e){} setEnv(env); }); })();
  new RGBELoader().setDataType(THREE.UnsignedByteType).load('textures/studio_small_04_1k.hdr', (hdr)=>{
    hdr.mapping = THREE.EquirectangularReflectionMapping; const env = pmrem.fromEquirectangular(hdr).texture; try{ hdr.dispose && hdr.dispose(); }catch(e){}
    setEnv(env); try{ pmrem.dispose(); }catch(e){} pmrem = new THREE.PMREMGenerator(renderer);
  }, undefined, ()=>{});

  // ---------- Ground / Disc ----------
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(400,400), new THREE.MeshStandardMaterial({ color:0x040405, roughness:0.85 }));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
  const discMat = new THREE.MeshStandardMaterial({ color:0x0e0e10, roughness:0.45, metalness:0.04, transparent:true, opacity:1 });
  const disc = new THREE.Mesh(new THREE.CircleGeometry(10,64), discMat); disc.rotation.x = -Math.PI/2; disc.position.y = 0.001; disc.receiveShadow = true; scene.add(disc);

  // ---------- Cursor visuals ----------
  function makeGlow(size=512,color='#fff3d9'){ const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
    const g=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2); g.addColorStop(0,color); g.addColorStop(0.25,color); g.addColorStop(0.6,'rgba(255,243,217,.45)'); g.addColorStop(1,'rgba(255,243,217,0)');
    ctx.fillStyle=g; ctx.fillRect(0,0,size,size); const tx=new THREE.CanvasTexture(c); tx.minFilter=THREE.LinearFilter; tx.magFilter=THREE.LinearFilter; return tx; }
  const cursorLight = new THREE.PointLight(0xfff7ea, 0.0, 28, 2.2); scene.add(cursorLight);
  const cursorBall = new THREE.Mesh(new THREE.SphereGeometry(0.06,12,12), new THREE.MeshBasicMaterial({ color:0xfff3d9 })); cursorBall.frustumCulled=false; scene.add(cursorBall);
  const glow = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeGlow(512,'#fff3d9'), blending:THREE.AdditiveBlending, opacity:0.65, transparent:true, depthWrite:false }));
  glow.scale.setScalar(0.8); scene.add(glow);

  // ---------- Reactive pulses (pool) ----------
  const pulsePool=[]; const activePulses=[];
  function createPulse(count=80){ const g=new THREE.BufferGeometry(); const pos=new Float32Array(count*3), vel=new Float32Array(count*3);
    g.setAttribute('position', new THREE.BufferAttribute(pos,3)); g.setAttribute('vel', new THREE.BufferAttribute(vel,3));
    const m=new THREE.Points(g, new THREE.PointsMaterial({ size:0.05, color:0xfff0d8, transparent:true, opacity:1, depthWrite:false })); m.userData={life:0,count}; return m; }
  function getPulse(){ return pulsePool.length ? pulsePool.pop() : createPulse(80); }
  function recyclePulse(p){ p.visible=false; p.userData.life=0; pulsePool.push(p); }
  function spawnPulse(pos3, color=0xfff0d8, count=80){ const p=getPulse(); const A=p.geometry.attributes; if(A.position.count!==count){ p.geometry.dispose(); p.geometry=new THREE.BufferGeometry(); p.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(count*3),3)); p.geometry.setAttribute('vel', new THREE.BufferAttribute(new Float32Array(count*3),3)); }
    const P=p.geometry.attributes.position.array, V=p.geometry.attributes.vel.array; for(let i=0;i<count;i++){ const phi=Math.acos(2*Math.random()-1), th=Math.random()*Math.PI*2, r=0.02+Math.random()*0.08;
      P[i*3]=pos3.x+r*Math.sin(phi)*Math.cos(th); P[i*3+1]=pos3.y+r*Math.cos(phi); P[i*3+2]=pos3.z+r*Math.sin(phi)*Math.sin(th);
      V[i*3]=(Math.random()-0.5)*0.9; V[i*3+1]=Math.random()*1.2+0.2; V[i*3+2]=(Math.random()-0.5)*0.9; }
    p.geometry.attributes.position.needsUpdate=true; p.geometry.attributes.vel.needsUpdate=true; p.material.color.setHex(color); p.userData.life=1; p.visible=true; if(!p.parent) scene.add(p); activePulses.push(p); }

  // ---------- Particle sprite (for points shader) ----------
  function makeBokeh(size=256){ const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d'); const cx=size/2,cy=size/2; const g=ctx.createRadialGradient(cx,cy,0,cx,cy,size/2);
    g.addColorStop(0,'#fff'); g.addColorStop(.3,'#fff'); g.addColorStop(.7,'rgba(255,255,255,.35)'); g.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=g; ctx.fillRect(0,0,size,size); const t=new THREE.CanvasTexture(c); t.minFilter=THREE.LinearFilter; t.magFilter=THREE.LinearFilter; return t; }
  const pointMap = makeBokeh(256);

  // ---------- Morphable particle system (Points + MeshSurfaceSampler) ----------
  function createMorphParticles(targetMesh, count=2000){
    // sample positions on the porcelain surface
    const sampler = new MeshSurfaceSampler(targetMesh).build();
    const target = new Float32Array(count*3);
    const tmpPos = new THREE.Vector3(); const tmpNorm = new THREE.Vector3();
    for(let i=0;i<count;i++){ sampler.sample(tmpPos, tmpNorm); target[i*3]=tmpPos.x; target[i*3+1]=tmpPos.y; target[i*3+2]=tmpPos.z; }

    // starting positions: dispersed sphere shell around object
    const start = new Float32Array(count*3); const phase = new Float32Array(count); const size = new Float32Array(count);
    for(let i=0;i<count;i++){ const u=Math.random(), v=Math.random(); const th=2*Math.PI*u, ph=Math.acos(2*v-1); const r=4.5 + Math.random()*4.0;
      start[i*3]=Math.sin(ph)*Math.cos(th)*r; start[i*3+1]=Math.cos(ph)*r*0.7; start[i*3+2]=Math.sin(ph)*Math.sin(th)*r; phase[i]=Math.random()*Math.PI*2; size[i]=THREE.MathUtils.lerp(0.9, 2.6, Math.random()); }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('start', new THREE.BufferAttribute(start,3));
    geo.setAttribute('target', new THREE.BufferAttribute(target,3));
    geo.setAttribute('phase', new THREE.BufferAttribute(phase,1));
    geo.setAttribute('psize', new THREE.BufferAttribute(size,1));

    const mat = new THREE.ShaderMaterial({
      transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
      uniforms:{ uTime:{value:0}, uAssemble:{value:0}, uColorGrade:{value:new THREE.Vector3(1,1,1)}, uOpacity:{value:0.85}, pointMap:{value:pointMap} },
      vertexShader:`
        attribute vec3 start; attribute vec3 target; attribute float phase; attribute float psize;
        uniform float uTime; uniform float uAssemble; varying float vAlpha; varying float vPulse; varying float vAssemble;
        void main(){
          float t = uAssemble; // 0..1
          // ease-in assemble curve (like grass growing fast)
          float a = smoothstep(0.0, 1.0, t);
          vec3 pos = mix(start, target, a);
          // add a gentle swirl during assembly
          float swirl = (1.0 - a) * 0.8;
          pos.x += sin(phase + uTime*0.8) * swirl;
          pos.z += cos(phase + uTime*0.9) * swirl;
          // breathing when settled
          float breath = a * 0.2 * sin(uTime*1.5 + phase);
          pos.y += breath;
          vec4 mv = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mv;
          // perspective-correct point size
          float dist = -mv.z; gl_PointSize = psize * (300.0 / max(1.0, dist));
          vAlpha = mix(0.5, 1.0, a);
          vPulse = breath; vAssemble = a;
        }
      `,
      fragmentShader:`
        uniform sampler2D pointMap; uniform vec3 uColorGrade; uniform float uOpacity; varying float vAlpha; varying float vPulse; varying float vAssemble;
        void main(){
          vec2 uv = gl_PointCoord; vec4 s = texture2D(pointMap, uv);
          // subtle chroma grading
          vec3 col = s.rgb * mix(vec3(1.0), uColorGrade, 0.5);
          float a = s.a * uOpacity * vAlpha;
          if(a < 0.02) discard; gl_FragColor = vec4(col, a);
        }
      `
    });

    const points = new THREE.Points(geo, mat); points.frustumCulled = false; return points;
  }

  // ---------- Scene class ----------
  class PorcelainScene {
    constructor({ id=0, name='Untitled', palette, make, chapters=4, rail }){
      this.id=id; this.name=name; this.palette=palette; this.make=make; this.chapters=chapters; this.rail=rail;
      this.group = new THREE.Group(); this.meshCache=[]; this.motionEnabled=true;
      // lights
      this.hemi = new THREE.HemisphereLight(0xddddff,0x0a0a0d,0.45); this.group.add(this.hemi);
      this.key = new THREE.DirectionalLight((palette&&palette.key)||0xffffff, 1.8); this.key.castShadow=true; this.key.shadow.mapSize.set(1024,1024); this.key.shadow.bias=-0.0005; this.key.position.set(6,10,6); this.group.add(this.key);
      this.fill = new THREE.DirectionalLight(0x8fb3ff,0.45); this.group.add(this.fill);
      this.rim  = new THREE.DirectionalLight(0xffe6d0,0.6); this.group.add(this.rim);
      // porcelain
      this.porcelain = this.make();
      this.porcelain.traverse(o=>{ if(o.isMesh){ o.castShadow=o.receiveShadow=true; this.meshCache.push(o);
        if(!(o.material && o.material.isMeshPhysicalMaterial)) o.material = new THREE.MeshPhysicalMaterial({ color: (o.material&&o.material.color)||0xffffff, roughness:0.06, clearcoat:1.0, envMap:scene.environment, envMapIntensity:1.2 }); }});
      this.group.add(this.porcelain);
      // scale & ground it
      const box=new THREE.Box3().setFromObject(this.group), size=box.getSize(new THREE.Vector3()), center=box.getCenter(new THREE.Vector3()); this.group.position.sub(center);
      const maxDim=Math.max(size.x,size.y,size.z), s=maxDim>0? (4.6/maxDim):1; this.group.scale.setScalar(s); this.group.updateWorldMatrix(true,true);
      const box2=new THREE.Box3().setFromObject(this.group); this.group.position.y -= box2.min.y;
      // tighten shadows
      const b=new THREE.Box3().setFromObject(this.group).getSize(new THREE.Vector3()); const pad=Math.max(.5, Math.min(b.length()*0.25,2.0));
      try{ this.key.shadow.camera.left=-b.x/2-pad; this.key.shadow.camera.right=b.x/2+pad; this.key.shadow.camera.top=b.y/2+pad; this.key.shadow.camera.bottom=-b.y/2-pad; this.key.shadow.camera.updateProjectionMatrix(); }catch(e){}
      // particles that can morph to porcelain
      this.particles = createMorphParticles(this.porcelain, 1800);
      this.particles.material.uniforms.uColorGrade.value = (palette&&palette.grade) || new THREE.Vector3(1,1,1);
      this.group.add(this.particles);
    }

    enter(){
      const bg = this.palette?.bg ?? 0x000000; gsap.to(scene.background, { r:((bg>>16)&255)/255, g:((bg>>8)&255)/255, b:(bg&255)/255, duration:0.9 });
      gsap.fromTo(this.key, { intensity:0.0 }, { intensity:1.8, duration:0.9 });
      gsap.fromTo(this.rim, { intensity:0.0 }, { intensity:0.6, duration:0.9, delay:0.1 });
      gsap.fromTo(this.fill,{ intensity:0.0 }, { intensity:0.45, duration:0.9, delay:0.12 });
      // assemble timeline (cinematic): disperse -> swirl hint -> converge -> settle
      const uA = this.particles.material.uniforms.uAssemble;
      gsap.fromTo(uA, { value:0.0 }, { value:1.0, duration:1.4, ease:'power3.inOut' });
      gsap.fromTo(bloomPass, { strength:0.25 }, { strength:0.55, duration:1.0, ease:'sine.inOut' });
      // set camera to rail
      if(this.rail){ gsap.to(camera.position, { x:this.rail.position.x, y:this.rail.position.y, z:this.rail.position.z, duration:1.1, ease:'expo.inOut', onUpdate:()=>controls.update() });
        gsap.to(controls.target, { x:this.rail.target.x, y:this.rail.target.y, z:this.rail.target.z, duration:1.1, ease:'expo.inOut', onUpdate:()=>controls.update() }); }
      // disc tint
      const gc=this.palette?.ground||0x0e0e10; const gcr=((gc>>16)&255)/255*0.15, gcg=((gc>>8)&255)/255*0.15, gcb=(gc&255)/255*0.15;
      gsap.to(disc.material.color, { r:gcr, g:gcg, b:gcb, duration:0.9 });
    }
    exit(){ gsap.to(this.key, { intensity:0.0, duration:0.7 }); gsap.to(this.fill,{ intensity:0.0, duration:0.6 }); gsap.to(this.rim,{ intensity:0.0, duration:0.6 }); }
    update(dt, elapsed, cursorWorld, cursorIntensity){
      if(this.particles) this.particles.material.uniforms.uTime.value = elapsed;
      if(this.motionEnabled) this.porcelain.rotation.y += dt * (0.09 + this.id*0.02);
      // highlight response
      if(cursorWorld && cursorIntensity>0.02){ for(const m of this.meshCache){ const w=new THREE.Vector3(); m.getWorldPosition(w); const d=Math.min(1.0, cursorWorld.distanceTo(w)/4.5); const effect=1.0-d; const env0=m.material.envMapIntensity||1.2;
          m.material.envMapIntensity = THREE.MathUtils.lerp(m.material.envMapIntensity, env0 + 2.2*effect*cursorIntensity, 0.18); } }
    }
    toggleMotion(flag){ this.motionEnabled = flag; }
  }

  // ---------- Procedural porcelain makers ----------
  function makeVesselA(){ const pts=[]; for(let i=0;i<20;i++){ const t=i/19; pts.push(new THREE.Vector2(0.6+Math.sin(t*Math.PI)*0.8*(0.5+0.5*t), -1+t*2.2)); }
    const geo=new THREE.LatheGeometry(pts,128); const m=new THREE.Mesh(geo,new THREE.MeshPhysicalMaterial({ color:0xf7f8fb, roughness:0.06, clearcoat:1.0, envMap:scene.environment })); return m; }
  function makePlateB(){ const ring=new THREE.RingGeometry(0.5,2.0,128); const bowl=new THREE.SphereGeometry(2.2,128,128,0,Math.PI*2,0,Math.PI/2); bowl.scale(1,0.38,1);
    const mat=new THREE.MeshPhysicalMaterial({ color:0xeaf6ff, roughness:0.03, clearcoat:1.0, envMap:scene.environment }); const g=new THREE.Group(); const rim=new THREE.Mesh(ring,mat.clone()); rim.rotation.x=-Math.PI/2; rim.position.y=0.01; const center=new THREE.Mesh(bowl,mat.clone()); center.position.y=0.02; g.add(center,rim); return g; }
  function makeMiniSculptC(){ const geo=new THREE.TorusKnotGeometry(0.9,0.25,256,32,2,3); geo.rotateX(Math.PI*0.1); return new THREE.Mesh(geo,new THREE.MeshPhysicalMaterial({ color:0xffefef, roughness:0.08, clearcoat:1.0, envMap:scene.environment })); }
  function makeTallCylinderD(){ const geo=new THREE.CylinderGeometry(0.8,0.8,3.6,64,1,true); return new THREE.Mesh(geo,new THREE.MeshPhysicalMaterial({ color:0xfffffb, roughness:0.06, clearcoat:1.0, envMap:scene.environment })); }
  function makeBowlE(){ const geo=new THREE.SphereGeometry(1.8,128,128,0,Math.PI*2,0,Math.PI/1.7); geo.scale(1,0.7,1); return new THREE.Mesh(geo,new THREE.MeshPhysicalMaterial({ color:0xe8f2ff, roughness:0.02, clearcoat:0.9, envMap:scene.environment })); }

  // ---------- Scenes ----------
  const scenes = [
    new PorcelainScene({ id:0, name:'Dawn Vessel', palette:{ bg:0x05050A, key:0xfff8e8, grade:new THREE.Vector3(1.05,0.95,0.9), ground:0x2b0702 }, make:makeVesselA, rail:{ position:new THREE.Vector3(6,3.5,6), target:new THREE.Vector3(0,1.1,0) } }),
    new PorcelainScene({ id:1, name:'Calm Mirror', palette:{ bg:0x071022, key:0xdfefff, grade:new THREE.Vector3(0.95,1.02,1.05), ground:0x031022 }, make:makePlateB, rail:{ position:new THREE.Vector3(5.5,2.8,5.8), target:new THREE.Vector3(0,0.85,0) } }),
    new PorcelainScene({ id:2, name:'Whim', palette:{ bg:0x10040a, key:0xffefe9, grade:new THREE.Vector3(1.06,0.96,1.05), ground:0x2a0507 }, make:makeMiniSculptC, rail:{ position:new THREE.Vector3(7,3.4,7), target:new THREE.Vector3(0,0.8,0) } }),
    new PorcelainScene({ id:3, name:'Echo Column', palette:{ bg:0x071011, key:0xfffff6, grade:new THREE.Vector3(1.0,0.98,1.05), ground:0x062b19 }, make:makeTallCylinderD, rail:{ position:new THREE.Vector3(6.2,3.8,6.2), target:new THREE.Vector3(0,1.4,0) } }),
    new PorcelainScene({ id:4, name:'Night Bloom', palette:{ bg:0x040618, key:0xe6f0ff, grade:new THREE.Vector3(0.92,0.98,1.08), ground:0x180226 }, make:makeBowlE, rail:{ position:new THREE.Vector3(7.5,3.6,7.8), target:new THREE.Vector3(0,0.9,0) } })
  ];

  // ---------- Mount first scene ----------
  let currentIndex = 0; scene.add(scenes[0].group); scenes[0].enter();
  const sceneLabel = document.getElementById('sceneLabel'); function updateSceneLabel(i){ sceneLabel.textContent = `Scene ${i+1} / 5 — ${scenes[i].name}`; } updateSceneLabel(0);

  // ---------- Transition crossfade + assemble ----------
  let transitioning=false; function prepareFade(group){ group.traverse(o=>{ if(o.isMesh && o.material && !o.material.__pf){ o.material.__pf=true; o.material.__origTransparent=o.material.transparent; o.material.__origOpacity=(o.material.opacity!==undefined)?o.material.opacity:1.0; o.material.transparent=true; } }); }
  function fadeGroup(group,to,d=0.9){ group.traverse(o=>{ if(o.isMesh && o.material && o.material.__pf){ gsap.to(o.material,{ opacity:to, duration:d, ease:'power2.inOut' }); } }); }
  function restoreFade(group){ group.traverse(o=>{ if(o.isMesh && o.material && o.material.__pf){ gsap.to(o.material,{ opacity:o.material.__origOpacity||1.0, duration:0.02, onComplete:()=>{ o.material.transparent=o.material.__origTransparent; delete o.material.__origTransparent; delete o.material.__origOpacity; delete o.material.__pf; } }); } }); }
  function freezeGround(flag){ gsap.to(disc.material,{ opacity: flag?0.6:1.0, duration:0.6 }); }

  function gotoScene(index){ if(transitioning || index===currentIndex || index<0 || index>=scenes.length) return; transitioning=true; const from=scenes[currentIndex], to=scenes[index]; if(!to.group.parent) scene.add(to.group);
    prepareFade(from.group); prepareFade(to.group); to.group.traverse(o=>{ if(o.isMesh && o.material) o.material.opacity=0.0; }); controls.enabled=false; freezeGround(true);
    const tl=gsap.timeline({ onComplete:()=>{ scene.remove(from.group); restoreFade(from.group); restoreFade(to.group); currentIndex=index; updateSceneLabel(index); transitioning=false; controls.enabled=true; freezeGround(false); } });
    // Camera rail
    tl.to(camera.position, { x:to.rail.position.x, y:to.rail.position.y, z:to.rail.position.z, duration:1.1, ease:'expo.inOut', onUpdate:()=>controls.update() }, 0);
    tl.to(controls.target, { x:to.rail.target.x, y:to.rail.target.y, z:to.rail.target.z, duration:1.1, ease:'expo.inOut', onUpdate:()=>controls.update() }, 0);
    // Crossfade + re-assemble new scene
    tl.add(()=>from.exit(), 0.02);
    tl.add(()=>{ to.enter(); to.particles.material.uniforms.uAssemble.value = 0.0; gsap.to(to.particles.material.uniforms.uAssemble, { value:1.0, duration:1.2, ease:'power3.inOut' }); }, 0.02);
    tl.add(()=>fadeGroup(from.group,0.0,0.9),0.04); tl.add(()=>fadeGroup(to.group,1.0,1.0),0.06);
  }

  // ---------- Input handling ----------
  function isOverUI(event){ const el=document.elementFromPoint(event.clientX, event.clientY); return el && el.closest && el.closest('.panel'); }
  const rect = ()=>renderer.domElement.getBoundingClientRect();
  const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2(-10,-10);
  let lastInteractionTime = performance.now();

  function onPointerMove(e){ if(isOverUI(e)) return; const r=rect(); mouse.x=((e.clientX-r.left)/r.width)*2-1; mouse.y=-((e.clientY-r.top)/r.height)*2+1; lastInteractionTime=performance.now(); }
  function onPointerDown(e){ if(isOverUI(e)) return; onPointerMove(e); const pos=computeCursorWorld(); spawnPulse(pos,0xfff0d8,80); }
  renderer.domElement.addEventListener('mousemove', onPointerMove, { passive:true });
  renderer.domElement.addEventListener('pointerdown', onPointerDown, { passive:true });

  // scroll (zoom + chapters)
  let scrollTarget = camera.position.distanceTo(controls.target); let scrollAccum=0; let chapterIndex=0;
  function applyChapter(){ const cur=scenes[currentIndex]; const uA=cur.particles.material.uniforms.uAssemble; const t=chapterIndex; // 0..3
    if(t===0){ gsap.to(uA,{ value:0.0, duration:0.8, ease:'power2.inOut' }); gsap.to(bloomPass,{ strength:0.35, duration:0.6 }); }
    if(t===1){ gsap.to(uA,{ value:0.5, duration:0.9, ease:'power2.inOut' }); gsap.to(bloomPass,{ strength:0.45, duration:0.6 }); }
    if(t===2){ gsap.to(uA,{ value:1.0, duration:1.0, ease:'power2.inOut' }); gsap.to(bloomPass,{ strength:0.55, duration:0.8 }); }
    if(t===3){ // soft release (oscillate a bit around 0.85..1)
      gsap.to(uA,{ value:0.85, duration:0.8, yoyo:true, repeat:1, ease:'sine.inOut' }); gsap.to(bloomPass,{ strength:0.5, duration:0.6 }); }
  }
  renderer.domElement.addEventListener('wheel', (e)=>{
    if(isOverUI(e)) return; e.preventDefault(); const delta=e.deltaY*0.003; scrollTarget += delta*6.0; scrollTarget = THREE.MathUtils.clamp(scrollTarget, controls.minDistance, controls.maxDistance);
    scrollAccum += (e.deltaY>0?1:-1); if(Math.abs(scrollAccum)>=2){ chapterIndex = THREE.MathUtils.clamp(chapterIndex + Math.sign(scrollAccum), 0, 3); scrollAccum=0; applyChapter(); }
  }, { passive:false });

  // touch pinch zoom
  let pinch=null; renderer.domElement.addEventListener('touchstart', (e)=>{ if(e.touches?.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY; pinch=Math.hypot(dx,dy); } }, { passive:true });
  renderer.domElement.addEventListener('touchmove', (e)=>{ if(e.touches?.length===2 && pinch){ const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY; const now=Math.hypot(dx,dy); const diff=(pinch-now)*0.0025; scrollTarget += diff*8.0; scrollTarget=THREE.MathUtils.clamp(scrollTarget, controls.minDistance, controls.maxDistance); pinch=now; } }, { passive:true });
  renderer.domElement.addEventListener('touchend', ()=>{ pinch=null; }, { passive:true });

  // keyboard
  window.addEventListener('keydown', (e)=>{ const a=document.activeElement; const typing=a && (a.tagName==='INPUT'||a.tagName==='TEXTAREA'||a.isContentEditable); if(!typing){
    if(e.code==='ArrowRight'){ e.preventDefault(); gotoScene((currentIndex+1)%scenes.length); }
    if(e.code==='ArrowLeft'){ e.preventDefault(); gotoScene((currentIndex-1+scenes.length)%scenes.length); }
    if(e.code==='Space'){ e.preventDefault(); scenes.forEach(s=>s.toggleMotion(!(s.motionEnabled))); }
  } }, { passive:false });

  // ---------- Ray helpers ----------
  const interactPlane = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000), new THREE.MeshBasicMaterial({ visible:false })); interactPlane.rotation.x=-Math.PI/2; interactPlane.position.y=0; scene.add(interactPlane);
  function computeCursorWorld(){ raycaster.setFromCamera(mouse, camera); const cur=scenes[currentIndex]; if(cur&&cur.meshCache.length){ const ints=raycaster.intersectObjects(cur.meshCache,true); if(ints.length) return ints[0].point.clone(); }
    const ints2=raycaster.intersectObject(interactPlane); if(ints2.length) return ints2[0].point.clone(); return new THREE.Vector3(mouse.x,mouse.y,0.5).unproject(camera); }

  // ---------- UI toggles ----------
  let audioReactive=false; document.getElementById('toggleAudio').addEventListener('change', e=>{ audioReactive=e.target.checked; });
  document.getElementById('toggleBloom').addEventListener('change', e=>{ bloomPass.enabled = e.target.checked; });
  document.getElementById('toggleDOF').addEventListener('change', e=>{ bokehPass.enabled = e.target.checked; });
  document.getElementById('toggleParticles').addEventListener('change', e=>{ scenes.forEach(s=>{ if(s.particles) s.particles.visible = e.target.checked; }); });

  // ---------- Resize ----------
  function resize(){ const w=WIDTH(), h=HEIGHT(); camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h); composer.setSize(w,h);
    try{ if(bokehPass?.materialBokeh?.uniforms?.aspect) bokehPass.materialBokeh.uniforms.aspect.value = camera.aspect; else if(bokehPass?.uniforms){ bokehPass.uniforms['width'].value=w; bokehPass.uniforms['height'].value=h; } smaaPass?.setSize(w,h); }catch(e){}
  }
  window.addEventListener('resize', resize);

  // ---------- Render loop ----------
  const clock = new THREE.Clock();
  function animate(){ const dt=Math.min(0.05, clock.getDelta()); const elapsed=clock.getElapsedTime();
    // smooth camera zoom
    const camDir=new THREE.Vector3(); camera.getWorldDirection(camDir); const curDist=camera.position.distanceTo(controls.target);
    const desired=THREE.MathUtils.lerp(curDist, scrollTarget, 0.06); const clamped=THREE.MathUtils.clamp(desired, controls.minDistance, controls.maxDistance);
    const newPos=new THREE.Vector3().copy(camDir).multiplyScalar(-clamped).add(controls.target); camera.position.lerp(newPos, 0.08);

    // cursor highlight visuals
    let cursorWorld=null, cursorIntensity=0; if(mouse.x>-9){ raycaster.setFromCamera(mouse,camera); const cur=scenes[currentIndex]; if(cur&&cur.meshCache.length){ const ints=raycaster.intersectObjects(cur.meshCache,true);
        if(ints.length){ cursorWorld=ints[0].point.clone(); const nd = ints[0].face? ints[0].face.normal.clone().transformDirection(ints[0].object.matrixWorld) : new THREE.Vector3(0,1,0);
          const camVec = new THREE.Vector3().subVectors(camera.position, cursorWorld).normalize(); const align=Math.max(0, nd.dot(camVec)); cursorIntensity = THREE.MathUtils.clamp((1.0 - ints[0].distance/10.0)*align, 0.0, 1.0); }
      }
      if(!cursorWorld){ const ints2=raycaster.intersectObject(interactPlane); if(ints2.length) cursorWorld=ints2[0].point.clone(); }
    }
    const idle = (performance.now()-lastInteractionTime)>900;
    if(cursorWorld && !idle){ const camDist=camera.position.distanceTo(cursorWorld); const camFactor=THREE.MathUtils.clamp(8.0/Math.max(0.001,camDist), 0.0, 1.0);
      const intended = THREE.MathUtils.clamp( (0.04 + cursorIntensity*1.6)*camFactor, 0.04, 1.8 );
      cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, intended, 0.12);
      cursorLight.position.lerp(cursorWorld, 0.18); cursorBall.position.lerp(cursorWorld, 0.18);
      glow.position.lerp(new THREE.Vector3().copy(cursorWorld).add(new THREE.Vector3().subVectors(camera.position,cursorWorld).setLength(0.06)), 0.18);
      glow.material.opacity = THREE.MathUtils.lerp(glow.material.opacity, 0.65*(cursorIntensity*0.85+0.15), 0.12);
      const gS = THREE.MathUtils.lerp(glow.scale.x, 0.3 + cursorIntensity*1.8*camFactor, 0.12); glow.scale.setScalar(gS);
    } else { cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, 0.0, 0.06); glow.material.opacity = THREE.MathUtils.lerp(glow.material.opacity, 0.0, 0.05); }

    // update pulses
    for(let i=activePulses.length-1;i>=0;i--){ const p=activePulses[i]; p.userData.life -= dt*0.8; const posAttr=p.geometry.attributes.position, velAttr=p.geometry.attributes.vel;
      for(let v=0; v<posAttr.count; v++){ posAttr.array[v*3] += velAttr.array[v*3]*dt; posAttr.array[v*3+1] += velAttr.array[v*3+1]*dt; posAttr.array[v*3+2] += velAttr.array[v*3+2]*dt; velAttr.array[v*3+1] -= dt*0.9; }
      posAttr.needsUpdate=true; velAttr.needsUpdate=true; p.material.opacity=Math.max(0,p.userData.life);
      if(p.userData.life<=0){ const idx=activePulses.indexOf(p); if(idx!==-1) activePulses.splice(idx,1); if(p.parent) p.parent.remove(p); recyclePulse(p); }
    }

    // update scene
    scenes[currentIndex].update(dt, elapsed, cursorWorld, cursorIntensity);

    controls.update(); composer.render(); requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  // ---------- Debug helpers ----------
  window.__porcelain = { gotoScene, scenes };

  // expose gotoScene to arrow keys/label updates
  function setScene(i){ gotoScene(i); }

  // update label when scene actually changes (hooked in gotoScene onComplete)

  // ---------- Expose public change API ----------
  window.addEventListener('keydown', (e)=>{ const active=document.activeElement; const typing=active && (active.tagName==='INPUT'||active.tagName==='TEXTAREA'||active.isContentEditable); if(!typing){
    if(e.code==='ArrowRight'){ e.preventDefault(); setScene((currentIndex+1)%scenes.length); }
    if(e.code==='ArrowLeft'){ e.preventDefault(); setScene((currentIndex-1+scenes.length)%scenes.length); }
    if(e.code==='Space'){ e.preventDefault(); scenes.forEach(s=>s.toggleMotion(!(s.motionEnabled))); }
  } });

  </script>
</body>
</html>
