<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Porcelain Transcendence</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html,body { width: 100%; height: 100%; }
        body{
            background:#000;
            color:#fff;
            font-family: Inter, sans-serif;
            overflow:hidden;
            position:fixed;
            width:100%;
            height:100%;
        }
        #container{ position:absolute; width:100%; height:100%; z-index:1; }
        canvas{ position:absolute; top:0; left:0; outline:none; display:block; }
        .ui-overlay{ position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:100; }
        .loading-screen{ position:absolute; inset:0; display:flex; flex-direction:column; justify-content:center; align-items:center; background:#000; z-index:1000; transition:opacity 1s ease; }
        .loading-bar{ width:300px; height:2px; background:rgba(255,255,255,0.08); overflow:hidden; margin-top:20px; }
        .loading-progress{ height:100%; background:linear-gradient(90deg,#ff6b6b,#ffa86b,#ffd86b,#6bffb8,#6bd4ff,#a86bff); width:0%; transition:width 0.3s ease; }
        .hud{ position:absolute; top:20px; left:20px; background:rgba(0,0,0,0.45); padding:10px 15px; border-radius:10px; font-size:12px; pointer-events:auto; backdrop-filter: blur(6px); border:1px solid rgba(255,255,255,0.06);}
        .controls{ position:absolute; bottom:20px; left:20px; background:rgba(0,0,0,0.45); padding:12px; border-radius:10px; font-size:11px; pointer-events:auto; backdrop-filter: blur(6px); border:1px solid rgba(255,255,255,0.06);}
        .title{ position:absolute; top:20px; right:20px; text-align:right; font-size:24px; font-weight:300; opacity:0.85; }
        .effects-panel{ position:absolute; top:80px; right:20px; background:rgba(0,0,0,0.45); padding:12px; border-radius:10px; backdrop-filter: blur(6px); border:1px solid rgba(255,255,255,0.06); font-size:11px; pointer-events:auto;}
        .effect-toggle{ display:flex; align-items:center; margin:6px 0; }
        .effect-toggle input{ margin-right:8px; }
    </style>
</head>
<body>
    <div id="container"></div>

    <div class="loading-screen" id="loadingScreen">
        <div style="font-size:24px;margin-bottom:8px;">PORCELAIN TRANSCENDENCE</div>
        <div style="font-size:14px;opacity:0.7;margin-bottom:16px;">Focused lighting — tunnel vision engaged...</div>
        <div class="loading-bar"><div class="loading-progress" id="loadingProgress"></div></div>
    </div>

    <div class="ui-overlay">
        <div class="hud" id="hud">DRAG: ORBIT • SCROLL: ZOOM • SPACE: TOGGLE ROTATION</div>
        <div class="title">PORCELAIN<br>TRANSCENDENCE</div>

        <div class="effects-panel">
            <div class="effect-toggle"><input type="checkbox" id="bloomToggle" checked><label for="bloomToggle">BLOOM</label></div>
            <div class="effect-toggle"><input type="checkbox" id="cursorLightToggle" checked><label for="cursorLightToggle">CURSOR LIGHT</label></div>
            <div class="effect-toggle"><input type="checkbox" id="particlesToggle" checked><label for="particlesToggle">PARTICLES</label></div>
            <div class="effect-toggle"><input type="checkbox" id="reflectionsToggle" checked><label for="reflectionsToggle">REFLECTIONS</label></div>
            <div class="effect-toggle"><input type="checkbox" id="shadowToggle" checked><label for="shadowToggle">SHADOWS</label></div>
        </div>

        <div class="controls">
            <div>SPACE: Toggle Auto-Rotation</div>
            <div>1-4: Change Material Type</div>
            <div>R: Reset Camera</div>
            <div>F: Toggle Fullscreen</div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

    // ---------- Core ----------
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.05, 2000);
    camera.position.set(8, 5, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
    else renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15;
    renderer.physicallyCorrectLights = true;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // ---------- Controls ----------
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 1.5;
    controls.maxDistance = 40;
    controls.maxPolarAngle = Math.PI * 0.495;

    // ---------- Lighting (realistic baseline) ----------
    // Hemisphere to give realistic sky-to-ground lighting
    const hemi = new THREE.HemisphereLight(0xdde8ff, 0x111018, 0.6);
    scene.add(hemi);

    // Main directional key light (sun-like) with strong shadows
    const mainLight = new THREE.DirectionalLight(0xffffff, 2.6);
    mainLight.position.set(8, 14, 6);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.set(4096, 4096);
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 200;
    mainLight.shadow.camera.left = -30;
    mainLight.shadow.camera.right = 30;
    mainLight.shadow.camera.top = 30;
    mainLight.shadow.camera.bottom = -30;
    mainLight.shadow.bias = -0.0006;
    scene.add(mainLight);

    // Soft fill
    const fillLight = new THREE.DirectionalLight(0x93aaff, 0.7);
    fillLight.position.set(-8, 6, -6);
    scene.add(fillLight);

    // Soft warm rim for highlights
    const rimLight = new THREE.DirectionalLight(0xffe5d6, 0.55);
    rimLight.position.set(0, 6, -10);
    scene.add(rimLight);

    // PMREM generator for environment reflections (keeps highlights crisp)
    const pmrem = new THREE.PMREMGenerator(renderer);
    pmrem.compileEquirectangularShader();

    // Small cube texture placeholder then make a PMREM to ensure env lighting is present
    const envMap = new THREE.CubeTextureLoader().load([
        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=='
    ], () => {
        scene.environment = pmrem.fromCubemap(envMap).texture;
    });

    // ---------- Particles ----------
    const particleCount = 1800;
    const particles = new THREE.BufferGeometry();
    const pos = new Float32Array(particleCount * 3);
    const cols = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount; i++){
        const i3 = i*3;
        const r = 12 + Math.random()*12;
        const t = Math.random()*Math.PI*2;
        const p = Math.acos(2*Math.random()-1);
        pos[i3] = r*Math.sin(p)*Math.cos(t);
        pos[i3+1] = r*Math.cos(p)*0.45;
        pos[i3+2] = r*Math.sin(p)*Math.sin(t);
        const c = new THREE.Color().setHSL(Math.random()*0.16 + 0.5, 0.75, 0.6);
        cols[i3] = c.r; cols[i3+1] = c.g; cols[i3+2] = c.b;
    }
    particles.setAttribute('position', new THREE.BufferAttribute(pos,3));
    particles.setAttribute('color', new THREE.BufferAttribute(cols,3));
    const particleMaterial = new THREE.PointsMaterial({ size:0.18, vertexColors:true, transparent:true, opacity:0.9, blending:THREE.AdditiveBlending, depthWrite:false });
    const particleSystem = new THREE.Points(particles, particleMaterial);
    particleSystem.renderOrder = 1;
    scene.add(particleSystem);

    // ---------- Ground & disc for shading ----------
    const groundGeo = new THREE.PlaneGeometry(300, 300);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x050507, roughness: 0.75, metalness: 0.0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    ground.position.y = 0;
    scene.add(ground);

    // subtle glossy disc under the model for local reflection
    const discGeo = new THREE.CircleGeometry(10, 64);
    const discMat = new THREE.MeshStandardMaterial({ color: 0x0d0d0f, roughness:0.45, metalness:0.06 });
    const disc = new THREE.Mesh(discGeo, discMat);
    disc.rotation.x = -Math.PI/2;
    disc.position.y = 0.001;
    disc.receiveShadow = true;
    scene.add(disc);

    // shadow catcher (soft)
    const shadowMat = new THREE.ShadowMaterial({ opacity: 0.45 });
    const shadowPlane = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), shadowMat);
    shadowPlane.rotation.x = -Math.PI/2;
    shadowPlane.position.y = 0.001;
    shadowPlane.receiveShadow = true;
    scene.add(shadowPlane);

    // ---------- Post-processing ----------
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.1, 0.35, 0.8);
    composer.addPass(bloom);
    const film = new FilmPass(0.28, 0.35, 2048, false);
    composer.addPass(film);

    // subtle custom pass (vignette/aberration)
    const customPass = new ShaderPass({
        uniforms: {
            tDiffuse: { value: null },
            time: { value: 0 },
            resolution: { value: new THREE.Vector2(innerWidth, innerHeight) }
        },
        vertexShader: `
            varying vec2 vUv;
            void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
        `,
        fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform float time;
            uniform vec2 resolution;
            varying vec2 vUv;
            void main(){
                vec2 uv = vUv;
                vec4 color = texture2D(tDiffuse, uv);
                float vign = smoothstep(0.85, 0.2, distance(uv, vec2(0.5)));
                float scan = 1.0 + 0.002 * sin(uv.y * resolution.y * 0.7 + time * 6.0);
                // slight chromatic
                vec2 o = vec2(0.0015 * sin(time), -0.001 * cos(time));
                float r = texture2D(tDiffuse, uv + o).r;
                float g = color.g;
                float b = texture2D(tDiffuse, uv - o).b;
                vec3 c = vec3(r,g,b) * (1.0 - 0.25 * vign) * scan;
                gl_FragColor = vec4(c, 1.0);
            }
        `
    });
    composer.addPass(customPass);

    // ---------- Model loading / scene group ----------
    const loader = new GLTFLoader();
    let porcelainModel = null;
    const modelGroup = new THREE.Group();
    scene.add(modelGroup);

    // An invisible plane used for raycasting (keeps cursor-on-empty-area mapping stable)
    const interactPlane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshBasicMaterial({ visible: false }));
    interactPlane.rotation.x = -Math.PI/2;
    interactPlane.position.y = 0; // will be moved to model base after model loads
    scene.add(interactPlane);

    const loadingScreen = document.getElementById('loadingScreen');
    const loadingProgress = document.getElementById('loadingProgress');

    loader.load('./porcelain.glb',
        (gltf) => {
            porcelainModel = gltf.scene;
            porcelainModel.traverse((child) => {
                if (child.isMesh){
                    child.castShadow = true;
                    child.receiveShadow = true;

                    // convert to PBR while preserving textures
                    const orig = child.material;
                    const baseColor = orig.color ? orig.color.clone() : new THREE.Color(0xffffff);
                    const physical = new THREE.MeshPhysicalMaterial({
                        color: baseColor,
                        roughness: (orig.roughness !== undefined) ? orig.roughness : 0.08,
                        metalness: orig.metalness || 0,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.05,
                        reflectivity: 1.0,
                        transmission: orig.transmission || 0.0,
                        transparent: orig.transparent || false,
                        opacity: orig.opacity !== undefined ? orig.opacity : 1.0,
                        envMapIntensity: 1.0
                    });
                    if (orig.map) physical.map = orig.map;
                    if (orig.normalMap) physical.normalMap = orig.normalMap;
                    if (orig.roughnessMap) physical.roughnessMap = orig.roughnessMap;
                    if (orig.metalnessMap) physical.metalnessMap = orig.metalnessMap;

                    // store original properties for runtime interaction
                    physical.userData = {
                        origRoughness: physical.roughness,
                        origEnvIntensity: physical.envMapIntensity,
                        origClearcoat: physical.clearcoat
                    };

                    child.material = physical;
                }
            });

            modelGroup.add(porcelainModel);

            // center and scale model
            const box = new THREE.Box3().setFromObject(modelGroup);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            modelGroup.position.sub(center);
            const maxDim = Math.max(size.x, size.y, size.z);
            const targetHeight = 5.0;
            const scale = (maxDim > 0) ? (targetHeight / maxDim) : 1;
            modelGroup.scale.setScalar(scale);
            modelGroup.updateWorldMatrix(true, true);

            // recompute bounds and put on ground
            const boxAfter = new THREE.Box3().setFromObject(modelGroup);
            const minY = boxAfter.min.y;
            modelGroup.position.y -= minY;

            // position interactPlane at model base height
            interactPlane.position.y = 0; // matches ground height
            interactPlane.updateMatrixWorld();

            // aim mainLight at model
            mainLight.target = modelGroup;
            scene.add(mainLight.target);

            // frame camera
            const modelHeight = boxAfter.getSize(new THREE.Vector3()).y;
            controls.target.set(0, modelHeight * 0.45, 0);
            controls.update();
            camera.position.set(modelHeight * 1.4, modelHeight * 0.9, modelHeight * 1.4);
            camera.lookAt(controls.target);

            // apply environment map to meshes (if available)
            modelGroup.traverse((c) => {
                if (c.isMesh && c.material && scene.environment){
                    c.material.envMap = scene.environment;
                    c.material.envMapIntensity = c.material.userData.origEnvIntensity || 1.0;
                    c.material.needsUpdate = true;
                }
            });

            // hide loader
            setTimeout(() => { loadingScreen.style.opacity = '0'; setTimeout(()=> loadingScreen.style.display='none', 900); }, 400);
        },
        (xhr) => {
            if (xhr && xhr.lengthComputable){
                const pct = (xhr.loaded / xhr.total) * 100;
                loadingProgress.style.width = pct + '%';
            } else if (xhr && xhr.loaded){
                loadingProgress.style.width = Math.min(95, (xhr.loaded / 1000000) * 100) + '%';
            }
        },
        (err) => {
            console.error(err);
            loadingScreen.innerHTML = '<div style="color:#ff6b6b;">Error loading model — check console</div>';
        }
    );

    // ---------- Cursor Light System ----------
    // A point light and a tight spot combined:
    const cursorLight = new THREE.PointLight(0xfff7ea, 0.0, 26, 2.2);
    cursorLight.castShadow = true;
    cursorLight.shadow.mapSize.set(2048, 2048);
    cursorLight.shadow.camera.near = 0.1;
    cursorLight.shadow.camera.far = 80;
    scene.add(cursorLight);

    // A small visual emissive sphere to show the light source (soft)
    const cursorBall = new THREE.Mesh(
        new THREE.SphereGeometry(0.06, 12, 12),
        new THREE.MeshBasicMaterial({ color: 0xfff1d8, opacity: 1, transparent: true })
    );
    cursorBall.renderOrder = 999;
    scene.add(cursorBall);

    // A soft sprite / glow for the cursor light (additive)
    const spriteMap = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAIUlEQVR4AWMY2NDQwMDAg4GhgYGBgYwAAjCAFgGQZC0gqGQAAED9FJ0g6vG4AAAAASUVORK5CYII=');
    const glowMaterial = new THREE.SpriteMaterial({ map: spriteMap, color: 0xfff1d8, blending: THREE.AdditiveBlending, transparent:true, opacity:0.9, depthWrite:false });
    const glowSprite = new THREE.Sprite(glowMaterial);
    glowSprite.scale.set(0.8, 0.8, 0.8);
    scene.add(glowSprite);

    // Additional specular spot for crisp highlights
    const cursorSpot = new THREE.SpotLight(0xfff7e6, 0.0, 40, Math.PI * 0.12, 0.2, 2.0);
    cursorSpot.castShadow = true;
    cursorSpot.shadow.mapSize.set(2048, 2048);
    scene.add(cursorSpot);

    // Raycaster and mouse
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(-10, -10); // offscreen initial
    const cursorTarget = new THREE.Vector3();
    let lastInteractionTime = 0;
    let pointerActive = false;

    // Tunables for "tunnel vision" lighting
    const CURSOR_MAX_INTENSITY = 6.4;
    const CURSOR_MIN_INTENSITY = 0.05;
    const CURSOR_FALLOFF = 24;
    const CURSOR_SMOOTH = 0.14; // lerp smoothing

    // Handle pointer input (mouse + touch)
    function updateMouseNDC(event){
        const rect = renderer.domElement.getBoundingClientRect();
        const x = ( (event.clientX - rect.left) / rect.width ) * 2 - 1;
        const y = - ( (event.clientY - rect.top) / rect.height ) * 2 + 1;
        mouse.set(x, y);
    }
    window.addEventListener('mousemove', (e) => {
        updateMouseNDC(e);
        pointerActive = true;
        lastInteractionTime = performance.now();
    }, { passive: true });
    window.addEventListener('pointerdown', (e) => { updateMouseNDC(e); pointerActive = true; lastInteractionTime = performance.now(); }, { passive: true });
    window.addEventListener('pointerup', () => { pointerActive = false; lastInteractionTime = performance.now(); }, { passive: true });

    // When user leaves window, fade out
    window.addEventListener('mouseleave', () => { pointerActive = false; }, { passive: true });

    // ---------- Interaction: map cursor to 3D point ----------
    function computeCursorTarget() {
        // If model exists, prefer intersecting the model meshes so the light skims over geometry
        raycaster.setFromCamera(mouse, camera);
        let intersects = [];
        if (porcelainModel) {
            // collect meshes for intersection
            const meshes = [];
            porcelainModel.traverse((c) => { if (c.isMesh) meshes.push(c); });
            intersects = raycaster.intersectObjects(meshes, true);
        }
        if (intersects && intersects.length > 0) {
            // precise hit on mesh
            cursorTarget.copy(intersects[0].point);
        } else {
            // fallback: intersect with big invisible plane at ground/model base
            const ip = raycaster.intersectObject(interactPlane, true);
            if (ip && ip.length > 0) {
                cursorTarget.copy(ip[0].point);
            } else {
                // as last fallback, project a point in front of camera
                const v = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);
                cursorTarget.copy(v);
            }
        }
    }

    // ---------- Animation & Light-material interaction ----------
    const clock = new THREE.Clock();
    let autoRotate = true;

    function animate(){
        const dt = clock.getDelta();
        const t = clock.getElapsedTime();

        // particle motion
        particleSystem.rotation.y += dt * 0.035;
        particleSystem.rotation.x = Math.sin(t * 0.1) * 0.06;

        // compute desired cursor position
        computeCursorTarget();

        // desired intensity based on pointer activity and proximity
        const now = performance.now();
        const inactiveMs = now - lastInteractionTime;
        const activeFactor = (pointerActive || inactiveMs < 900) ? 1.0 : 0.0;

        // distance-based intensity: if cursor above model, stronger; when away, fade
        let distToModel = 999;
        if (porcelainModel) {
            const worldPos = new THREE.Vector3();
            modelGroup.getWorldPosition(worldPos);
            distToModel = cursorTarget.distanceTo(worldPos);
        } else {
            distToModel = cursorTarget.length();
        }
        // map distance to intensity (closer -> stronger)
        const distFactor = 1.0 - Math.min(1.0, distToModel / CURSOR_FALLOFF);
        const intensityTarget = THREE.MathUtils.lerp(CURSOR_MIN_INTENSITY, CURSOR_MAX_INTENSITY, distFactor) * activeFactor;

        // lerp cursor light position for smoothness
        cursorLight.position.lerp(cursorTarget, CURSOR_SMOOTH * 1.6);
        cursorBall.position.lerp(cursorTarget, CURSOR_SMOOTH * 1.6);
        glowSprite.position.lerp(cursorTarget, CURSOR_SMOOTH * 1.6);
        // offset the sprite slightly toward camera so it is visible
        const camToCursor = new THREE.Vector3().subVectors(camera.position, cursorTarget).setLength(0.08);
        glowSprite.position.add(camToCursor);

        // update spot light to aim at cursor position but with slight offset
        cursorSpot.position.lerp(new THREE.Vector3().copy(cursorTarget).add(new THREE.Vector3(0, 6, 0)), CURSOR_SMOOTH);
        cursorSpot.target.position.lerp(cursorTarget, CURSOR_SMOOTH);
        cursorSpot.target.updateMatrixWorld();

        // smoothly change intensities
        cursorLight.intensity = THREE.MathUtils.lerp(cursorLight.intensity, intensityTarget, CURSOR_SMOOTH * 1.5);
        cursorSpot.intensity = THREE.MathUtils.lerp(cursorSpot.intensity, intensityTarget * 0.22, CURSOR_SMOOTH);
        glowMaterial.opacity = THREE.MathUtils.lerp(glowMaterial.opacity, 0.95 * (intensityTarget / CURSOR_MAX_INTENSITY) + 0.02, CURSOR_SMOOTH * 1.2);

        // Scale glow sprite relative to intensity to amplify "mighty" clarity
        const glowScale = THREE.MathUtils.lerp(glowSprite.scale.x, 0.4 + (intensityTarget / CURSOR_MAX_INTENSITY) * 2.2, CURSOR_SMOOTH);
        glowSprite.scale.setScalar(glowScale);

        // Slight pulsing when active to feel alive
        const pulse = 1.0 + Math.sin(t * 8.0) * 0.02 * (intensityTarget / CURSOR_MAX_INTENSITY);
        cursorBall.scale.lerp(new THREE.Vector3(1,1,1).multiplyScalar(pulse), CURSOR_SMOOTH);

        // high-frequency bloom modulation for more drama
        bloom.strength = 0.9 + Math.sin(t * 1.1) * 0.12 + (intensityTarget / CURSOR_MAX_INTENSITY) * 0.4;

        // Material interaction: change roughness/clearcoat/env map intensity near the cursor to create specular "scan"
        if (porcelainModel && intensityTarget > 0.02) {
            // we only update when the cursor is close for performance
            const meshes = [];
            porcelainModel.traverse((m) => { if (m.isMesh && m.material && m.material.userData) meshes.push(m); });
            for (let i = 0; i < meshes.length; i++){
                const m = meshes[i];
                // compute distance between cursor and mesh world position (cheap approximation)
                const worldPos = new THREE.Vector3();
                m.getWorldPosition(worldPos);
                const d = Math.min(1.0, cursorTarget.distanceTo(worldPos) / 6.0); // normalized 0..1
                // when d small (very close), reduce roughness and pump envMapIntensity + clearcoat for sharp highlight
                const effect = 1.0 - d;
                const origR = m.material.userData.origRoughness ?? 0.08;
                const origE = m.material.userData.origEnvIntensity ?? 1.0;
                const origC = m.material.userData.origClearcoat ?? 1.0;
                // compute dynamic properties
                const targetRough = THREE.MathUtils.clamp(origR * (0.2 + (1 - effect) * 1.0), 0.02, 1.0);
                const targetEnv = THREE.MathUtils.lerp(origE, origE + 3.0 * effect * (intensityTarget / CURSOR_MAX_INTENSITY), 0.9);
                const targetClearcoat = THREE.MathUtils.lerp(origC, Math.min(1.0, origC + 0.6 * effect), 0.9);
                // lerp into material
                m.material.roughness = THREE.MathUtils.lerp(m.material.roughness, targetRough, 0.25);
                m.material.envMapIntensity = THREE.MathUtils.lerp(m.material.envMapIntensity || origE, targetEnv, 0.25);
                m.material.clearcoat = THREE.MathUtils.lerp(m.material.clearcoat || origC, targetClearcoat, 0.25);
                m.material.needsUpdate = true;
            }
        } else if (porcelainModel) {
            // gently restore materials when cursor not active
            porcelainModel.traverse((m) => {
                if (m.isMesh && m.material && m.material.userData){
                    m.material.roughness = THREE.MathUtils.lerp(m.material.roughness, m.material.userData.origRoughness ?? 0.08, 0.04);
                    m.material.envMapIntensity = THREE.MathUtils.lerp(m.material.envMapIntensity || (m.material.userData.origEnvIntensity||1.0), m.material.userData.origEnvIntensity||1.0, 0.03);
                    m.material.clearcoat = THREE.MathUtils.lerp(m.material.clearcoat || (m.material.userData.origClearcoat||1.0), m.material.userData.origClearcoat||1.0, 0.03);
                    m.material.needsUpdate = true;
                }
            });
        }

        // Auto rotation of the whole group for "gallery" feel
        if (autoRotate && porcelainModel) modelGroup.rotation.y += dt * 0.16;

        controls.update();
        composer.render();

        requestAnimationFrame(animate);
    }

    // ---------- keyboard & UI ----------
    document.addEventListener('keydown', (ev) => {
        switch(ev.code){
            case 'Space': autoRotate = !autoRotate; break;
            case 'KeyR': controls.reset(); break;
            case 'KeyF': toggleFullscreen(); break;
            case 'Digit1': changeMaterialType(0); break;
            case 'Digit2': changeMaterialType(1); break;
            case 'Digit3': changeMaterialType(2); break;
            case 'Digit4': changeMaterialType(3); break;
        }
    });

    function changeMaterialType(type){
        if (!porcelainModel) return;
        porcelainModel.traverse((child) => {
            if (child.isMesh && child.material){
                const mat = child.material;
                switch(type){
                    case 0: mat.roughness = 0.08; mat.metalness = 0.0; mat.clearcoat = 1.0; mat.transmission = 0.0; break;
                    case 1: mat.roughness = 0.25; mat.metalness = 1.0; mat.clearcoat = 0.0; mat.transmission = 0.0; break;
                    case 2: mat.roughness = 0.02; mat.metalness = 0.0; mat.clearcoat = 0.2; mat.transmission = 0.9; mat.transparent = true; mat.opacity = 0.95; break;
                    case 3: mat.roughness = 0.04; mat.metalness = 0.18; mat.clearcoat = 0.9; break;
                }
                mat.needsUpdate = true;
            }
        });
    }

    function toggleFullscreen(){
        if (!document.fullscreenElement) container.requestFullscreen().catch(e => console.warn(e));
        else document.exitFullscreen();
    }

    // wire the UI toggles
    const bloomToggle = document.getElementById('bloomToggle');
    const cursorLightToggle = document.getElementById('cursorLightToggle');
    const particlesToggle = document.getElementById('particlesToggle');
    const reflectionsToggle = document.getElementById('reflectionsToggle');
    const shadowToggle = document.getElementById('shadowToggle');

    bloomToggle.addEventListener('change', () => bloom.enabled = bloomToggle.checked);
    cursorLightToggle.addEventListener('change', () => {
        cursorLight.visible = cursorBall.visible = glowSprite.visible = cursorSpot.visible = cursorLightToggle.checked;
        // also toggle intensity quick-fade when disabled
        if (!cursorLightToggle.checked) { cursorLight.intensity = 0.0; cursorSpot.intensity = 0.0; glowMaterial.opacity = 0.0; }
    });
    particlesToggle.addEventListener('change', () => particleSystem.visible = particlesToggle.checked);
    reflectionsToggle.addEventListener('change', () => {
        if (!porcelainModel) return;
        porcelainModel.traverse((m) => {
            if (m.isMesh && m.material) {
                m.material.envMap = reflectionsToggle.checked ? scene.environment : null;
                m.material.needsUpdate = true;
            }
        });
    });
    shadowToggle.addEventListener('change', () => {
        const v = shadowToggle.checked;
        mainLight.castShadow = v;
        cursorLight.castShadow = v;
        cursorSpot.castShadow = v;
        porcelainModel && porcelainModel.traverse((m) => { if (m.isMesh) { m.castShadow = v; m.receiveShadow = v; } });
    });

    // ---------- mouse/touch for mobile ----------
    window.addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
        composer.setSize(innerWidth, innerHeight);
        customPass.uniforms.resolution.value.set(innerWidth, innerHeight);
    });

    // Start
    requestAnimationFrame(animate);
    </script>
</body>
</html>
