<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Porcelain Transcendence - Developer Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            height: 100vh;
            color: #00ff88;
        }

        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
        }

        /* Developer UI */
        .dev-ui {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
        }

        .panel {
            background: rgba(0, 20, 10, 0.85);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 15px;
            margin: 10px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .stats-panel {
            top: 10px;
            right: 10px;
            min-width: 200px;
        }

        .controls-panel {
            bottom: 10px;
            left: 10px;
            min-width: 300px;
        }

        .scene-panel {
            top: 10px;
            left: 10px;
            min-width: 250px;
        }

        .debug-panel {
            bottom: 10px;
            right: 10px;
            min-width: 280px;
            max-height: 200px;
            overflow-y: auto;
        }

        h3 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }

        .stat-label {
            color: #88ffcc;
        }

        .stat-value {
            color: #00ff88;
            font-weight: bold;
        }

        .control-group {
            margin: 10px 0;
        }

        .control-row {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        label {
            font-size: 12px;
            color: #88ffcc;
            margin-right: 10px;
            min-width: 120px;
        }

        input[type="range"] {
            flex: 1;
            background: #003322;
            height: 4px;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #00ff88;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }

        button {
            background: #002211;
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin: 2px;
            transition: all 0.3s;
            font-family: inherit;
        }

        button:hover {
            background: #00ff88;
            color: #002211;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 8px;
        }

        .scene-button {
            flex: 1;
            min-width: 80px;
        }

        .log-entry {
            font-size: 11px;
            margin: 2px 0;
            color: #88ffaa;
            opacity: 0.8;
        }

        .performance-graph {
            height: 40px;
            background: #001a0d;
            border: 1px solid #004422;
            border-radius: 2px;
            margin-top: 5px;
            overflow: hidden;
        }

        .graph-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #88ffcc);
            transition: width 0.3s;
            width: 0%;
        }

        /* Loading screen */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: #00ff88;
            font-family: inherit;
        }

        .loading-bar {
            width: 300px;
            height: 4px;
            background: #003322;
            border-radius: 2px;
            margin-top: 20px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: #00ff88;
            width: 0%;
            transition: width 0.3s ease-out;
        }

        .hotkey {
            display: inline-block;
            background: #002211;
            border: 1px solid #00ff88;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin: 0 2px;
        }

        .water-surface {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            background: linear-gradient(to top, 
                rgba(0, 50, 100, 0.8) 0%,
                rgba(0, 100, 150, 0.4) 50%,
                transparent 100%);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div class="water-surface" id="waterSurface"></div>

    <!-- Loading Screen -->
    <div class="loading" id="loading">
        <h2>PORCELAIN TRANSCENDENCE</h2>
        <p>Developer Edition v2.1.4</p>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
        <p id="loadingText">Initializing core systems...</p>
    </div>

    <!-- Developer UI -->
    <div class="dev-ui">
        <!-- Stats Panel -->
        <div class="panel stats-panel">
            <h3>Performance Metrics</h3>
            <div class="stat">
                <span class="stat-label">FPS:</span>
                <span class="stat-value" id="fpsCounter">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Frame Time:</span>
                <span class="stat-value" id="frameTime">0ms</span>
            </div>
            <div class="stat">
                <span class="stat-label">Triangles:</span>
                <span class="stat-value" id="triangleCount">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Draw Calls:</span>
                <span class="stat-value" id="drawCallCount">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Memory:</span>
                <span class="stat-value" id="memoryUsage">0 MB</span>
            </div>
            <div class="performance-graph">
                <div class="graph-bar" id="performanceGraph"></div>
            </div>
        </div>

        <!-- Controls Panel -->
        <div class="panel controls-panel">
            <h3>Scene Controls</h3>
            <div class="control-group">
                <div class="control-row">
                    <label>Auto Rotate:</label>
                    <input type="checkbox" id="autoRotate" checked>
                </div>
                <div class="control-row">
                    <label>Rotation Speed:</label>
                    <input type="range" id="rotationSpeed" min="0" max="2" step="0.1" value="1">
                </div>
                <div class="control-row">
                    <label>Bloom Intensity:</label>
                    <input type="range" id="bloomIntensity" min="0" max="2" step="0.1" value="0.8">
                </div>
                <div class="control-row">
                    <label>Exposure:</label>
                    <input type="range" id="exposure" min="0.1" max="2" step="0.1" value="1.0">
                </div>
            </div>
            <div class="button-group">
                <button onclick="toggleWireframe()">Wireframe</button>
                <button onclick="toggleParticles()">Particles</button>
                <button onclick="toggleWater()">Water FX</button>
                <button onclick="takeScreenshot()">Screenshot</button>
            </div>
        </div>

        <!-- Scene Panel -->
        <div class="panel scene-panel">
            <h3>Scene Management</h3>
            <div class="control-row">
                <label>Current Scene:</label>
                <span class="stat-value" id="currentScene">1/5</span>
            </div>
            <div class="button-group">
                <button class="scene-button" onclick="switchScene(0)">Vessel</button>
                <button class="scene-button" onclick="switchScene(1)">Plate</button>
                <button class="scene-button" onclick="switchScene(2)">Sculpture</button>
                <button class="scene-button" onclick="switchScene(3)">Column</button>
                <button class="scene-button" onclick="switchScene(4)">Bowl</button>
            </div>
            <div class="control-row">
                <label>Animation:</label>
                <input type="checkbox" id="animationToggle" checked>
            </div>
        </div>

        <!-- Debug Panel -->
        <div class="panel debug-panel">
            <h3>Debug Console</h3>
            <div id="debugLog">
                <div class="log-entry">System initialized</div>
                <div class="log-entry">Ready to load...</div>
            </div>
            <div class="button-group">
                <button onclick="clearLog()">Clear Log</button>
                <button onclick="exportData()">Export Data</button>
                <button onclick="toggleUI()">Hide UI</button>
            </div>
        </div>
    </div>

    <script>
        // Global state management
        const APP = {
            scene: null,
            camera: null,
            renderer: null,
            composer: null,
            controls: null,
            currentScene: 0,
            scenes: [],
            clock: new THREE.Clock(),
            stats: {
                fps: 60,
                frameTime: 0,
                triangles: 0,
                drawCalls: 0,
                lastTime: performance.now(),
                frameCount: 0
            },
            settings: {
                autoRotate: true,
                rotationSpeed: 1.0,
                bloomIntensity: 0.8,
                exposure: 1.0,
                wireframe: false,
                particlesEnabled: true,
                waterEnabled: true
            },
            assets: {
                textures: {},
                models: {}
            }
        };

        // Initialize Three.js and the application
        async function initializeApplication() {
            try {
                updateLoading('Loading Three.js...', 10);
                
                // Import Three.js from CDN
                await loadScript('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js');
                
                updateLoading('Initializing renderer...', 25);
                await initializeRenderer();
                
                updateLoading('Setting up scene...', 45);
                await setupScene();
                
                updateLoading('Creating objects...', 65);
                await createScenes();
                
                updateLoading('Setting up lighting...', 80);
                await setupLighting();
                
                updateLoading('Finalizing...', 95);
                await finalizeSetup();
                
                updateLoading('Ready!', 100);
                
                setTimeout(() => {
                    document.getElementById('loading').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 500);
                }, 1000);
                
                startAnimationLoop();
                
            } catch (error) {
                console.error('Initialization failed:', error);
                updateLoading('Initialization failed: ' + error.message, 0);
            }
        }

        // Utility function to load scripts
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        function updateLoading(text, progress) {
            const loadingText = document.getElementById('loadingText');
            const loadingProgress = document.getElementById('loadingProgress');
            
            if (loadingText) loadingText.textContent = text;
            if (loadingProgress) loadingProgress.style.width = `${progress}%`;
            
            addLogEntry(text);
        }

        function addLogEntry(message) {
            const log = document.getElementById('debugLog');
            if (!log) return;
            
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function clearLog() {
            const log = document.getElementById('debugLog');
            if (log) log.innerHTML = '<div class="log-entry">Log cleared</div>';
        }

        async function initializeRenderer() {
            // Create WebGL renderer
            APP.renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: "high-performance",
                alpha: false
            });
            
            APP.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            APP.renderer.setSize(window.innerWidth, window.innerHeight);
            APP.renderer.outputEncoding = THREE.sRGBEncoding;
            APP.renderer.toneMapping = THREE.ACESFilmicToneMapping;
            APP.renderer.toneMappingExposure = APP.settings.exposure;
            APP.renderer.shadowMap.enabled = true;
            APP.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            document.getElementById('container').appendChild(APP.renderer.domElement);
            
            addLogEntry('WebGL renderer initialized');
        }

        async function setupScene() {
            // Create main scene
            APP.scene = new THREE.Scene();
            APP.scene.background = new THREE.Color(0x000511);
            APP.scene.fog = new THREE.Fog(0x000511, 15, 50);

            // Create camera
            APP.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            APP.camera.position.set(8, 5, 12);

            // Create orbit controls
            APP.controls = new THREE.OrbitControls(APP.camera, APP.renderer.domElement);
            APP.controls.enableDamping = true;
            APP.controls.dampingFactor = 0.05;
            APP.controls.minDistance = 3;
            APP.controls.maxDistance = 50;
            APP.controls.autoRotate = APP.settings.autoRotate;
            APP.controls.autoRotateSpeed = APP.settings.rotationSpeed;

            addLogEntry('Scene and camera setup complete');
        }

        async function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404060, 0.4);
            APP.scene.add(ambientLight);

            // Directional light
            const directionalLight = new THREE.DirectionalLight(0xfff0e0, 1.2);
            directionalLight.position.set(10, 15, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            APP.scene.add(directionalLight);

            // Hemisphere light
            const hemisphereLight = new THREE.HemisphereLight(0x4488ff, 0x224433, 0.3);
            APP.scene.add(hemisphereLight);

            addLogEntry('Lighting system configured');
        }

        async function createScenes() {
            const sceneConfigs = [
                { name: "Dawn Vessel", color: 0xffeebb, scale: 1.2 },
                { name: "Calm Plate", color: 0xbbeeff, scale: 1.0 },
                { name: "Whim Sculpture", color: 0xffbbee, scale: 0.8 },
                { name: "Echo Column", color: 0xeeffbb, scale: 1.5 },
                { name: "Night Bloom", color: 0xbbffee, scale: 1.1 }
            ];

            for (let i = 0; i < sceneConfigs.length; i++) {
                const config = sceneConfigs[i];
                const sceneGroup = new THREE.Group();
                
                // Create geometry based on scene type
                let geometry;
                switch(i) {
                    case 0: // Vessel
                        geometry = createVesselGeometry();
                        break;
                    case 1: // Plate
                        geometry = createPlateGeometry();
                        break;
                    case 2: // Sculpture
                        geometry = createSculptureGeometry();
                        break;
                    case 3: // Column
                        geometry = createColumnGeometry();
                        break;
                    case 4: // Bowl
                        geometry = createBowlGeometry();
                        break;
                }
                
                // Create material
                const material = new THREE.MeshPhysicalMaterial({
                    color: config.color,
                    roughness: 0.1,
                    metalness: 0.0,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.05,
                    transmission: 0.1,
                    transparent: true,
                    opacity: 0.9
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.scale.setScalar(config.scale);
                
                sceneGroup.add(mesh);
                
                // Add particles
                if (APP.settings.particlesEnabled) {
                    addParticleSystem(sceneGroup, i);
                }
                
                // Store scene
                APP.scenes.push({
                    group: sceneGroup,
                    mesh: mesh,
                    config: config,
                    particles: sceneGroup.children.find(child => child.isPoints),
                    animation: {
                        rotationSpeed: 0.3 + Math.random() * 0.4,
                        floatHeight: 0.1 + Math.random() * 0.2,
                        floatSpeed: 0.5 + Math.random() * 1.0
                    }
                });
                
                addLogEntry(`Created scene: ${config.name}`);
            }
            
            // Add first scene
            APP.scene.add(APP.scenes[0].group);
        }

        function createVesselGeometry() {
            const points = [];
            for (let i = 0; i <= 20; i++) {
                const t = i / 20;
                const x = Math.sin(t * Math.PI) * 1.5;
                const y = (t - 0.5) * 3;
                points.push(new THREE.Vector2(x, y));
            }
            return new THREE.LatheGeometry(points, 32);
        }

        function createPlateGeometry() {
            return new THREE.CylinderGeometry(2, 2, 0.2, 64);
        }

        function createSculptureGeometry() {
            return new THREE.TorusKnotGeometry(1, 0.3, 64, 16);
        }

        function createColumnGeometry() {
            return new THREE.CylinderGeometry(0.8, 1, 3, 32);
        }

        function createBowlGeometry() {
            return new THREE.SphereGeometry(1.5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        }

        function addParticleSystem(sceneGroup, sceneIndex) {
            const particleCount = 100;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            const colorPalette = [
                new THREE.Color(0xff6b6b),
                new THREE.Color(0x4ecdc4),
                new THREE.Color(0x45b7d1),
                new THREE.Color(0x96ceb4),
                new THREE.Color(0xffeaa7)
            ];
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const radius = 2 + Math.random() * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i3] = Math.sin(phi) * Math.cos(theta) * radius;
                positions[i3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
                positions[i3 + 2] = Math.cos(phi) * radius;
                
                const color = colorPalette[sceneIndex % colorPalette.length].clone();
                color.multiplyScalar(0.7 + Math.random() * 0.3);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                sizeAttenuation: true
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            sceneGroup.add(particleSystem);
        }

        async function finalizeSetup() {
            // Setup event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            
            // Initialize UI controls
            initializeUIControls();
            
            // Create simple water effect
            createWaterEffect();
            
            addLogEntry('Application fully initialized');
        }

        function createWaterEffect() {
            // Simple CSS-based water surface effect
            const waterSurface = document.getElementById('waterSurface');
            if (waterSurface) {
                waterSurface.style.background = `linear-gradient(to top, 
                    rgba(0, 50, 100, 0.6) 0%,
                    rgba(0, 100, 150, 0.3) 50%,
                    transparent 100%)`;
            }
        }

        function onWindowResize() {
            APP.camera.aspect = window.innerWidth / window.innerHeight;
            APP.camera.updateProjectionMatrix();
            APP.renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            switch(event.key) {
                case 'ArrowRight':
                    switchScene((APP.currentScene + 1) % APP.scenes.length);
                    break;
                case 'ArrowLeft':
                    switchScene((APP.currentScene - 1 + APP.scenes.length) % APP.scenes.length);
                    break;
                case ' ':
                    toggleAnimation();
                    event.preventDefault();
                    break;
                case 'r':
                    resetCamera();
                    break;
                case '1': case '2': case '3': case '4': case '5':
                    switchScene(parseInt(event.key) - 1);
                    break;
            }
        }

        function switchScene(index) {
            if (index === APP.currentScene || index < 0 || index >= APP.scenes.length) return;
            
            // Remove current scene
            APP.scene.remove(APP.scenes[APP.currentScene].group);
            
            // Add new scene
            APP.scene.add(APP.scenes[index].group);
            APP.currentScene = index;
            
            // Update UI
            document.getElementById('currentScene').textContent = `${index + 1}/${APP.scenes.length}`;
            
            addLogEntry(`Switched to scene: ${APP.scenes[index].config.name}`);
        }

        function toggleAnimation() {
            APP.settings.autoRotate = !APP.settings.autoRotate;
            APP.controls.autoRotate = APP.settings.autoRotate;
            document.getElementById('animationToggle').checked = APP.settings.autoRotate;
            addLogEntry(`Animation ${APP.settings.autoRotate ? 'enabled' : 'disabled'}`);
        }

        function resetCamera() {
            APP.controls.reset();
            addLogEntry('Camera reset');
        }

        function initializeUIControls() {
            // Auto rotate
            document.getElementById('autoRotate').addEventListener('change', (e) => {
                APP.settings.autoRotate = e.target.checked;
                APP.controls.autoRotate = APP.settings.autoRotate;
            });
            
            // Rotation speed
            document.getElementById('rotationSpeed').addEventListener('input', (e) => {
                APP.settings.rotationSpeed = parseFloat(e.target.value);
                APP.controls.autoRotateSpeed = APP.settings.rotationSpeed;
            });
            
            // Animation toggle
            document.getElementById('animationToggle').addEventListener('change', (e) => {
                toggleAnimation();
            });
        }

        // Utility functions
        function toggleWireframe() {
            APP.settings.wireframe = !APP.settings.wireframe;
            APP.scenes.forEach(scene => {
                scene.mesh.material.wireframe = APP.settings.wireframe;
            });
            addLogEntry(`Wireframe ${APP.settings.wireframe ? 'enabled' : 'disabled'}`);
        }

        function toggleParticles() {
            APP.settings.particlesEnabled = !APP.settings.particlesEnabled;
            APP.scenes.forEach(scene => {
                if (scene.particles) {
                    scene.particles.visible = APP.settings.particlesEnabled;
                }
            });
            addLogEntry(`Particles ${APP.settings.particlesEnabled ? 'enabled' : 'disabled'}`);
        }

        function toggleWater() {
            APP.settings.waterEnabled = !APP.settings.waterEnabled;
            const waterSurface = document.getElementById('waterSurface');
            if (waterSurface) {
                waterSurface.style.display = APP.settings.waterEnabled ? 'block' : 'none';
            }
            addLogEntry(`Water effects ${APP.settings.waterEnabled ? 'enabled' : 'disabled'}`);
        }

        function takeScreenshot() {
            const canvas = APP.renderer.domElement;
            const link = document.createElement('a');
            link.download = `porcelain-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            addLogEntry('Screenshot saved');
        }

        function exportData() {
            const data = {
                settings: APP.settings,
                sceneCount: APP.scenes.length,
                currentScene: APP.currentScene,
                timestamp: new Date().toISOString()
            };
            const dataStr = JSON.stringify(data, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'porcelain-data.json';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
            addLogEntry('Scene data exported');
        }

        function toggleUI() {
            const ui = document.querySelector('.dev-ui');
            ui.style.display = ui.style.display === 'none' ? 'block' : 'none';
            addLogEntry(`UI ${ui.style.display === 'none' ? 'hidden' : 'shown'}`);
        }

        // Animation loop
        function startAnimationLoop() {
            function animate() {
                requestAnimationFrame(animate);
                
                const delta = APP.clock.getDelta();
                const elapsed = APP.clock.getElapsedTime();
                
                // Update controls
                APP.controls.update();
                
                // Update current scene
                const currentScene = APP.scenes[APP.currentScene];
                if (currentScene) {
                    // Floating animation
                    currentScene.group.position.y = Math.sin(elapsed * currentScene.animation.floatSpeed) * currentScene.animation.floatHeight;
                    
                    // Gentle rotation when not auto-rotating
                    if (!APP.controls.autoRotate) {
                        currentScene.group.rotation.y += delta * currentScene.animation.rotationSpeed * 0.5;
                    }
                    
                    // Particle animation
                    if (currentScene.particles) {
                        currentScene.particles.rotation.y += delta * 0.1;
                    }
                }
                
                // Update stats
                updateStats();
                
                // Render
                APP.renderer.render(APP.scene, APP.camera);
            }
            
            animate();
        }

        function updateStats() {
            const now = performance.now();
            APP.stats.frameCount++;
            
            // Update FPS every second
            if (now >= APP.stats.lastTime + 1000) {
                APP.stats.fps = Math.round((APP.stats.frameCount * 1000) / (now - APP.stats.lastTime));
                APP.stats.frameTime = 1000 / APP.stats.fps;
                APP.stats.frameCount = 0;
                APP.stats.lastTime = now;
                
                // Update UI
                document.getElementById('fpsCounter').textContent = APP.stats.fps;
                document.getElementById('frameTime').textContent = `${APP.stats.frameTime.toFixed(1)}ms`;
                document.getElementById('triangleCount').textContent = APP.renderer.info.render.triangles;
                document.getElementById('drawCallCount').textContent = APP.renderer.info.render.calls;
                
                // Performance graph
                const performancePercent = Math.min(100, (APP.stats.frameTime / 16.67) * 100);
                document.getElementById('performanceGraph').style.width = `${performancePercent}%`;
            }
        }

        // Make functions globally available
        window.toggleWireframe = toggleWireframe;
        window.toggleParticles = toggleParticles;
        window.toggleWater = toggleWater;
        window.switchScene = switchScene;
        window.takeScreenshot = takeScreenshot;
        window.exportData = exportData;
        window.toggleUI = toggleUI;
        window.clearLog = clearLog;

        // Start the application when Three.js is loaded
        if (typeof THREE !== 'undefined') {
            initializeApplication();
        } else {
            // Fallback: Load Three.js and then initialize
            loadScript('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js')
                .then(initializeApplication)
                .catch(error => {
                    console.error('Failed to load Three.js:', error);
                    updateLoading('Failed to load 3D engine', 0);
                });
        }
    </script>
</body>
</html>
